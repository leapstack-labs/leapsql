package components

import (
	"fmt"
)

// TreeNode represents a node in the explorer tree.
type TreeNode struct {
	Name     string
	Path     string
	Type     string // "folder" or "model"
	Children []TreeNode
}

// DashboardStats holds stats for the dashboard view.
type DashboardStats struct {
	ModelCount  int
	SourceCount int
	RunCount    int
}

// ModelViewData holds all data for the model view including all tab content.
type ModelViewData struct {
	// Model info
	Path         string
	Name         string
	FilePath     string
	Materialized string
	Schema       string
	Description  string
	Owner        string
	Tags         []string

	// Tab content (all pre-rendered)
	SourceSQL    string
	CompiledSQL  string
	CompileError string // If compilation failed

	// Preview data (may be nil if not available)
	Preview      *PreviewData
	PreviewError string // If preview query failed
}

// PreviewData holds data preview results.
type PreviewData struct {
	Columns  []string
	Rows     [][]string
	RowCount int
	Limited  bool
}

// ModelContext holds data for the context panel.
type ModelContext struct {
	Path       string
	Name       string
	Type       string
	Schema     string
	DependsOn  []string
	Dependents []string
	Columns    []ColumnData
}

// ColumnData holds column information.
type ColumnData struct {
	Name    string
	Type    string
	Sources []string
}

// GraphViewData holds data for the DAG visualization page.
type GraphViewData struct {
	Nodes []GraphNode
	Edges []GraphEdge
}

// GraphNode represents a node in the graph.
type GraphNode struct {
	ID    string
	Label string
	Type  string // "view", "table", "incremental", "source"
}

// GraphEdge represents an edge between nodes.
type GraphEdge struct {
	Source string
	Target string
}

// RunsViewData holds data for the runs history page.
type RunsViewData struct {
	Runs          []RunListItem
	SelectedRunID string
	SelectedRun   *RunDetailWithTiers
}

// RunListItem is a compact run representation for the list view.
type RunListItem struct {
	ID          string
	Environment string
	Status      string
	StartedAt   string // formatted time string
	Duration    string // formatted duration
	Stats       RunStats
	Error       string
}

// RunStats holds aggregate stats for a run.
type RunStats struct {
	TotalModels   int
	Succeeded     int
	Failed        int
	Skipped       int
	Pending       int
	Running       int
	TotalDuration int64 // milliseconds
}

// TieredModelRun represents a model run with tier information.
type TieredModelRun struct {
	ID           string
	ModelID      string
	ModelPath    string
	ModelName    string
	Status       string
	RowsAffected int64
	ExecutionMS  int64
	RenderMS     int64
	Error        string
	Tier         int // Execution tier (0 = no deps, 1 = depends on tier 0, etc.)
}

// TierGroup represents a group of models at the same execution tier.
type TierGroup struct {
	Tier      int
	Label     string // e.g., "Tier 0: Sources"
	Models    []TieredModelRun
	Stats     TierStats
	Collapsed bool // For tiers not reached due to failure
}

// TierStats holds aggregate stats for a tier.
type TierStats struct {
	TotalModels   int
	Succeeded     int
	Failed        int
	Skipped       int
	Pending       int
	Running       int
	TotalDuration int64 // milliseconds
}

// RunDetailWithTiers holds full run info with tiered model runs.
type RunDetailWithTiers struct {
	ID          string
	Environment string
	Status      string
	StartedAt   string
	CompletedAt string
	Duration    string
	Error       string
	Stats       RunStats
	Tiers       []TierGroup
}

// RunItem represents a run in the list (deprecated, use RunListItem).
type RunItem = RunListItem

// RunDetail holds detailed run information (deprecated, use RunDetailWithTiers).
type RunDetail struct {
	ID          string
	Environment string
	Status      string
	StartedAt   string
	CompletedAt string
	Duration    string
	Error       string
	ModelRuns   []ModelRunItem
}

// ModelRunItem represents a model run within a pipeline run.
type ModelRunItem struct {
	ID           string
	ModelID      string
	ModelName    string
	Status       string
	RowsAffected string
	ExecutionMS  string
	Error        string
}

// QueryViewData holds data for the state query page.
type QueryViewData struct {
	Tables []TableItem
	Views  []TableItem
}

// TableItem represents a table or view in the sidebar.
type TableItem struct {
	Name string
	Type string // "table" or "view"
}

// AppData holds all data needed to render the full app container.
type AppData struct {
	// Current page context
	CurrentPath string // e.g., "/models/staging.customers", "/graph", "/runs"

	// Sidebar data
	ExplorerTree []TreeNode

	// Main content (only one should be set)
	Model *ModelViewData   // for model page
	Stats *DashboardStats  // for dashboard
	Graph *GraphViewData   // for graph page
	Runs  *RunsViewData    // for runs page
	Query *QueryViewData   // for query page

	// Context panel
	Context *ModelContext // nil if no model selected
}

// ThemeControls renders the theme selector and dark mode toggle.
templ ThemeControls() {
	<div class="theme-controls">
		<div class="theme-icons" role="radiogroup" aria-label="Select theme">
			<button
				type="button"
				class="theme-icon"
				data-class:active="$theme === 'claude'"
				data-on:click="$theme = 'claude'; localStorage.setItem('theme', 'claude')"
				title="Claude"
				aria-label="Claude theme"
			>
				<img src="/static/icons/claude.svg" alt="" width="18" height="18"/>
			</button>
			<button
				type="button"
				class="theme-icon"
				data-class:active="$theme === 'vercel'"
				data-on:click="$theme = 'vercel'; localStorage.setItem('theme', 'vercel')"
				title="Vercel"
				aria-label="Vercel theme"
			>
				<img data-show="$darkMode" src="/static/icons/vercel-dark.svg" alt="" width="18" height="18"/>
				<img data-show="!$darkMode" src="/static/icons/vercel-light.svg" alt="" width="18" height="18"/>
			</button>
			<button
				type="button"
				class="theme-icon"
				data-class:active="$theme === 'catppuccin'"
				data-on:click="$theme = 'catppuccin'; localStorage.setItem('theme', 'catppuccin')"
				title="Catppuccin"
				aria-label="Catppuccin theme"
			>
				<img src="/static/icons/catppuccin.png" alt="" width="18" height="18"/>
			</button>
		</div>
		<div class="theme-divider"></div>
		<button
			class="theme-toggle"
			data-on:click="$darkMode = !$darkMode; localStorage.setItem('darkMode', $darkMode)"
			data-attr:aria-label="$darkMode ? 'Switch to light mode' : 'Switch to dark mode'"
			type="button"
		>
			<svg data-show="$darkMode" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
				<circle cx="12" cy="12" r="5"></circle>
				<line x1="12" y1="1" x2="12" y2="3"></line>
				<line x1="12" y1="21" x2="12" y2="23"></line>
				<line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
				<line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
				<line x1="1" y1="12" x2="3" y2="12"></line>
				<line x1="21" y1="12" x2="23" y2="12"></line>
				<line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
				<line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
			</svg>
			<svg data-show="!$darkMode" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
				<path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
			</svg>
		</button>
	</div>
}

templ Header() {
	<header class="ui-header">
		<div class="ui-header__logo">
			<a href="/">LeapSQL</a>
		</div>
		<div class="ui-header__search">
			<input type="text" placeholder="Search models... (Cmd+K)"/>
		</div>
		<div class="ui-header__actions">
			@ThemeControls()
		</div>
	</header>
}

templ Sidebar(explorerTree []TreeNode, currentPath string) {
	<aside class="ui-sidebar">
		<div class="ui-sidebar__section">
			<div class="ui-sidebar__title">Explorer</div>
			@ExplorerTreeView(explorerTree, currentPath)
		</div>
		<div class="ui-sidebar__section">
			<a 
				href="/graph" 
				class={ "tree-item", templ.KV("tree-item--active", currentPath == "/graph") }
			>
				<span>View DAG</span>
			</a>
		</div>
		<div class="ui-sidebar__section">
			<a 
				href="/runs" 
				class={ "tree-item", templ.KV("tree-item--active", currentPath == "/runs") }
			>
				<span>Run History</span>
			</a>
		</div>
		<div class="ui-sidebar__section">
			<a 
				href="/query" 
				class={ "tree-item", templ.KV("tree-item--active", currentPath == "/query") }
			>
				<span>State Query</span>
			</a>
		</div>
	</aside>
}

templ ExplorerTreeView(nodes []TreeNode, currentPath string) {
	<div class="ui-sidebar__tree">
		if len(nodes) == 0 {
			<p class="text-muted">No models found</p>
		} else {
			for _, node := range nodes {
				@TreeItemView(node, currentPath)
			}
		}
	</div>
}

templ TreeItemView(node TreeNode, currentPath string) {
	if node.Type == "folder" {
		<details class="tree-folder" open>
			<summary class="tree-item tree-item--folder">
				<span class="tree-item__icon">+</span>
				<span>{ node.Name }</span>
				<span class="tree-item__count">{ lenStr(node.Children) }</span>
			</summary>
			<div class="tree-folder__children">
				for _, child := range node.Children {
					@TreeItemView(child, currentPath)
				}
			</div>
		</details>
	} else {
		{{
			modelURL := fmt.Sprintf("/models/%s", node.Path)
			isActive := currentPath == modelURL
		}}
		<a 
			href={ templ.SafeURL(modelURL) }
			class={ "tree-item", "tree-item--model", templ.KV("tree-item--active", isActive) }
		>
			<span class="tree-item__icon">~</span>
			<span>{ node.Name }</span>
		</a>
	}
}

templ ContextPanel(mctx *ModelContext) {
	<aside class="ui-context-panel">
		<div class="ui-context-panel__header">Properties</div>
		<div id="context-content">
			if mctx != nil {
				@ModelContextContent(*mctx)
			} else {
				<p class="text-muted">Select a model to view details</p>
			}
		</div>
	</aside>
}

templ ModelContextContent(mctx ModelContext) {
	<div class="model-context">
		<div class="model-context__section">
			<div class="model-context__label">Model</div>
			<div class="model-context__value">{ mctx.Name }</div>
		</div>
		<div class="model-context__section">
			<div class="model-context__label">Type</div>
			<div class="model-context__value">{ materializationLabel(mctx.Type) }</div>
		</div>
		if mctx.Schema != "" {
			<div class="model-context__section">
				<div class="model-context__label">Schema</div>
				<div class="model-context__value">{ mctx.Schema }</div>
			</div>
		}
		if len(mctx.DependsOn) > 0 {
			<div class="model-context__section">
				<div class="model-context__label">Depends On</div>
				<ul class="model-context__list">
					for _, dep := range mctx.DependsOn {
						<li>
							<a href={ templ.SafeURL(fmt.Sprintf("/models/%s", dep)) }>{ dep }</a>
						</li>
					}
				</ul>
			</div>
		}
		if len(mctx.Dependents) > 0 {
			<div class="model-context__section">
				<div class="model-context__label">Dependents</div>
				<ul class="model-context__list">
					for _, dep := range mctx.Dependents {
						<li>
							<a href={ templ.SafeURL(fmt.Sprintf("/models/%s", dep)) }>{ dep }</a>
						</li>
					}
				</ul>
			</div>
		}
		if len(mctx.Columns) > 0 {
			<div class="model-context__section">
				<div class="model-context__label">Columns ({ itoa(len(mctx.Columns)) })</div>
				<ul class="model-context__columns">
					for _, col := range mctx.Columns {
						<li class="model-context__column">
							<span class="model-context__column-name">{ col.Name }</span>
							if col.Type != "" {
								<span class="model-context__column-type">{ col.Type }</span>
							}
						</li>
					}
				</ul>
			</div>
		}
	</div>
}

templ LogDrawer() {
	<div class="ui-log-drawer ui-log-drawer--collapsed">
		<div class="ui-log-drawer__header">
			<span>Logs</span>
		</div>
		<div class="ui-log-drawer__content">
			<div id="log-content"></div>
		</div>
	</div>
}

// AppContainer is the fat morph target - the entire app UI.
// The id="app" is included here so SSE responses can be patched by datastar.
// Page templates should wrap this with data-init for SSE connections.
templ AppContainer(data AppData) {
	<div id="app">
		@Header()
		<div class="ui-main">
			@Sidebar(data.ExplorerTree, data.CurrentPath)
			<main class={ mainContentClass(data) }>
				if data.Model != nil {
					@ModelView(data.Model)
				} else if data.Stats != nil {
					@DashboardContent(data.Stats)
				} else if data.Graph != nil {
					@GraphContent(data.Graph)
				} else if data.Runs != nil {
					@RunsContent(data.Runs)
				} else if data.Query != nil {
					@QueryContent(data.Query)
				} else {
					<div class="empty-state">
						<p>Select a model from the explorer</p>
					</div>
				}
			</main>
			if data.Model != nil {
				@ContextPanel(data.Context)
			}
		</div>
		@LogDrawer()
	</div>
}

// mainContentClass determines the CSS class for main content based on page type.
func mainContentClass(data AppData) string {
	// Full-width for graph, runs, query pages (no context panel)
	if data.Graph != nil || data.Runs != nil || data.Query != nil {
		return "ui-content ui-content--full"
	}
	return "ui-content"
}

templ DashboardContent(stats *DashboardStats) {
	<div id="model-detail">
		<h1>LeapSQL Dashboard</h1>
		<div class="stats-grid">
			<div class="stat-card">
				<span class="stat-value">{ fmt.Sprint(stats.ModelCount) }</span>
				<span class="stat-label">Models</span>
			</div>
		</div>
	</div>
}

templ ModelView(data *ModelViewData) {
	<div class="model-detail" data-signals="{view: 'source'}">
		// Header
		<div class="model-detail__header">
			<h2 class="model-detail__title">{ data.Name }</h2>
			<span class="model-detail__path">{ data.Path }</span>
		</div>
		
		if data.Description != "" {
			<p class="model-detail__description">{ data.Description }</p>
		}
		
		// Metadata badges
		<div class="model-detail__meta">
			<span class="model-detail__badge">{ materializationLabel(data.Materialized) }</span>
			if data.Schema != "" {
				<span class="model-detail__schema">{ data.Schema }</span>
			}
			if data.Owner != "" {
				<span class="model-detail__owner">Owner: { data.Owner }</span>
			}
		</div>
		
		if len(data.Tags) > 0 {
			<div class="model-detail__tags">
				for _, tag := range data.Tags {
					<span class="model-detail__tag">{ tag }</span>
				}
			</div>
		}
		
		// Tab buttons
		<div class="model-detail__tabs">
			<button 
				class="tab-btn"
				data-on:click="$view = 'source'"
				data-class:tab-btn--active="$view === 'source'"
			>
				Source SQL
			</button>
			<button 
				class="tab-btn"
				data-on:click="$view = 'compiled'"
				data-class:tab-btn--active="$view === 'compiled'"
			>
				Compiled SQL
			</button>
			<button 
				class="tab-btn"
				data-on:click="$view = 'preview'"
				data-class:tab-btn--active="$view === 'preview'"
			>
				Preview Data
			</button>
		</div>
		
		// Tab content
		<div class="model-detail__content">
			// Source SQL tab
			<div data-show="$view === 'source'">
				<pre class="sql-code"><code>{ data.SourceSQL }</code></pre>
			</div>
			
			// Compiled SQL tab
			<div data-show="$view === 'compiled'">
				if data.CompileError != "" {
					<div class="error-message">{ data.CompileError }</div>
				} else {
					<pre class="sql-code"><code>{ data.CompiledSQL }</code></pre>
				}
			</div>
			
			// Preview tab
			<div data-show="$view === 'preview'">
				if data.PreviewError != "" {
					<div class="error-message">{ data.PreviewError }</div>
				} else if data.Preview != nil {
					@DataPreviewTable(data.Preview)
				} else {
					<p class="text-muted">Run the model to preview data</p>
				}
			</div>
		</div>
	</div>
}

templ DataPreviewTable(preview *PreviewData) {
	<div class="data-preview">
		<div class="data-preview__header">
			<span class="data-preview__count">
				{ itoa(preview.RowCount) } rows
				if preview.Limited {
					(limited to 50)
				}
			</span>
		</div>
		if len(preview.Columns) > 0 {
			<div class="data-preview__table-wrapper">
				<table class="data-preview__table">
					<thead>
						<tr>
							for _, col := range preview.Columns {
								<th>{ col }</th>
							}
						</tr>
					</thead>
					<tbody>
						for _, row := range preview.Rows {
							<tr>
								for _, cell := range row {
									<td>{ cell }</td>
								}
							</tr>
						}
					</tbody>
				</table>
			</div>
		}
	</div>
}

// GraphContent renders the DAG visualization page content.
templ GraphContent(data *GraphViewData) {
	<div class="graph-page">
		<div class="graph-header">
			<h1>DAG</h1>
			<p class="text-muted">Model dependency graph</p>
		</div>
		<div class="graph-container">
			@GraphView(data)
		</div>
	</div>
}

// GraphView renders the graph visualization with nodes and edges.
templ GraphView(data *GraphViewData) {
	<div class="graph-view">
		<div class="graph-view__canvas">
			if len(data.Nodes) == 0 {
				<div class="graph-empty">
					<p>No models found</p>
					<p class="text-muted">Run discovery to populate the graph</p>
				</div>
			} else {
				<div class="graph-nodes">
					for _, node := range data.Nodes {
						<div class={ "graph-node", graphNodeClass(node.Type) } data-node-id={ node.ID }>
							<span class="graph-node__label">{ node.Label }</span>
							<span class="graph-node__type">{ node.Type }</span>
						</div>
					}
				</div>
				if len(data.Edges) > 0 {
					<div class="graph-edges-info">
						<p class="text-muted">Dependencies:</p>
						<ul class="graph-edges-list">
							for _, edge := range data.Edges {
								<li>{ extractModelName(edge.Source) } -> { extractModelName(edge.Target) }</li>
							}
						</ul>
					</div>
				}
			}
		</div>
		<div class="graph-view__legend">
			<div class="graph-legend">
				<div class="graph-legend__item">
					<span class="graph-legend__color graph-legend__color--view"></span>
					<span>View</span>
				</div>
				<div class="graph-legend__item">
					<span class="graph-legend__color graph-legend__color--table"></span>
					<span>Table</span>
				</div>
				<div class="graph-legend__item">
					<span class="graph-legend__color graph-legend__color--incremental"></span>
					<span>Incremental</span>
				</div>
			</div>
		</div>
		<div class="graph-view__stats">
			{ itoa(len(data.Nodes)) } models, { itoa(len(data.Edges)) } dependencies
		</div>
	</div>
}

// RunsContent renders the runs history page content with GitHub Actions-style layout.
templ RunsContent(data *RunsViewData) {
	<div class="runs-page">
		<div class="runs-header">
			<h1>Run History</h1>
			<p class="text-muted">View past pipeline executions</p>
		</div>
		<div class="runs-container">
			<div class="runs-list-container">
				@RunsListView(data.Runs, data.SelectedRunID)
			</div>
			<div class="runs-detail-container">
				<div id="run-detail">
					if data.SelectedRun != nil {
						@RunDetailWithTiersView(data.SelectedRun)
					} else if data.SelectedRunID != "" {
						<div class="run-detail-empty">
							<p>Run not found</p>
							<a href="/runs" class="run-detail-empty__link">‚Üê Back to runs</a>
						</div>
					} else {
						<div class="run-detail-empty">
							<p>Select a run to view details</p>
						</div>
					}
				</div>
			</div>
		</div>
	</div>
}

// RunsListView renders the list of runs as GitHub Actions-style cards.
templ RunsListView(runs []RunListItem, selectedRunID string) {
	<div id="runs-list" class="runs-list">
		if len(runs) == 0 {
			<div class="runs-empty">
				<p>No runs found</p>
				<p class="text-muted">Execute a run to see history here</p>
			</div>
		} else {
			<div class="runs-card-list">
				for _, run := range runs {
					@RunListCard(run, run.ID == selectedRunID)
				}
			</div>
		}
	</div>
}

// RunListCard renders a compact run card for the list view (GitHub Actions style).
// Each run is a resource with its own URL for proper navigation and bookmarking.
// When selected, automatically scrolls into view on page load.
templ RunListCard(run RunListItem, isSelected bool) {
	<a 
		href={ templ.SafeURL(fmt.Sprintf("/runs/%s", run.ID)) }
		class={ "run-list-card", templ.KV("run-list-card--selected", isSelected), runListCardStatusClass(run.Status) }
		if isSelected {
			data-init="el.scrollIntoView({ block: 'center', behavior: 'instant' })"
		}
	>
		<div class="run-list-card__main">
			<div class="run-list-card__status">
				@StatusIcon(run.Status, "lg")
			</div>
			<div class="run-list-card__info">
				<div class="run-list-card__title">
					<code class="run-list-card__id">{ truncateID(run.ID) }</code>
					<span class="run-list-card__env">{ run.Environment }</span>
				</div>
				<div class="run-list-card__meta">
					<span class="run-list-card__time">{ run.StartedAt }</span>
					if run.Duration != "" {
						<span class="run-list-card__duration">{ run.Duration }</span>
					}
				</div>
			</div>
		</div>
		<div class="run-list-card__stats">
			if run.Stats.TotalModels > 0 {
				@RunMiniStats(run.Stats)
			}
		</div>
	</a>
}

// RunMiniStats renders mini status counts for list cards.
templ RunMiniStats(stats RunStats) {
	<div class="run-mini-stats">
		if stats.Succeeded > 0 {
			<span class="run-mini-stats__item run-mini-stats__item--success">
				@StatusIcon("success", "sm")
				{ itoa(stats.Succeeded) }
			</span>
		}
		if stats.Failed > 0 {
			<span class="run-mini-stats__item run-mini-stats__item--failed">
				@StatusIcon("failed", "sm")
				{ itoa(stats.Failed) }
			</span>
		}
		if stats.Skipped > 0 {
			<span class="run-mini-stats__item run-mini-stats__item--skipped">
				@StatusIcon("skipped", "sm")
				{ itoa(stats.Skipped) }
			</span>
		}
		if stats.Running > 0 {
			<span class="run-mini-stats__item run-mini-stats__item--running">
				@StatusIcon("running", "sm")
				{ itoa(stats.Running) }
			</span>
		}
		if stats.Pending > 0 {
			<span class="run-mini-stats__item run-mini-stats__item--pending">
				@StatusIcon("pending", "sm")
				{ itoa(stats.Pending) }
			</span>
		}
	</div>
}

// StatusIcon renders a status icon SVG.
templ StatusIcon(status string, size string) {
	<span class={ "status-icon", statusIconClass(status), statusIconSizeClass(size) }>
		if status == "success" || status == "completed" {
			<svg viewBox="0 0 16 16" fill="currentColor">
				<path fill-rule="evenodd" d="M13.78 4.22a.75.75 0 010 1.06l-7.25 7.25a.75.75 0 01-1.06 0L2.22 9.28a.75.75 0 011.06-1.06L6 10.94l6.72-6.72a.75.75 0 011.06 0z"/>
			</svg>
		} else if status == "failed" {
			<svg viewBox="0 0 16 16" fill="currentColor">
				<path fill-rule="evenodd" d="M3.72 3.72a.75.75 0 011.06 0L8 6.94l3.22-3.22a.75.75 0 111.06 1.06L9.06 8l3.22 3.22a.75.75 0 11-1.06 1.06L8 9.06l-3.22 3.22a.75.75 0 01-1.06-1.06L6.94 8 3.72 4.78a.75.75 0 010-1.06z"/>
			</svg>
		} else if status == "running" {
			<svg viewBox="0 0 16 16" fill="currentColor" class="status-icon--spinning">
				<path d="M8 0a8 8 0 108 8h-2a6 6 0 11-6-6V0z"/>
			</svg>
		} else if status == "skipped" {
			<svg viewBox="0 0 16 16" fill="currentColor">
				<path fill-rule="evenodd" d="M1.5 8a6.5 6.5 0 1113 0 6.5 6.5 0 01-13 0zM8 0a8 8 0 100 16A8 8 0 008 0z"/>
			</svg>
		} else {
			<svg viewBox="0 0 16 16" fill="currentColor">
				<circle cx="8" cy="8" r="4"/>
			</svg>
		}
	</span>
}

// RunDetailWithTiersView renders the full detail view with tiered model runs.
templ RunDetailWithTiersView(run *RunDetailWithTiers) {
	<div class="run-detail-tiered">
		@RunDetailHeader(run)
		@RunSummaryBar(run.Stats)
		<div class="run-detail-tiered__tiers">
			for _, tier := range run.Tiers {
				@TierGroupView(tier)
			}
		</div>
		if run.Error != "" {
			<div class="run-detail-tiered__error">
				<strong>Error:</strong> { run.Error }
			</div>
		}
	</div>
}

// RunDetailHeader renders the full header for a selected run.
templ RunDetailHeader(run *RunDetailWithTiers) {
	<div class="run-detail-header">
		<div class="run-detail-header__title">
			@StatusIcon(run.Status, "lg")
			<span class="run-detail-header__label">Run { truncateID(run.ID) }</span>
			<span class={ "run-status", runStatusBadgeClass(run.Status) }>{ run.Status }</span>
		</div>
		<div class="run-detail-header__meta">
			<span class="run-detail-header__item">
				<span class="run-detail-header__key">Environment:</span>
				<span class="run-detail-header__value">{ run.Environment }</span>
			</span>
			<span class="run-detail-header__item">
				<span class="run-detail-header__key">Started:</span>
				<span class="run-detail-header__value">{ run.StartedAt }</span>
			</span>
			<span class="run-detail-header__item">
				<span class="run-detail-header__key">Duration:</span>
				<span class="run-detail-header__value">{ run.Duration }</span>
			</span>
		</div>
		if run.Status == "running" {
			<div class="run-detail-header__progress">
				<div class="run-detail-header__progress-bar run-detail-header__progress-bar--running"></div>
			</div>
		}
	</div>
}

// RunSummaryBar renders the horizontal status summary bar.
templ RunSummaryBar(stats RunStats) {
	<div class="run-summary-bar">
		<span class="run-summary-bar__item run-summary-bar__item--success">
			@StatusIcon("success", "sm")
			<span>{ itoa(stats.Succeeded) } succeeded</span>
		</span>
		<span class="run-summary-bar__item run-summary-bar__item--failed">
			@StatusIcon("failed", "sm")
			<span>{ itoa(stats.Failed) } failed</span>
		</span>
		<span class="run-summary-bar__item run-summary-bar__item--skipped">
			@StatusIcon("skipped", "sm")
			<span>{ itoa(stats.Skipped) } skipped</span>
		</span>
		if stats.Running > 0 {
			<span class="run-summary-bar__item run-summary-bar__item--running">
				@StatusIcon("running", "sm")
				<span>{ itoa(stats.Running) } running</span>
			</span>
		}
		if stats.Pending > 0 {
			<span class="run-summary-bar__item run-summary-bar__item--pending">
				@StatusIcon("pending", "sm")
				<span>{ itoa(stats.Pending) } pending</span>
			</span>
		}
	</div>
}

// TierGroupView renders a collapsible tier section with models.
templ TierGroupView(tier TierGroup) {
	<details class={ "tier-group", templ.KV("tier-group--collapsed", tier.Collapsed) } open>
		<summary class="tier-group__header">
			<span class="tier-group__toggle">
				<svg class="tier-group__arrow" viewBox="0 0 16 16" fill="currentColor">
					<path fill-rule="evenodd" d="M6.22 3.22a.75.75 0 011.06 0l4.25 4.25a.75.75 0 010 1.06l-4.25 4.25a.75.75 0 01-1.06-1.06L9.94 8 6.22 4.28a.75.75 0 010-1.06z"/>
				</svg>
			</span>
			<span class="tier-group__label">{ tier.Label }</span>
			<span class="tier-group__stats">
				<span class="tier-group__count">{ itoa(tier.Stats.TotalModels) } models</span>
				if tier.Stats.TotalDuration > 0 {
					<span class="tier-group__duration">{ formatDurationMS(tier.Stats.TotalDuration) }</span>
				}
			</span>
		</summary>
		<div class="tier-group__content">
			<div class="tier-group__models">
				for i, model := range tier.Models {
					@ModelRunCard(model, i == len(tier.Models)-1, maxDuration(tier.Models))
				}
			</div>
		</div>
	</details>
}

// ModelRunCard renders a single model execution within a tier.
templ ModelRunCard(model TieredModelRun, isLast bool, maxDurationMS int64) {
	<div class={ "model-run-card", modelRunCardClass(model.Status) }>
		<div class="model-run-card__connector">
			if isLast {
				<span class="model-run-card__line model-run-card__line--last"></span>
			} else {
				<span class="model-run-card__line"></span>
			}
		</div>
		<div class="model-run-card__status">
			@StatusIcon(model.Status, "md")
		</div>
		<div class="model-run-card__info">
			<a href={ templ.SafeURL(fmt.Sprintf("/models/%s", model.ModelPath)) } class="model-run-card__name">
				{ model.ModelName }
			</a>
		</div>
		<div class="model-run-card__timing">
			if model.ExecutionMS > 0 && maxDurationMS > 0 {
				<div class="model-run-card__duration-bar">
					<div 
						class="model-run-card__duration-fill"
						style={ fmt.Sprintf("width: %.1f%%", float64(model.ExecutionMS)/float64(maxDurationMS)*100) }
					></div>
				</div>
			}
			if model.ExecutionMS > 0 {
				<span class="model-run-card__duration-text">{ formatDurationMS(model.ExecutionMS) }</span>
			}
		</div>
		if model.Error != "" {
			<div class="model-run-card__error">
				<span class="model-run-card__error-text">{ model.Error }</span>
			</div>
		}
	</div>
}

// RunRowView renders a single run row (legacy table format).
templ RunRowView(run RunItem) {
	<tr class={ "run-row", runStatusRowClass(run.Status) }>
		<td>
			<span class={ "run-status", runStatusBadgeClass(run.Status) }>
				{ run.Status }
			</span>
		</td>
		<td class="run-env">{ run.Environment }</td>
		<td class="run-time">{ run.StartedAt }</td>
		<td class="run-duration">{ run.Duration }</td>
		<td class="run-actions">
			<button 
				class="btn btn--sm"
				data-on:click={ fmt.Sprintf("@get('/api/runs/%s')", run.ID) }
			>
				View
			</button>
		</td>
	</tr>
}

// RunDetailView renders detailed information about a run (legacy format).
templ RunDetailView(run *RunDetail) {
	<div class="run-detail">
		<div class="run-detail__header">
			<h2>Run Details</h2>
			<span class={ "run-status", runStatusBadgeClass(run.Status) }>
				{ run.Status }
			</span>
		</div>
		<div class="run-detail__info">
			<div class="run-detail__row">
				<span class="run-detail__label">ID:</span>
				<span class="run-detail__value">{ run.ID }</span>
			</div>
			<div class="run-detail__row">
				<span class="run-detail__label">Environment:</span>
				<span class="run-detail__value">{ run.Environment }</span>
			</div>
			<div class="run-detail__row">
				<span class="run-detail__label">Started:</span>
				<span class="run-detail__value">{ run.StartedAt }</span>
			</div>
			if run.CompletedAt != "" {
				<div class="run-detail__row">
					<span class="run-detail__label">Completed:</span>
					<span class="run-detail__value">{ run.CompletedAt }</span>
				</div>
			}
			<div class="run-detail__row">
				<span class="run-detail__label">Duration:</span>
				<span class="run-detail__value">{ run.Duration }</span>
			</div>
			if run.Error != "" {
				<div class="run-detail__row run-detail__row--error">
					<span class="run-detail__label">Error:</span>
					<span class="run-detail__value run-detail__error">{ run.Error }</span>
				</div>
			}
		</div>
		if len(run.ModelRuns) > 0 {
			<div class="run-detail__models">
				<h3>Model Runs</h3>
				<table class="model-runs-table">
					<thead>
						<tr>
							<th>Status</th>
							<th>Model</th>
							<th>Rows</th>
							<th>Time (ms)</th>
						</tr>
					</thead>
					<tbody>
						for _, mr := range run.ModelRuns {
							<tr class={ "model-run-row", modelRunStatusRowClass(mr.Status) }>
								<td>
									<span class={ "model-run-status", modelRunStatusBadgeClass(mr.Status) }>
										{ mr.Status }
									</span>
								</td>
								<td class="model-run-name" title={ mr.ModelID }>{ mr.ModelName }</td>
								<td class="model-run-rows">{ mr.RowsAffected }</td>
								<td class="model-run-time">{ mr.ExecutionMS }</td>
							</tr>
						}
					</tbody>
				</table>
			</div>
		}
	</div>
}

// QueryContent renders the state query page content.
templ QueryContent(data *QueryViewData) {
	<div
		class="query-page"
		data-signals="{sql: ''}"
		data-on:editor-change="$sql = evt.detail"
	>
		<div class="query-page__main">
			<div class="query-page__editor-section">
				<div class="query-page__editor-header">
					<h1 class="query-page__title">State Query</h1>
					<p class="text-muted">Query the LeapSQL state database</p>
				</div>
				<div class="query-editor">
					<sql-editor
						id="sql-editor"
						initial-value=""
						placeholder="SELECT * FROM models LIMIT 10;"
						data-on:editor-execute="document.getElementById('execute-btn').click()"
					></sql-editor>
				</div>
				<div class="query-page__actions">
					<button
						type="button"
						id="execute-btn"
						class="btn btn--primary"
						data-on:click="@post('/api/query/execute')"
					>
						Execute
						<kbd>Cmd+Enter</kbd>
					</button>
					<button
						type="button"
						class="btn btn--secondary"
						id="clear-btn"
						data-on:click="document.getElementById('sql-editor').clear(); $sql = ''"
					>
						Clear
					</button>
				</div>
			</div>
			<div id="query-results" class="query-results">
				<div class="query-results__empty">
					<p class="text-muted">Enter a query and press Execute</p>
				</div>
			</div>
		</div>
		<aside class="query-page__sidebar">
			@QueryTablesList(data.Tables, data.Views)
			<div id="query-schema-panel" class="query-sidebar__schema">
				<p class="text-muted">Click a table to view schema</p>
			</div>
		</aside>
	</div>
}

// QueryTablesList renders the list of tables and views in the query sidebar.
templ QueryTablesList(tables, views []TableItem) {
	<div id="query-sidebar-tables" class="query-sidebar__tables">
		if len(tables) > 0 {
			<details class="query-sidebar__group" open>
				<summary>Tables ({ itoa(len(tables)) })</summary>
				<ul class="query-sidebar__list">
					for _, t := range tables {
						<li>
							<button 
								class="query-sidebar__item"
								data-on:click={ fmt.Sprintf("@get('/api/query/schema/%s')", t.Name) }
							>
								<span class="query-sidebar__icon">T</span>
								{ t.Name }
							</button>
						</li>
					}
				</ul>
			</details>
		}
		if len(views) > 0 {
			<details class="query-sidebar__group" open>
				<summary>Views ({ itoa(len(views)) })</summary>
				<ul class="query-sidebar__list">
					for _, v := range views {
						<li>
							<button 
								class="query-sidebar__item"
								data-on:click={ fmt.Sprintf("@get('/api/query/schema/%s')", v.Name) }
							>
								<span class="query-sidebar__icon">V</span>
								{ v.Name }
							</button>
						</li>
					}
				</ul>
			</details>
		}
		if len(tables) == 0 && len(views) == 0 {
			<p class="text-muted">No tables found</p>
		}
	</div>
}

func materializationLabel(mat string) string {
	switch mat {
	case "table":
		return "Table"
	case "view":
		return "View"
	case "incremental":
		return "Incremental"
	case "":
		return "View"
	default:
		return mat
	}
}

func itoa(n int) string {
	if n == 0 {
		return "0"
	}
	result := ""
	for n > 0 {
		result = string('0'+byte(n%10)) + result
		n /= 10
	}
	return result
}

func lenStr(nodes []TreeNode) string {
	return "(" + itoa(len(nodes)) + ")"
}

// Graph helper functions

func graphNodeClass(nodeType string) string {
	switch nodeType {
	case "table":
		return "graph-node--table"
	case "incremental":
		return "graph-node--incremental"
	case "source":
		return "graph-node--source"
	default:
		return "graph-node--view"
	}
}

func extractModelName(path string) string {
	// Extract name from path like "staging.orders" -> "orders"
	for i := len(path) - 1; i >= 0; i-- {
		if path[i] == '.' {
			return path[i+1:]
		}
	}
	return path
}

// Run helper functions

func runStatusBadgeClass(status string) string {
	switch status {
	case "completed":
		return "run-status--completed"
	case "running":
		return "run-status--running"
	case "failed":
		return "run-status--failed"
	case "cancelled":
		return "run-status--cancelled"
	default:
		return ""
	}
}

func runStatusRowClass(status string) string {
	switch status {
	case "failed":
		return "run-row--failed"
	case "running":
		return "run-row--running"
	default:
		return ""
	}
}

func modelRunStatusBadgeClass(status string) string {
	switch status {
	case "success":
		return "model-run-status--success"
	case "running":
		return "model-run-status--running"
	case "failed":
		return "model-run-status--failed"
	case "skipped":
		return "model-run-status--skipped"
	case "pending":
		return "model-run-status--pending"
	default:
		return ""
	}
}

func modelRunStatusRowClass(status string) string {
	switch status {
	case "failed":
		return "model-run-row--failed"
	case "running":
		return "model-run-row--running"
	default:
		return ""
	}
}

// New helper functions for GitHub Actions-style runs

func truncateID(id string) string {
	if len(id) > 7 {
		return id[:7]
	}
	return id
}

func runListCardStatusClass(status string) string {
	switch status {
	case "completed":
		return "run-list-card--completed"
	case "running":
		return "run-list-card--running"
	case "failed":
		return "run-list-card--failed"
	case "cancelled":
		return "run-list-card--cancelled"
	default:
		return ""
	}
}

func statusIconClass(status string) string {
	switch status {
	case "success", "completed":
		return "status-icon--success"
	case "running":
		return "status-icon--running"
	case "failed":
		return "status-icon--failed"
	case "skipped":
		return "status-icon--skipped"
	case "pending":
		return "status-icon--pending"
	default:
		return ""
	}
}

func statusIconSizeClass(size string) string {
	switch size {
	case "lg":
		return "status-icon--lg"
	case "md":
		return "status-icon--md"
	case "sm":
		return "status-icon--sm"
	default:
		return "status-icon--md"
	}
}

func modelRunCardClass(status string) string {
	switch status {
	case "failed":
		return "model-run-card--failed"
	case "skipped":
		return "model-run-card--skipped"
	case "running":
		return "model-run-card--running"
	default:
		return ""
	}
}

func formatDurationMS(ms int64) string {
	if ms < 1000 {
		return itoa(int(ms)) + "ms"
	}
	secs := float64(ms) / 1000
	if secs < 60 {
		// Format with 1 decimal place
		whole := int(secs)
		frac := int((secs - float64(whole)) * 10)
		return itoa(whole) + "." + itoa(frac) + "s"
	}
	mins := int(secs / 60)
	remainSecs := int(secs) % 60
	return itoa(mins) + "m" + itoa(remainSecs) + "s"
}

func maxDuration(models []TieredModelRun) int64 {
	var max int64
	for _, m := range models {
		if m.ExecutionMS > max {
			max = m.ExecutionMS
		}
	}
	return max
}
