package pages

import (
	"fmt"
	"github.com/leapstack-labs/leapsql/internal/ui/features/common"
	"github.com/leapstack-labs/leapsql/internal/ui/features/common/components"
	"github.com/leapstack-labs/leapsql/internal/ui/features/common/layouts"
)

// ModelViewData holds all data for the model view including all tab content.
type ModelViewData struct {
	// Model info
	Path         string
	Name         string
	FilePath     string
	Materialized string
	Schema       string
	Description  string
	Owner        string
	Tags         []string

	// Tab content (all pre-rendered)
	SourceSQL    string
	CompiledSQL  string
	CompileError string // If compilation failed

	// Preview data (may be nil if not available)
	Preview      *PreviewData
	PreviewError string // If preview query failed
}

// PreviewData holds data preview results.
type PreviewData struct {
	Columns  []string
	Rows     [][]string
	RowCount int
	Limited  bool
}

// ModelContext holds data for the context panel.
type ModelContext struct {
	Path       string
	Name       string
	Type       string
	Schema     string
	DependsOn  []string
	Dependents []string
	Columns    []ColumnData
}

// ColumnData holds column information.
type ColumnData struct {
	Name    string
	Type    string
	Sources []string
}

// ModelPage renders the model detail page with full content.
// SSE is used only for live updates, not initial content.
// AppShellWithContext provides id="app" for datastar patching.
templ ModelPage(title string, isDev bool, sidebar common.SidebarData, modelData *ModelViewData, contextData *ModelContext, updatePath string) {
	@layouts.Base(title, isDev) {
		<div data-init={ fmt.Sprintf("@get('%s')", updatePath) }>
			@components.AppShellWithContext(sidebar.ExplorerTree, sidebar.CurrentPath, ContextPanel(contextData)) {
				@ModelContent(modelData)
			}
		</div>
	}
}

// ModelAppShell renders just the app shell with model content (for SSE updates).
templ ModelAppShell(sidebar common.SidebarData, modelData *ModelViewData, contextData *ModelContext) {
	@components.AppShellWithContext(sidebar.ExplorerTree, sidebar.CurrentPath, ContextPanel(contextData)) {
		@ModelContent(modelData)
	}
}

// ModelContent wraps ModelView with nil check
templ ModelContent(data *ModelViewData) {
	if data != nil {
		@ModelView(data)
	} else {
		<div class="model-detail model-detail--empty">
			<h2>Model Not Found</h2>
			<p class="text-muted">The requested model does not exist.</p>
		</div>
	}
}

// ModelView renders the model detail view.
templ ModelView(data *ModelViewData) {
	<div class="model-detail" data-signals="{view: 'source'}">
		// Header
		<div class="model-detail__header">
			<h2 class="model-detail__title">{ data.Name }</h2>
			<span class="model-detail__path">{ data.Path }</span>
		</div>
		
		if data.Description != "" {
			<p class="model-detail__description">{ data.Description }</p>
		}
		
		// Metadata badges
		<div class="model-detail__meta">
			<span class="model-detail__badge">{ materializationLabel(data.Materialized) }</span>
			if data.Schema != "" {
				<span class="model-detail__schema">{ data.Schema }</span>
			}
			if data.Owner != "" {
				<span class="model-detail__owner">Owner: { data.Owner }</span>
			}
		</div>
		
		if len(data.Tags) > 0 {
			<div class="model-detail__tags">
				for _, tag := range data.Tags {
					<span class="model-detail__tag">{ tag }</span>
				}
			</div>
		}
		
		// Tab buttons
		<div class="model-detail__tabs">
			<button 
				class="tab-btn"
				data-on:click="$view = 'source'"
				data-class:tab-btn--active="$view === 'source'"
			>
				Source SQL
			</button>
			<button 
				class="tab-btn"
				data-on:click="$view = 'compiled'"
				data-class:tab-btn--active="$view === 'compiled'"
			>
				Compiled SQL
			</button>
			<button 
				class="tab-btn"
				data-on:click="$view = 'preview'"
				data-class:tab-btn--active="$view === 'preview'"
			>
				Preview Data
			</button>
		</div>
		
		// Tab content
		<div class="model-detail__content">
			// Source SQL tab
			<div data-show="$view === 'source'">
				<pre class="sql-code"><code>{ data.SourceSQL }</code></pre>
			</div>
			
			// Compiled SQL tab
			<div data-show="$view === 'compiled'">
				if data.CompileError != "" {
					<div class="error-message">{ data.CompileError }</div>
				} else {
					<pre class="sql-code"><code>{ data.CompiledSQL }</code></pre>
				}
			</div>
			
			// Preview tab
			<div data-show="$view === 'preview'">
				if data.PreviewError != "" {
					<div class="error-message">{ data.PreviewError }</div>
				} else if data.Preview != nil {
					@DataPreviewTable(data.Preview)
				} else {
					<p class="text-muted">Run the model to preview data</p>
				}
			</div>
		</div>
	</div>
}

// DataPreviewTable renders the data preview table.
templ DataPreviewTable(preview *PreviewData) {
	<div class="data-preview">
		<div class="data-preview__header">
			<span class="data-preview__count">
				{ itoa(preview.RowCount) } rows
				if preview.Limited {
					(limited to 50)
				}
			</span>
		</div>
		if len(preview.Columns) > 0 {
			<div class="data-preview__table-wrapper">
				<table class="data-preview__table">
					<thead>
						<tr>
							for _, col := range preview.Columns {
								<th>{ col }</th>
							}
						</tr>
					</thead>
					<tbody>
						for _, row := range preview.Rows {
							<tr>
								for _, cell := range row {
									<td>{ cell }</td>
								}
							</tr>
						}
					</tbody>
				</table>
			</div>
		}
	</div>
}

// ContextPanel renders the context panel sidebar.
templ ContextPanel(mctx *ModelContext) {
	<aside class="ui-context-panel">
		<div class="ui-context-panel__header">Properties</div>
		<div id="context-content">
			if mctx != nil {
				@ModelContextContent(*mctx)
			} else {
				<p class="text-muted">Select a model to view details</p>
			}
		</div>
	</aside>
}

// ModelContextContent renders the model context content.
templ ModelContextContent(mctx ModelContext) {
	<div class="model-context">
		<div class="model-context__section">
			<div class="model-context__label">Model</div>
			<div class="model-context__value">{ mctx.Name }</div>
		</div>
		<div class="model-context__section">
			<div class="model-context__label">Type</div>
			<div class="model-context__value">{ materializationLabel(mctx.Type) }</div>
		</div>
		if mctx.Schema != "" {
			<div class="model-context__section">
				<div class="model-context__label">Schema</div>
				<div class="model-context__value">{ mctx.Schema }</div>
			</div>
		}
		if len(mctx.DependsOn) > 0 {
			<div class="model-context__section">
				<div class="model-context__label">Depends On</div>
				<ul class="model-context__list">
					for _, dep := range mctx.DependsOn {
						<li>
							<a href={ templ.SafeURL(fmt.Sprintf("/models/%s", dep)) }>{ dep }</a>
						</li>
					}
				</ul>
			</div>
		}
		if len(mctx.Dependents) > 0 {
			<div class="model-context__section">
				<div class="model-context__label">Dependents</div>
				<ul class="model-context__list">
					for _, dep := range mctx.Dependents {
						<li>
							<a href={ templ.SafeURL(fmt.Sprintf("/models/%s", dep)) }>{ dep }</a>
						</li>
					}
				</ul>
			</div>
		}
		if len(mctx.Columns) > 0 {
			<div class="model-context__section">
				<div class="model-context__label">Columns ({ itoa(len(mctx.Columns)) })</div>
				<ul class="model-context__columns">
					for _, col := range mctx.Columns {
						<li class="model-context__column">
							<span class="model-context__column-name">{ col.Name }</span>
							if col.Type != "" {
								<span class="model-context__column-type">{ col.Type }</span>
							}
						</li>
					}
				</ul>
			</div>
		}
	</div>
}
