// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: batch.sql

package sqlcgen

import (
	"context"
)

const batchGetAllColumnLineage = `-- name: BatchGetAllColumnLineage :many
SELECT 
    cl.model_path,
    cl.column_name,
    cl.source_table,
    cl.source_column
FROM column_lineage cl
ORDER BY cl.model_path, cl.column_name
`

// Returns all column lineage for all models in one query
func (q *Queries) BatchGetAllColumnLineage(ctx context.Context) ([]ColumnLineage, error) {
	rows, err := q.db.QueryContext(ctx, batchGetAllColumnLineage)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ColumnLineage{}
	for rows.Next() {
		var i ColumnLineage
		if err := rows.Scan(
			&i.ModelPath,
			&i.ColumnName,
			&i.SourceTable,
			&i.SourceColumn,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const batchGetAllColumns = `-- name: BatchGetAllColumns :many
SELECT 
    mc.model_path,
    mc.column_name,
    mc.column_index,
    mc.transform_type,
    mc.function_name
FROM model_columns mc
ORDER BY mc.model_path, mc.column_index
`

// Returns all columns for all models in one query
func (q *Queries) BatchGetAllColumns(ctx context.Context) ([]ModelColumn, error) {
	rows, err := q.db.QueryContext(ctx, batchGetAllColumns)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ModelColumn{}
	for rows.Next() {
		var i ModelColumn
		if err := rows.Scan(
			&i.ModelPath,
			&i.ColumnName,
			&i.ColumnIndex,
			&i.TransformType,
			&i.FunctionName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const batchGetAllDependencies = `-- name: BatchGetAllDependencies :many
SELECT 
    d.model_id,
    d.parent_id
FROM dependencies d
`

// Returns all dependencies in one query
func (q *Queries) BatchGetAllDependencies(ctx context.Context) ([]Dependency, error) {
	rows, err := q.db.QueryContext(ctx, batchGetAllDependencies)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Dependency{}
	for rows.Next() {
		var i Dependency
		if err := rows.Scan(&i.ModelID, &i.ParentID); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const batchGetAllDependents = `-- name: BatchGetAllDependents :many
SELECT 
    d.parent_id,
    d.model_id
FROM dependencies d
`

type BatchGetAllDependentsRow struct {
	ParentID string `json:"parent_id"`
	ModelID  string `json:"model_id"`
}

// Returns all dependents (reverse lookup) in one query
func (q *Queries) BatchGetAllDependents(ctx context.Context) ([]BatchGetAllDependentsRow, error) {
	rows, err := q.db.QueryContext(ctx, batchGetAllDependents)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []BatchGetAllDependentsRow{}
	for rows.Next() {
		var i BatchGetAllDependentsRow
		if err := rows.Scan(&i.ParentID, &i.ModelID); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
