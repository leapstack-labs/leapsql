// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: models.sql

package sqlcgen

import (
	"context"
	"time"
)

const deleteModelByFilePath = `-- name: DeleteModelByFilePath :exec
DELETE FROM models WHERE file_path = ?
`

func (q *Queries) DeleteModelByFilePath(ctx context.Context, filePath *string) error {
	_, err := q.db.ExecContext(ctx, deleteModelByFilePath, filePath)
	return err
}

const getModelByFilePath = `-- name: GetModelByFilePath :one
SELECT id, path, name, materialized, unique_key, content_hash, file_path,
    owner, schema_name, tags, tests, meta, created_at, updated_at
FROM models
WHERE file_path = ?
`

func (q *Queries) GetModelByFilePath(ctx context.Context, filePath *string) (Model, error) {
	row := q.db.QueryRowContext(ctx, getModelByFilePath, filePath)
	var i Model
	err := row.Scan(
		&i.ID,
		&i.Path,
		&i.Name,
		&i.Materialized,
		&i.UniqueKey,
		&i.ContentHash,
		&i.FilePath,
		&i.Owner,
		&i.SchemaName,
		&i.Tags,
		&i.Tests,
		&i.Meta,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getModelByID = `-- name: GetModelByID :one
SELECT id, path, name, materialized, unique_key, content_hash, file_path,
    owner, schema_name, tags, tests, meta, created_at, updated_at
FROM models
WHERE id = ?
`

func (q *Queries) GetModelByID(ctx context.Context, id string) (Model, error) {
	row := q.db.QueryRowContext(ctx, getModelByID, id)
	var i Model
	err := row.Scan(
		&i.ID,
		&i.Path,
		&i.Name,
		&i.Materialized,
		&i.UniqueKey,
		&i.ContentHash,
		&i.FilePath,
		&i.Owner,
		&i.SchemaName,
		&i.Tags,
		&i.Tests,
		&i.Meta,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getModelByPath = `-- name: GetModelByPath :one
SELECT id, path, name, materialized, unique_key, content_hash, file_path,
    owner, schema_name, tags, tests, meta, created_at, updated_at
FROM models
WHERE path = ?
`

func (q *Queries) GetModelByPath(ctx context.Context, path string) (Model, error) {
	row := q.db.QueryRowContext(ctx, getModelByPath, path)
	var i Model
	err := row.Scan(
		&i.ID,
		&i.Path,
		&i.Name,
		&i.Materialized,
		&i.UniqueKey,
		&i.ContentHash,
		&i.FilePath,
		&i.Owner,
		&i.SchemaName,
		&i.Tags,
		&i.Tests,
		&i.Meta,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const insertModel = `-- name: InsertModel :exec
INSERT INTO models (id, path, name, materialized, unique_key, content_hash, file_path,
    owner, schema_name, tags, tests, meta, created_at, updated_at)
VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
`

type InsertModelParams struct {
	ID           string    `json:"id"`
	Path         string    `json:"path"`
	Name         string    `json:"name"`
	Materialized string    `json:"materialized"`
	UniqueKey    *string   `json:"unique_key"`
	ContentHash  string    `json:"content_hash"`
	FilePath     *string   `json:"file_path"`
	Owner        *string   `json:"owner"`
	SchemaName   *string   `json:"schema_name"`
	Tags         *string   `json:"tags"`
	Tests        *string   `json:"tests"`
	Meta         *string   `json:"meta"`
	CreatedAt    time.Time `json:"created_at"`
	UpdatedAt    time.Time `json:"updated_at"`
}

func (q *Queries) InsertModel(ctx context.Context, arg InsertModelParams) error {
	_, err := q.db.ExecContext(ctx, insertModel,
		arg.ID,
		arg.Path,
		arg.Name,
		arg.Materialized,
		arg.UniqueKey,
		arg.ContentHash,
		arg.FilePath,
		arg.Owner,
		arg.SchemaName,
		arg.Tags,
		arg.Tests,
		arg.Meta,
		arg.CreatedAt,
		arg.UpdatedAt,
	)
	return err
}

const listModelFilePaths = `-- name: ListModelFilePaths :many
SELECT file_path FROM models WHERE file_path IS NOT NULL AND file_path != ''
`

func (q *Queries) ListModelFilePaths(ctx context.Context) ([]*string, error) {
	rows, err := q.db.QueryContext(ctx, listModelFilePaths)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*string{}
	for rows.Next() {
		var file_path *string
		if err := rows.Scan(&file_path); err != nil {
			return nil, err
		}
		items = append(items, file_path)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listModels = `-- name: ListModels :many
SELECT id, path, name, materialized, unique_key, content_hash, file_path,
    owner, schema_name, tags, tests, meta, created_at, updated_at
FROM models
ORDER BY path
`

func (q *Queries) ListModels(ctx context.Context) ([]Model, error) {
	rows, err := q.db.QueryContext(ctx, listModels)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Model{}
	for rows.Next() {
		var i Model
		if err := rows.Scan(
			&i.ID,
			&i.Path,
			&i.Name,
			&i.Materialized,
			&i.UniqueKey,
			&i.ContentHash,
			&i.FilePath,
			&i.Owner,
			&i.SchemaName,
			&i.Tags,
			&i.Tests,
			&i.Meta,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateModel = `-- name: UpdateModel :exec
UPDATE models
SET name = ?, materialized = ?, unique_key = ?, content_hash = ?, file_path = ?,
    owner = ?, schema_name = ?, tags = ?, tests = ?, meta = ?, updated_at = ?
WHERE id = ?
`

type UpdateModelParams struct {
	Name         string    `json:"name"`
	Materialized string    `json:"materialized"`
	UniqueKey    *string   `json:"unique_key"`
	ContentHash  string    `json:"content_hash"`
	FilePath     *string   `json:"file_path"`
	Owner        *string   `json:"owner"`
	SchemaName   *string   `json:"schema_name"`
	Tags         *string   `json:"tags"`
	Tests        *string   `json:"tests"`
	Meta         *string   `json:"meta"`
	UpdatedAt    time.Time `json:"updated_at"`
	ID           string    `json:"id"`
}

func (q *Queries) UpdateModel(ctx context.Context, arg UpdateModelParams) error {
	_, err := q.db.ExecContext(ctx, updateModel,
		arg.Name,
		arg.Materialized,
		arg.UniqueKey,
		arg.ContentHash,
		arg.FilePath,
		arg.Owner,
		arg.SchemaName,
		arg.Tags,
		arg.Tests,
		arg.Meta,
		arg.UpdatedAt,
		arg.ID,
	)
	return err
}

const updateModelHash = `-- name: UpdateModelHash :exec
UPDATE models
SET content_hash = ?, updated_at = ?
WHERE id = ?
`

type UpdateModelHashParams struct {
	ContentHash string    `json:"content_hash"`
	UpdatedAt   time.Time `json:"updated_at"`
	ID          string    `json:"id"`
}

func (q *Queries) UpdateModelHash(ctx context.Context, arg UpdateModelHashParams) error {
	_, err := q.db.ExecContext(ctx, updateModelHash, arg.ContentHash, arg.UpdatedAt, arg.ID)
	return err
}
