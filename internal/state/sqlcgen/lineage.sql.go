// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: lineage.sql

package sqlcgen

import (
	"context"
)

const deleteColumnLineageByModelPath = `-- name: DeleteColumnLineageByModelPath :exec
DELETE FROM column_lineage WHERE model_path = ?
`

func (q *Queries) DeleteColumnLineageByModelPath(ctx context.Context, modelPath string) error {
	_, err := q.db.ExecContext(ctx, deleteColumnLineageByModelPath, modelPath)
	return err
}

const deleteModelColumnsByModelPath = `-- name: DeleteModelColumnsByModelPath :exec
DELETE FROM model_columns WHERE model_path = ?
`

func (q *Queries) DeleteModelColumnsByModelPath(ctx context.Context, modelPath string) error {
	_, err := q.db.ExecContext(ctx, deleteModelColumnsByModelPath, modelPath)
	return err
}

const getColumnLineage = `-- name: GetColumnLineage :many
SELECT column_name, source_table, source_column
FROM column_lineage
WHERE model_path = ?
`

type GetColumnLineageRow struct {
	ColumnName   string `json:"column_name"`
	SourceTable  string `json:"source_table"`
	SourceColumn string `json:"source_column"`
}

func (q *Queries) GetColumnLineage(ctx context.Context, modelPath string) ([]GetColumnLineageRow, error) {
	rows, err := q.db.QueryContext(ctx, getColumnLineage, modelPath)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetColumnLineageRow{}
	for rows.Next() {
		var i GetColumnLineageRow
		if err := rows.Scan(&i.ColumnName, &i.SourceTable, &i.SourceColumn); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getModelColumns = `-- name: GetModelColumns :many
SELECT column_name, column_index, transform_type, function_name
FROM model_columns
WHERE model_path = ?
ORDER BY column_index
`

type GetModelColumnsRow struct {
	ColumnName    string  `json:"column_name"`
	ColumnIndex   int64   `json:"column_index"`
	TransformType *string `json:"transform_type"`
	FunctionName  *string `json:"function_name"`
}

func (q *Queries) GetModelColumns(ctx context.Context, modelPath string) ([]GetModelColumnsRow, error) {
	rows, err := q.db.QueryContext(ctx, getModelColumns, modelPath)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetModelColumnsRow{}
	for rows.Next() {
		var i GetModelColumnsRow
		if err := rows.Scan(
			&i.ColumnName,
			&i.ColumnIndex,
			&i.TransformType,
			&i.FunctionName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const insertColumnLineage = `-- name: InsertColumnLineage :exec
INSERT INTO column_lineage (model_path, column_name, source_table, source_column)
VALUES (?, ?, ?, ?)
`

type InsertColumnLineageParams struct {
	ModelPath    string `json:"model_path"`
	ColumnName   string `json:"column_name"`
	SourceTable  string `json:"source_table"`
	SourceColumn string `json:"source_column"`
}

func (q *Queries) InsertColumnLineage(ctx context.Context, arg InsertColumnLineageParams) error {
	_, err := q.db.ExecContext(ctx, insertColumnLineage,
		arg.ModelPath,
		arg.ColumnName,
		arg.SourceTable,
		arg.SourceColumn,
	)
	return err
}

const insertModelColumn = `-- name: InsertModelColumn :exec
INSERT INTO model_columns (model_path, column_name, column_index, transform_type, function_name)
VALUES (?, ?, ?, ?, ?)
`

type InsertModelColumnParams struct {
	ModelPath     string  `json:"model_path"`
	ColumnName    string  `json:"column_name"`
	ColumnIndex   int64   `json:"column_index"`
	TransformType *string `json:"transform_type"`
	FunctionName  *string `json:"function_name"`
}

func (q *Queries) InsertModelColumn(ctx context.Context, arg InsertModelColumnParams) error {
	_, err := q.db.ExecContext(ctx, insertModelColumn,
		arg.ModelPath,
		arg.ColumnName,
		arg.ColumnIndex,
		arg.TransformType,
		arg.FunctionName,
	)
	return err
}

const traceColumnBackward = `-- name: TraceColumnBackward :many
WITH RECURSIVE trace AS (
    -- Start: get direct sources of the target column
    SELECT
        cl.model_path,
        cl.column_name,
        cl.source_table,
        cl.source_column,
        1 as depth
    FROM column_lineage cl
    WHERE cl.model_path = ? AND cl.column_name = ?

    UNION ALL

    -- Recurse: follow source_table -> model -> its sources
    SELECT
        cl.model_path,
        cl.column_name,
        cl.source_table,
        cl.source_column,
        t.depth + 1
    FROM trace t
    JOIN models m ON (m.name = t.source_table OR m.path = t.source_table)
    JOIN column_lineage cl ON cl.model_path = m.path AND cl.column_name = t.source_column
    WHERE t.depth < 20
)
SELECT DISTINCT
    source_table as model_path,
    source_column as column_name,
    depth,
    CASE WHEN m.path IS NULL THEN 1 ELSE 0 END as is_external
FROM trace t
LEFT JOIN models m ON (m.name = t.source_table OR m.path = t.source_table)
ORDER BY depth, source_table, source_column
`

type TraceColumnBackwardParams struct {
	ModelPath  string `json:"model_path"`
	ColumnName string `json:"column_name"`
}

type TraceColumnBackwardRow struct {
	ModelPath  string `json:"model_path"`
	ColumnName string `json:"column_name"`
	Depth      int64  `json:"depth"`
	IsExternal int64  `json:"is_external"`
}

func (q *Queries) TraceColumnBackward(ctx context.Context, arg TraceColumnBackwardParams) ([]TraceColumnBackwardRow, error) {
	rows, err := q.db.QueryContext(ctx, traceColumnBackward, arg.ModelPath, arg.ColumnName)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []TraceColumnBackwardRow{}
	for rows.Next() {
		var i TraceColumnBackwardRow
		if err := rows.Scan(
			&i.ModelPath,
			&i.ColumnName,
			&i.Depth,
			&i.IsExternal,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const traceColumnForward = `-- name: TraceColumnForward :many
WITH RECURSIVE trace AS (
    -- Start: find columns that reference this model/column as a source
    SELECT
        cl.model_path,
        cl.column_name,
        cl.source_table,
        cl.source_column,
        1 as depth
    FROM column_lineage cl
    JOIN models m ON (m.name = cl.source_table OR m.path = cl.source_table)
    WHERE m.path = ? AND cl.source_column = ?

    UNION ALL

    -- Recurse: find what references the columns we found
    SELECT
        cl.model_path,
        cl.column_name,
        cl.source_table,
        cl.source_column,
        t.depth + 1
    FROM trace t
    JOIN models m ON m.path = t.model_path
    JOIN column_lineage cl ON (cl.source_table = m.name OR cl.source_table = m.path)
                          AND cl.source_column = t.column_name
    WHERE t.depth < 20
)
SELECT DISTINCT model_path, column_name, depth
FROM trace
ORDER BY depth, model_path, column_name
`

type TraceColumnForwardParams struct {
	Path         string `json:"path"`
	SourceColumn string `json:"source_column"`
}

type TraceColumnForwardRow struct {
	ModelPath  string `json:"model_path"`
	ColumnName string `json:"column_name"`
	Depth      int64  `json:"depth"`
}

func (q *Queries) TraceColumnForward(ctx context.Context, arg TraceColumnForwardParams) ([]TraceColumnForwardRow, error) {
	rows, err := q.db.QueryContext(ctx, traceColumnForward, arg.Path, arg.SourceColumn)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []TraceColumnForwardRow{}
	for rows.Next() {
		var i TraceColumnForwardRow
		if err := rows.Scan(&i.ModelPath, &i.ColumnName, &i.Depth); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
