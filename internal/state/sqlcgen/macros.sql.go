// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: macros.sql

package sqlcgen

import (
	"context"
)

const deleteMacroFunctionsByNamespace = `-- name: DeleteMacroFunctionsByNamespace :exec
DELETE FROM macro_functions WHERE namespace = ?
`

func (q *Queries) DeleteMacroFunctionsByNamespace(ctx context.Context, namespace string) error {
	_, err := q.db.ExecContext(ctx, deleteMacroFunctionsByNamespace, namespace)
	return err
}

const deleteMacroNamespace = `-- name: DeleteMacroNamespace :exec
DELETE FROM macro_namespaces WHERE name = ?
`

func (q *Queries) DeleteMacroNamespace(ctx context.Context, name string) error {
	_, err := q.db.ExecContext(ctx, deleteMacroNamespace, name)
	return err
}

const deleteMacroNamespaceByFilePath = `-- name: DeleteMacroNamespaceByFilePath :exec
DELETE FROM macro_namespaces WHERE file_path = ?
`

func (q *Queries) DeleteMacroNamespaceByFilePath(ctx context.Context, filePath string) error {
	_, err := q.db.ExecContext(ctx, deleteMacroNamespaceByFilePath, filePath)
	return err
}

const getMacroFunction = `-- name: GetMacroFunction :one
SELECT namespace, name, args, docstring, line
FROM macro_functions
WHERE namespace = ? AND name = ?
`

type GetMacroFunctionParams struct {
	Namespace string `json:"namespace"`
	Name      string `json:"name"`
}

func (q *Queries) GetMacroFunction(ctx context.Context, arg GetMacroFunctionParams) (MacroFunction, error) {
	row := q.db.QueryRowContext(ctx, getMacroFunction, arg.Namespace, arg.Name)
	var i MacroFunction
	err := row.Scan(
		&i.Namespace,
		&i.Name,
		&i.Args,
		&i.Docstring,
		&i.Line,
	)
	return i, err
}

const getMacroFunctions = `-- name: GetMacroFunctions :many
SELECT namespace, name, args, docstring, line
FROM macro_functions
WHERE namespace = ?
ORDER BY name
`

func (q *Queries) GetMacroFunctions(ctx context.Context, namespace string) ([]MacroFunction, error) {
	rows, err := q.db.QueryContext(ctx, getMacroFunctions, namespace)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []MacroFunction{}
	for rows.Next() {
		var i MacroFunction
		if err := rows.Scan(
			&i.Namespace,
			&i.Name,
			&i.Args,
			&i.Docstring,
			&i.Line,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMacroNamespace = `-- name: GetMacroNamespace :one
SELECT name, file_path, package, updated_at
FROM macro_namespaces
WHERE name = ?
`

func (q *Queries) GetMacroNamespace(ctx context.Context, name string) (MacroNamespace, error) {
	row := q.db.QueryRowContext(ctx, getMacroNamespace, name)
	var i MacroNamespace
	err := row.Scan(
		&i.Name,
		&i.FilePath,
		&i.Package,
		&i.UpdatedAt,
	)
	return i, err
}

const getMacroNamespaces = `-- name: GetMacroNamespaces :many
SELECT name, file_path, package, updated_at
FROM macro_namespaces
ORDER BY name
`

func (q *Queries) GetMacroNamespaces(ctx context.Context) ([]MacroNamespace, error) {
	rows, err := q.db.QueryContext(ctx, getMacroNamespaces)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []MacroNamespace{}
	for rows.Next() {
		var i MacroNamespace
		if err := rows.Scan(
			&i.Name,
			&i.FilePath,
			&i.Package,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const insertMacroFunction = `-- name: InsertMacroFunction :exec
INSERT INTO macro_functions (namespace, name, args, docstring, line)
VALUES (?, ?, ?, ?, ?)
`

type InsertMacroFunctionParams struct {
	Namespace string  `json:"namespace"`
	Name      string  `json:"name"`
	Args      string  `json:"args"`
	Docstring *string `json:"docstring"`
	Line      *int64  `json:"line"`
}

func (q *Queries) InsertMacroFunction(ctx context.Context, arg InsertMacroFunctionParams) error {
	_, err := q.db.ExecContext(ctx, insertMacroFunction,
		arg.Namespace,
		arg.Name,
		arg.Args,
		arg.Docstring,
		arg.Line,
	)
	return err
}

const listMacroFilePaths = `-- name: ListMacroFilePaths :many
SELECT file_path FROM macro_namespaces WHERE file_path IS NOT NULL AND file_path != ''
`

func (q *Queries) ListMacroFilePaths(ctx context.Context) ([]string, error) {
	rows, err := q.db.QueryContext(ctx, listMacroFilePaths)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []string{}
	for rows.Next() {
		var file_path string
		if err := rows.Scan(&file_path); err != nil {
			return nil, err
		}
		items = append(items, file_path)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const macroFunctionExists = `-- name: MacroFunctionExists :one
SELECT COUNT(*) FROM macro_functions
WHERE namespace = ? AND name = ?
`

type MacroFunctionExistsParams struct {
	Namespace string `json:"namespace"`
	Name      string `json:"name"`
}

func (q *Queries) MacroFunctionExists(ctx context.Context, arg MacroFunctionExistsParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, macroFunctionExists, arg.Namespace, arg.Name)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const searchMacroFunctions = `-- name: SearchMacroFunctions :many
SELECT namespace, name, args, docstring, line
FROM macro_functions
WHERE namespace = ? AND name LIKE ? || '%'
ORDER BY name
`

type SearchMacroFunctionsParams struct {
	Namespace string  `json:"namespace"`
	Column2   *string `json:"column_2"`
}

func (q *Queries) SearchMacroFunctions(ctx context.Context, arg SearchMacroFunctionsParams) ([]MacroFunction, error) {
	rows, err := q.db.QueryContext(ctx, searchMacroFunctions, arg.Namespace, arg.Column2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []MacroFunction{}
	for rows.Next() {
		var i MacroFunction
		if err := rows.Scan(
			&i.Namespace,
			&i.Name,
			&i.Args,
			&i.Docstring,
			&i.Line,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchMacroNamespaces = `-- name: SearchMacroNamespaces :many
SELECT name, file_path, package, updated_at
FROM macro_namespaces
WHERE name LIKE ? || '%'
ORDER BY name
`

func (q *Queries) SearchMacroNamespaces(ctx context.Context, dollar_1 *string) ([]MacroNamespace, error) {
	rows, err := q.db.QueryContext(ctx, searchMacroNamespaces, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []MacroNamespace{}
	for rows.Next() {
		var i MacroNamespace
		if err := rows.Scan(
			&i.Name,
			&i.FilePath,
			&i.Package,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const upsertMacroNamespace = `-- name: UpsertMacroNamespace :exec
INSERT INTO macro_namespaces (name, file_path, package, updated_at)
VALUES (?, ?, ?, CURRENT_TIMESTAMP)
ON CONFLICT(name) DO UPDATE SET
    file_path = excluded.file_path,
    package = excluded.package,
    updated_at = CURRENT_TIMESTAMP
`

type UpsertMacroNamespaceParams struct {
	Name     string  `json:"name"`
	FilePath string  `json:"file_path"`
	Package  *string `json:"package"`
}

func (q *Queries) UpsertMacroNamespace(ctx context.Context, arg UpsertMacroNamespaceParams) error {
	_, err := q.db.ExecContext(ctx, upsertMacroNamespace, arg.Name, arg.FilePath, arg.Package)
	return err
}
