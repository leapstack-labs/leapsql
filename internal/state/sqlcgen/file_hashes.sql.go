// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: file_hashes.sql

package sqlcgen

import (
	"context"
)

const deleteContentHash = `-- name: DeleteContentHash :exec
DELETE FROM file_hashes WHERE file_path = ?
`

func (q *Queries) DeleteContentHash(ctx context.Context, filePath string) error {
	_, err := q.db.ExecContext(ctx, deleteContentHash, filePath)
	return err
}

const getContentHash = `-- name: GetContentHash :one
SELECT content_hash FROM file_hashes WHERE file_path = ?
`

func (q *Queries) GetContentHash(ctx context.Context, filePath string) (string, error) {
	row := q.db.QueryRowContext(ctx, getContentHash, filePath)
	var content_hash string
	err := row.Scan(&content_hash)
	return content_hash, err
}

const setContentHash = `-- name: SetContentHash :exec
INSERT INTO file_hashes (file_path, content_hash, file_type, updated_at)
VALUES (?, ?, ?, CURRENT_TIMESTAMP)
ON CONFLICT(file_path) DO UPDATE SET
    content_hash = excluded.content_hash,
    file_type = excluded.file_type,
    updated_at = CURRENT_TIMESTAMP
`

type SetContentHashParams struct {
	FilePath    string `json:"file_path"`
	ContentHash string `json:"content_hash"`
	FileType    string `json:"file_type"`
}

func (q *Queries) SetContentHash(ctx context.Context, arg SetContentHashParams) error {
	_, err := q.db.ExecContext(ctx, setContentHash, arg.FilePath, arg.ContentHash, arg.FileType)
	return err
}
