// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: docs.sql

package sqlcgen

import (
	"context"
)

const getAllColumnSourcesForModel = `-- name: GetAllColumnSourcesForModel :many
SELECT column_name, source_table, source_column
FROM v_column_sources WHERE model_path = ?
`

type GetAllColumnSourcesForModelRow struct {
	ColumnName   string `json:"column_name"`
	SourceTable  string `json:"source_table"`
	SourceColumn string `json:"source_column"`
}

func (q *Queries) GetAllColumnSourcesForModel(ctx context.Context, modelPath string) ([]GetAllColumnSourcesForModelRow, error) {
	rows, err := q.db.QueryContext(ctx, getAllColumnSourcesForModel, modelPath)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetAllColumnSourcesForModelRow{}
	for rows.Next() {
		var i GetAllColumnSourcesForModelRow
		if err := rows.Scan(&i.ColumnName, &i.SourceTable, &i.SourceColumn); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getColumnCount = `-- name: GetColumnCount :one
SELECT COUNT(*) FROM model_columns
`

func (q *Queries) GetColumnCount(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, getColumnCount)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getColumnLineageEdges = `-- name: GetColumnLineageEdges :many
SELECT source_id, target_id FROM v_column_lineage_edges
`

func (q *Queries) GetColumnLineageEdges(ctx context.Context) ([]VColumnLineageEdge, error) {
	rows, err := q.db.QueryContext(ctx, getColumnLineageEdges)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []VColumnLineageEdge{}
	for rows.Next() {
		var i VColumnLineageEdge
		if err := rows.Scan(&i.SourceID, &i.TargetID); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getColumnLineageEdgesForModel = `-- name: GetColumnLineageEdgesForModel :many
SELECT cle.source_id, cle.target_id
FROM v_column_lineage_edges cle
JOIN v_column_lineage_nodes cln ON cle.target_id = cln.id
WHERE cln.model = ?
`

func (q *Queries) GetColumnLineageEdgesForModel(ctx context.Context, model string) ([]VColumnLineageEdge, error) {
	rows, err := q.db.QueryContext(ctx, getColumnLineageEdgesForModel, model)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []VColumnLineageEdge{}
	for rows.Next() {
		var i VColumnLineageEdge
		if err := rows.Scan(&i.SourceID, &i.TargetID); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getColumnLineageNodes = `-- name: GetColumnLineageNodes :many
SELECT id, model, column_name FROM v_column_lineage_nodes
`

// Column Lineage
func (q *Queries) GetColumnLineageNodes(ctx context.Context) ([]VColumnLineageNode, error) {
	rows, err := q.db.QueryContext(ctx, getColumnLineageNodes)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []VColumnLineageNode{}
	for rows.Next() {
		var i VColumnLineageNode
		if err := rows.Scan(&i.ID, &i.Model, &i.ColumnName); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getColumnLineageNodesForModel = `-- name: GetColumnLineageNodesForModel :many
SELECT DISTINCT cln.id, cln.model, cln.column_name
FROM v_column_lineage_nodes cln
WHERE cln.model = ?1
UNION
SELECT DISTINCT cln2.id, cln2.model, cln2.column_name
FROM v_column_lineage_nodes cln
JOIN v_column_lineage_edges cle ON cln.id = cle.target_id
JOIN v_column_lineage_nodes cln2 ON cle.source_id = cln2.id
WHERE cln.model = ?1
`

func (q *Queries) GetColumnLineageNodesForModel(ctx context.Context, model string) ([]VColumnLineageNode, error) {
	rows, err := q.db.QueryContext(ctx, getColumnLineageNodesForModel, model)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []VColumnLineageNode{}
	for rows.Next() {
		var i VColumnLineageNode
		if err := rows.Scan(&i.ID, &i.Model, &i.ColumnName); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getColumnSourcesForColumn = `-- name: GetColumnSourcesForColumn :many
SELECT source_table, source_column
FROM v_column_sources WHERE model_path = ? AND column_name = ?
`

type GetColumnSourcesForColumnParams struct {
	ModelPath  string `json:"model_path"`
	ColumnName string `json:"column_name"`
}

type GetColumnSourcesForColumnRow struct {
	SourceTable  string `json:"source_table"`
	SourceColumn string `json:"source_column"`
}

func (q *Queries) GetColumnSourcesForColumn(ctx context.Context, arg GetColumnSourcesForColumnParams) ([]GetColumnSourcesForColumnRow, error) {
	rows, err := q.db.QueryContext(ctx, getColumnSourcesForColumn, arg.ModelPath, arg.ColumnName)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetColumnSourcesForColumnRow{}
	for rows.Next() {
		var i GetColumnSourcesForColumnRow
		if err := rows.Scan(&i.SourceTable, &i.SourceColumn); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getColumnsForModel = `-- name: GetColumnsForModel :many
SELECT name, idx, transform_type, function_name
FROM v_columns WHERE model_path = ? ORDER BY idx
`

type GetColumnsForModelRow struct {
	Name          string  `json:"name"`
	Idx           int64   `json:"idx"`
	TransformType *string `json:"transform_type"`
	FunctionName  *string `json:"function_name"`
}

// Columns
func (q *Queries) GetColumnsForModel(ctx context.Context, modelPath string) ([]GetColumnsForModelRow, error) {
	rows, err := q.db.QueryContext(ctx, getColumnsForModel, modelPath)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetColumnsForModelRow{}
	for rows.Next() {
		var i GetColumnsForModelRow
		if err := rows.Scan(
			&i.Name,
			&i.Idx,
			&i.TransformType,
			&i.FunctionName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getExternalSources = `-- name: GetExternalSources :many
SELECT name FROM v_sources ORDER BY name
`

// Sources
func (q *Queries) GetExternalSources(ctx context.Context) ([]string, error) {
	rows, err := q.db.QueryContext(ctx, getExternalSources)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []string{}
	for rows.Next() {
		var name string
		if err := rows.Scan(&name); err != nil {
			return nil, err
		}
		items = append(items, name)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getFolderCount = `-- name: GetFolderCount :one
SELECT COUNT(DISTINCT folder) FROM v_models
`

func (q *Queries) GetFolderCount(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, getFolderCount)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getLineageEdges = `-- name: GetLineageEdges :many
SELECT source_node, target_node FROM v_lineage_edges
`

// Lineage
func (q *Queries) GetLineageEdges(ctx context.Context) ([]VLineageEdge, error) {
	rows, err := q.db.QueryContext(ctx, getLineageEdges)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []VLineageEdge{}
	for rows.Next() {
		var i VLineageEdge
		if err := rows.Scan(&i.SourceNode, &i.TargetNode); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMacroNamespacesForDocs = `-- name: GetMacroNamespacesForDocs :many
SELECT DISTINCT namespace, file_path, package FROM v_macros ORDER BY namespace
`

type GetMacroNamespacesForDocsRow struct {
	Namespace string  `json:"namespace"`
	FilePath  string  `json:"file_path"`
	Package   *string `json:"package"`
}

func (q *Queries) GetMacroNamespacesForDocs(ctx context.Context) ([]GetMacroNamespacesForDocsRow, error) {
	rows, err := q.db.QueryContext(ctx, getMacroNamespacesForDocs)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetMacroNamespacesForDocsRow{}
	for rows.Next() {
		var i GetMacroNamespacesForDocsRow
		if err := rows.Scan(&i.Namespace, &i.FilePath, &i.Package); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMacrosForDocs = `-- name: GetMacrosForDocs :many
SELECT namespace, file_path, package, function_name, args, docstring, line
FROM v_macros ORDER BY namespace, function_name
`

// Macros (for future catalog)
func (q *Queries) GetMacrosForDocs(ctx context.Context) ([]VMacro, error) {
	rows, err := q.db.QueryContext(ctx, getMacrosForDocs)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []VMacro{}
	for rows.Next() {
		var i VMacro
		if err := rows.Scan(
			&i.Namespace,
			&i.FilePath,
			&i.Package,
			&i.FunctionName,
			&i.Args,
			&i.Docstring,
			&i.Line,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMaterializationCounts = `-- name: GetMaterializationCounts :many
SELECT materialized, COUNT(*) as count FROM models GROUP BY materialized
`

type GetMaterializationCountsRow struct {
	Materialized string `json:"materialized"`
	Count        int64  `json:"count"`
}

func (q *Queries) GetMaterializationCounts(ctx context.Context) ([]GetMaterializationCountsRow, error) {
	rows, err := q.db.QueryContext(ctx, getMaterializationCounts)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetMaterializationCountsRow{}
	for rows.Next() {
		var i GetMaterializationCountsRow
		if err := rows.Scan(&i.Materialized, &i.Count); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getModelCount = `-- name: GetModelCount :one
SELECT COUNT(*) FROM models
`

// Stats
func (q *Queries) GetModelCount(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, getModelCount)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getModelDependenciesByPath = `-- name: GetModelDependenciesByPath :many
SELECT parent_path FROM v_dependencies WHERE model_path = ?
`

// Dependencies
func (q *Queries) GetModelDependenciesByPath(ctx context.Context, modelPath string) ([]string, error) {
	rows, err := q.db.QueryContext(ctx, getModelDependenciesByPath, modelPath)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []string{}
	for rows.Next() {
		var parent_path string
		if err := rows.Scan(&parent_path); err != nil {
			return nil, err
		}
		items = append(items, parent_path)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getModelDependentsByPath = `-- name: GetModelDependentsByPath :many
SELECT dependent_path FROM v_dependents WHERE model_path = ?
`

func (q *Queries) GetModelDependentsByPath(ctx context.Context, modelPath string) ([]string, error) {
	rows, err := q.db.QueryContext(ctx, getModelDependentsByPath, modelPath)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []string{}
	for rows.Next() {
		var dependent_path string
		if err := rows.Scan(&dependent_path); err != nil {
			return nil, err
		}
		items = append(items, dependent_path)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getModelForDocs = `-- name: GetModelForDocs :one
SELECT id, path, name, folder, materialized, unique_key, sql_content, raw_content, file_path, description, owner, schema_name, tags, tests, meta, uses_select_star, created_at, updated_at
FROM v_models WHERE path = ?
`

func (q *Queries) GetModelForDocs(ctx context.Context, path string) (VModel, error) {
	row := q.db.QueryRowContext(ctx, getModelForDocs, path)
	var i VModel
	err := row.Scan(
		&i.ID,
		&i.Path,
		&i.Name,
		&i.Folder,
		&i.Materialized,
		&i.UniqueKey,
		&i.SqlContent,
		&i.RawContent,
		&i.FilePath,
		&i.Description,
		&i.Owner,
		&i.SchemaName,
		&i.Tags,
		&i.Tests,
		&i.Meta,
		&i.UsesSelectStar,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getModelsForDocs = `-- name: GetModelsForDocs :many

SELECT id, path, name, folder, materialized, unique_key, sql_content, raw_content, file_path, description, owner, schema_name, tags, tests, meta, uses_select_star, created_at, updated_at
FROM v_models ORDER BY folder, name
`

// Docs-specific queries for frontend consumption
// These queries use the views defined in migration 00004
// Models
func (q *Queries) GetModelsForDocs(ctx context.Context) ([]VModel, error) {
	rows, err := q.db.QueryContext(ctx, getModelsForDocs)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []VModel{}
	for rows.Next() {
		var i VModel
		if err := rows.Scan(
			&i.ID,
			&i.Path,
			&i.Name,
			&i.Folder,
			&i.Materialized,
			&i.UniqueKey,
			&i.SqlContent,
			&i.RawContent,
			&i.FilePath,
			&i.Description,
			&i.Owner,
			&i.SchemaName,
			&i.Tags,
			&i.Tests,
			&i.Meta,
			&i.UsesSelectStar,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSourceColumns = `-- name: GetSourceColumns :many
SELECT column_name FROM v_source_columns WHERE source_name = ? ORDER BY column_name
`

func (q *Queries) GetSourceColumns(ctx context.Context, sourceName string) ([]string, error) {
	rows, err := q.db.QueryContext(ctx, getSourceColumns, sourceName)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []string{}
	for rows.Next() {
		var column_name string
		if err := rows.Scan(&column_name); err != nil {
			return nil, err
		}
		items = append(items, column_name)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSourceCount = `-- name: GetSourceCount :one
SELECT COUNT(*) FROM v_sources
`

func (q *Queries) GetSourceCount(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, getSourceCount)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getSourceReferencedBy = `-- name: GetSourceReferencedBy :many
SELECT model_path FROM v_source_refs WHERE source_name = ?
`

func (q *Queries) GetSourceReferencedBy(ctx context.Context, sourceName string) ([]string, error) {
	rows, err := q.db.QueryContext(ctx, getSourceReferencedBy, sourceName)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []string{}
	for rows.Next() {
		var model_path string
		if err := rows.Scan(&model_path); err != nil {
			return nil, err
		}
		items = append(items, model_path)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchModelsLike = `-- name: SearchModelsLike :many
SELECT path, name, 
    CASE WHEN instr(path, '.') > 0
         THEN substr(path, 1, instr(path, '.') - 1)
         ELSE 'default' END AS folder,
    materialized, description
FROM models
WHERE name LIKE '%' || ? || '%' OR path LIKE '%' || ? || '%' OR description LIKE '%' || ? || '%'
ORDER BY name
LIMIT 20
`

type SearchModelsLikeParams struct {
	Column1 *string `json:"column_1"`
	Column2 *string `json:"column_2"`
	Column3 *string `json:"column_3"`
}

type SearchModelsLikeRow struct {
	Path         string  `json:"path"`
	Name         string  `json:"name"`
	Folder       string  `json:"folder"`
	Materialized string  `json:"materialized"`
	Description  *string `json:"description"`
}

// Search (FTS5 fallback with LIKE) - Used by SQLC. For proper FTS5, use SearchModels() method directly.
func (q *Queries) SearchModelsLike(ctx context.Context, arg SearchModelsLikeParams) ([]SearchModelsLikeRow, error) {
	rows, err := q.db.QueryContext(ctx, searchModelsLike, arg.Column1, arg.Column2, arg.Column3)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []SearchModelsLikeRow{}
	for rows.Next() {
		var i SearchModelsLikeRow
		if err := rows.Scan(
			&i.Path,
			&i.Name,
			&i.Folder,
			&i.Materialized,
			&i.Description,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
