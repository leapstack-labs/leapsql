// Code generated by scripts/gendialect. DO NOT EDIT.
// Source: DuckDB v1.1.3
// Generated: 2026-01-05

package duckdb

import "github.com/leapstack-labs/leapsql/pkg/dialect"

// duckDBFunctionDocs contains documentation for all DuckDB functions.
var duckDBFunctionDocs = map[string]dialect.FunctionDoc{
	"abs": {
		Description: "Absolute value",
		Signatures: []string{
			"abs(x UHUGEINT) -> UHUGEINT",
		},
		ReturnType: "UHUGEINT",
	},
	"acos": {
		Description: "Computes the arccosine of x",
		Signatures: []string{
			"acos(x DOUBLE) -> DOUBLE",
		},
		ReturnType: "DOUBLE",
	},
	"acosh": {
		Description: "Computes the inverse hyperbolic cos of x",
		Signatures: []string{
			"acosh(x DOUBLE) -> DOUBLE",
		},
		ReturnType: "DOUBLE",
	},
	"add": {
		Signatures: []string{
			"add(col0 INTERVAL, col1 TIME WITH TIME ZONE) -> TIME WITH TIME ZONE",
		},
		ReturnType: "TIME WITH TIME ZONE",
	},
	"add_parquet_key": {
		Signatures: []string{
			"add_parquet_key(col0 VARCHAR, col1 VARCHAR) -> ",
		},
	},
	"age": {
		Description: "Subtract arguments, resulting in the time difference between the two timestamps",
		Signatures: []string{
			"age(timestamp TIMESTAMP, timestamp TIMESTAMP) -> INTERVAL",
		},
		ReturnType: "INTERVAL",
	},
	"aggregate": {
		Description: "Executes the aggregate function name on the elements of list",
		Signatures: []string{
			"aggregate(list ANY[], name VARCHAR) -> ANY",
		},
		ReturnType: "ANY",
	},
	"alias": {
		Description: "Returns the name of a given expression",
		Signatures: []string{
			"alias(expr ANY) -> VARCHAR",
		},
		ReturnType: "VARCHAR",
	},
	"all_profiling_output": {
		Signatures: []string{
			"all_profiling_output() -> ",
		},
	},
	"any_value": {
		Signatures: []string{
			"any_value(col0 ANY) -> ANY",
		},
		ReturnType: "ANY",
	},
	"apply": {
		Description: "Returns a list that is the result of applying the lambda function to each element of the input list. See the Lambda Functions section for more details",
		Signatures: []string{
			"apply(list ANY[], lambda LAMBDA) -> ANY[]",
		},
		ReturnType: "ANY[]",
	},
	"approx_count_distinct": {
		Description: "Computes the approximate count of distinct elements using HyperLogLog.",
		Signatures: []string{
			"approx_count_distinct(any ANY) -> BIGINT",
		},
		ReturnType: "BIGINT",
	},
	"approx_quantile": {
		Description: "Computes the approximate quantile using T-Digest.",
		Signatures: []string{
			"approx_quantile(x TIMESTAMP, pos FLOAT[]) -> TIMESTAMP[]",
		},
		ReturnType: "TIMESTAMP[]",
	},
	"approx_top_k": {
		Description: "Finds the k approximately most occurring values in the data set",
		Signatures: []string{
			"approx_top_k(val ANY, k BIGINT) -> ANY[]",
		},
		ReturnType: "ANY[]",
	},
	"arbitrary": {
		Signatures: []string{
			"arbitrary(col0 ANY) -> ANY",
		},
		ReturnType: "ANY",
	},
	"arg_max": {
		Description: "Finds the row with the maximum val. Calculates the non-NULL arg expression at that row.",
		Signatures: []string{
			"arg_max(arg BLOB, val HUGEINT) -> BLOB",
		},
		ReturnType: "BLOB",
	},
	"arg_max_null": {
		Description: "Finds the row with the maximum val. Calculates the arg expression at that row.",
		Signatures: []string{
			"arg_max_null(arg VARCHAR, val HUGEINT) -> VARCHAR",
		},
		ReturnType: "VARCHAR",
	},
	"arg_min": {
		Description: "Finds the row with the minimum val. Calculates the non-NULL arg expression at that row.",
		Signatures: []string{
			"arg_min(arg DECIMAL, val DATE) -> DECIMAL",
		},
		ReturnType: "DECIMAL",
	},
	"arg_min_null": {
		Description: "Finds the row with the minimum val. Calculates the arg expression at that row.",
		Signatures: []string{
			"arg_min_null(arg DOUBLE, val BLOB) -> DOUBLE",
		},
		ReturnType: "DOUBLE",
	},
	"argmax": {
		Description: "Finds the row with the maximum val. Calculates the non-NULL arg expression at that row.",
		Signatures: []string{
			"argmax(arg ANY, val BLOB) -> ANY",
		},
		ReturnType: "ANY",
	},
	"argmin": {
		Description: "Finds the row with the minimum val. Calculates the non-NULL arg expression at that row.",
		Signatures: []string{
			"argmin(arg TIMESTAMP, val VARCHAR) -> TIMESTAMP",
		},
		ReturnType: "TIMESTAMP",
	},
	"array_agg": {
		Description: "Returns a LIST containing all the values of a column.",
		Signatures: []string{
			"array_agg(arg ANY) -> LIST",
		},
		ReturnType: "LIST",
	},
	"array_aggr": {
		Description: "Executes the aggregate function name on the elements of list",
		Signatures: []string{
			"array_aggr(list ANY[], name VARCHAR) -> ANY",
		},
		ReturnType: "ANY",
	},
	"array_aggregate": {
		Description: "Executes the aggregate function name on the elements of list",
		Signatures: []string{
			"array_aggregate(list ANY[], name VARCHAR) -> ANY",
		},
		ReturnType: "ANY",
	},
	"array_append": {
		Signatures: []string{
			"array_append(arr, el) -> ",
		},
	},
	"array_apply": {
		Description: "Returns a list that is the result of applying the lambda function to each element of the input list. See the Lambda Functions section for more details",
		Signatures: []string{
			"array_apply(list ANY[], lambda LAMBDA) -> ANY[]",
		},
		ReturnType: "ANY[]",
	},
	"array_cat": {
		Signatures: []string{
			"array_cat(col0 ANY[], col1 ANY[]) -> ANY[]",
		},
		ReturnType: "ANY[]",
	},
	"array_concat": {
		Signatures: []string{
			"array_concat(col0 ANY[], col1 ANY[]) -> ANY[]",
		},
		ReturnType: "ANY[]",
	},
	"array_contains": {
		Signatures: []string{
			"array_contains(col0 ANY[], col1 ANY) -> BOOLEAN",
		},
		ReturnType: "BOOLEAN",
	},
	"array_cosine_distance": {
		Description: "Compute the cosine distance between two arrays of the same size. The array elements can not be NULL. The arrays can have any size as long as the size is the same for both arguments.",
		Signatures: []string{
			"array_cosine_distance(array1 DOUBLE[ANY], array2 DOUBLE[ANY]) -> DOUBLE",
		},
		ReturnType: "DOUBLE",
	},
	"array_cosine_similarity": {
		Description: "Compute the cosine similarity between two arrays of the same size. The array elements can not be NULL. The arrays can have any size as long as the size is the same for both arguments.",
		Signatures: []string{
			"array_cosine_similarity(array1 FLOAT[ANY], array2 FLOAT[ANY]) -> FLOAT",
		},
		ReturnType: "FLOAT",
	},
	"array_cross_product": {
		Description: "Compute the cross product of two arrays of size 3. The array elements can not be NULL.",
		Signatures: []string{
			"array_cross_product(array FLOAT[3], array FLOAT[3]) -> FLOAT[3]",
		},
		ReturnType: "FLOAT[3]",
	},
	"array_distance": {
		Description: "Compute the distance between two arrays of the same size. The array elements can not be NULL. The arrays can have any size as long as the size is the same for both arguments.",
		Signatures: []string{
			"array_distance(array1 DOUBLE[ANY], array2 DOUBLE[ANY]) -> DOUBLE",
		},
		ReturnType: "DOUBLE",
	},
	"array_distinct": {
		Description: "Removes all duplicates and NULLs from a list. Does not preserve the original order",
		Signatures: []string{
			"array_distinct(list ANY[]) -> ANY[]",
		},
		ReturnType: "ANY[]",
	},
	"array_dot_product": {
		Description: "Compute the inner product between two arrays of the same size. The array elements can not be NULL. The arrays can have any size as long as the size is the same for both arguments.",
		Signatures: []string{
			"array_dot_product(array1 DOUBLE[ANY], array2 DOUBLE[ANY]) -> DOUBLE",
		},
		ReturnType: "DOUBLE",
	},
	"array_extract": {
		Signatures: []string{
			"array_extract(col0 STRUCT, col1 VARCHAR) -> ANY",
		},
		ReturnType: "ANY",
	},
	"array_filter": {
		Description: "Constructs a list from those elements of the input list for which the lambda function returns true",
		Signatures: []string{
			"array_filter(list ANY[], lambda LAMBDA) -> ANY[]",
		},
		ReturnType: "ANY[]",
	},
	"array_grade_up": {
		Description: "Returns the index of their sorted position.",
		Signatures: []string{
			"array_grade_up(list ANY[], col1 VARCHAR) -> ANY[]",
		},
		ReturnType: "ANY[]",
	},
	"array_has": {
		Signatures: []string{
			"array_has(col0 ANY[], col1 ANY) -> BOOLEAN",
		},
		ReturnType: "BOOLEAN",
	},
	"array_has_all": {
		Description: "Returns true if all elements of l2 are in l1. NULLs are ignored.",
		Signatures: []string{
			"array_has_all(l1 ANY[], l2 ANY[]) -> BOOLEAN",
		},
		ReturnType: "BOOLEAN",
	},
	"array_has_any": {
		Description: "Returns true if the lists have any element in common. NULLs are ignored.",
		Signatures: []string{
			"array_has_any(l1 ANY[], l2 ANY[]) -> BOOLEAN",
		},
		ReturnType: "BOOLEAN",
	},
	"array_indexof": {
		Signatures: []string{
			"array_indexof(col0 ANY[], col1 ANY) -> INTEGER",
		},
		ReturnType: "INTEGER",
	},
	"array_inner_product": {
		Description: "Compute the inner product between two arrays of the same size. The array elements can not be NULL. The arrays can have any size as long as the size is the same for both arguments.",
		Signatures: []string{
			"array_inner_product(array1 DOUBLE[ANY], array2 DOUBLE[ANY]) -> DOUBLE",
		},
		ReturnType: "DOUBLE",
	},
	"array_intersect": {
		Signatures: []string{
			"array_intersect(l1, l2) -> ",
		},
	},
	"array_length": {
		Signatures: []string{
			"array_length(col0 ANY[], col1 BIGINT) -> BIGINT",
		},
		ReturnType: "BIGINT",
	},
	"array_negative_dot_product": {
		Description: "Compute the negative inner product between two arrays of the same size. The array elements can not be NULL. The arrays can have any size as long as the size is the same for both arguments.",
		Signatures: []string{
			"array_negative_dot_product(array1 FLOAT[ANY], array2 FLOAT[ANY]) -> FLOAT",
		},
		ReturnType: "FLOAT",
	},
	"array_negative_inner_product": {
		Description: "Compute the negative inner product between two arrays of the same size. The array elements can not be NULL. The arrays can have any size as long as the size is the same for both arguments.",
		Signatures: []string{
			"array_negative_inner_product(array1 DOUBLE[ANY], array2 DOUBLE[ANY]) -> DOUBLE",
		},
		ReturnType: "DOUBLE",
	},
	"array_pop_back": {
		Signatures: []string{
			"array_pop_back(arr) -> ",
		},
	},
	"array_pop_front": {
		Signatures: []string{
			"array_pop_front(arr) -> ",
		},
	},
	"array_position": {
		Signatures: []string{
			"array_position(col0 ANY[], col1 ANY) -> INTEGER",
		},
		ReturnType: "INTEGER",
	},
	"array_prepend": {
		Signatures: []string{
			"array_prepend(el, arr) -> ",
		},
	},
	"array_push_back": {
		Signatures: []string{
			"array_push_back(arr, e) -> ",
		},
	},
	"array_push_front": {
		Signatures: []string{
			"array_push_front(arr, e) -> ",
		},
	},
	"array_reduce": {
		Description: "Returns a single value that is the result of applying the lambda function to each element of the input list, starting with the first element and then repeatedly applying the lambda function to the result of the previous application and the next element of the list.",
		Signatures: []string{
			"array_reduce(list ANY[], lambda LAMBDA) -> ANY",
		},
		ReturnType: "ANY",
	},
	"array_resize": {
		Signatures: []string{
			"array_resize(col0 ANY[], col1 ANY, col2 ANY) -> ANY[]",
		},
		ReturnType: "ANY[]",
	},
	"array_reverse": {
		Signatures: []string{
			"array_reverse(l) -> ",
		},
	},
	"array_reverse_sort": {
		Description: "Sorts the elements of the list in reverse order",
		Signatures: []string{
			"array_reverse_sort(list ANY[], col1 VARCHAR) -> ANY[]",
		},
		ReturnType: "ANY[]",
	},
	"array_select": {
		Signatures: []string{
			"array_select(col0 ANY[], col1 BIGINT[]) -> ANY[]",
		},
		ReturnType: "ANY[]",
	},
	"array_slice": {
		Description: "Extract a sublist using slice conventions. Negative values are accepted",
		Signatures: []string{
			"array_slice(list ANY, begin ANY, end[ ANY, step] BIGINT) -> ANY",
		},
		ReturnType: "ANY",
	},
	"array_sort": {
		Description: "Sorts the elements of the list",
		Signatures: []string{
			"array_sort(list ANY[]) -> ANY[]",
		},
		ReturnType: "ANY[]",
	},
	"array_to_json": {
		Signatures: []string{
			"array_to_json() -> JSON",
		},
		ReturnType: "JSON",
	},
	"array_to_string": {
		Signatures: []string{
			"array_to_string(arr, sep) -> ",
		},
	},
	"array_to_string_comma_default": {
		Signatures: []string{
			"array_to_string_comma_default(arr, sep) -> ",
		},
	},
	"array_transform": {
		Description: "Returns a list that is the result of applying the lambda function to each element of the input list. See the Lambda Functions section for more details",
		Signatures: []string{
			"array_transform(list ANY[], lambda LAMBDA) -> ANY[]",
		},
		ReturnType: "ANY[]",
	},
	"array_unique": {
		Description: "Counts the unique elements of a list",
		Signatures: []string{
			"array_unique(list ANY[]) -> UBIGINT",
		},
		ReturnType: "UBIGINT",
	},
	"array_value": {
		Description: "Create an ARRAY containing the argument values.",
		Signatures: []string{
			"array_value() -> ARRAY",
		},
		ReturnType: "ARRAY",
	},
	"array_where": {
		Signatures: []string{
			"array_where(col0 ANY[], col1 BOOLEAN[]) -> ANY[]",
		},
		ReturnType: "ANY[]",
	},
	"array_zip": {
		Signatures: []string{
			"array_zip() -> STRUCT[]",
		},
		ReturnType: "STRUCT[]",
	},
	"arrow_scan": {
		Signatures: []string{
			"arrow_scan(col0 POINTER, col1 POINTER, col2 POINTER) -> ",
		},
	},
	"arrow_scan_dumb": {
		Signatures: []string{
			"arrow_scan_dumb(col0 POINTER, col1 POINTER, col2 POINTER) -> ",
		},
	},
	"ascii": {
		Description: "Returns an integer that represents the Unicode code point of the first character of the string",
		Signatures: []string{
			"ascii(string VARCHAR) -> INTEGER",
		},
		ReturnType: "INTEGER",
	},
	"asin": {
		Description: "Computes the arcsine of x",
		Signatures: []string{
			"asin(x DOUBLE) -> DOUBLE",
		},
		ReturnType: "DOUBLE",
	},
	"asinh": {
		Description: "Computes the inverse hyperbolic sin of x",
		Signatures: []string{
			"asinh(x DOUBLE) -> DOUBLE",
		},
		ReturnType: "DOUBLE",
	},
	"atan": {
		Description: "Computes the arctangent of x",
		Signatures: []string{
			"atan(x DOUBLE) -> DOUBLE",
		},
		ReturnType: "DOUBLE",
	},
	"atan2": {
		Description: "Computes the arctangent (y, x)",
		Signatures: []string{
			"atan2(y DOUBLE, x DOUBLE) -> DOUBLE",
		},
		ReturnType: "DOUBLE",
	},
	"atanh": {
		Description: "Computes the inverse hyperbolic tan of x",
		Signatures: []string{
			"atanh(x DOUBLE) -> DOUBLE",
		},
		ReturnType: "DOUBLE",
	},
	"avg": {
		Description: "Calculates the average value for all tuples in x.",
		Signatures: []string{
			"avg(x BIGINT) -> DOUBLE",
		},
		ReturnType: "DOUBLE",
	},
	"bar": {
		Description: "Draws a band whose width is proportional to (x - min) and equal to width characters when x = max. width defaults to 80",
		Signatures: []string{
			"bar(x DOUBLE, min DOUBLE, max DOUBLE) -> VARCHAR",
		},
		ReturnType: "VARCHAR",
	},
	"base64": {
		Description: "Convert a blob to a base64 encoded string",
		Signatures: []string{
			"base64(blob BLOB) -> VARCHAR",
		},
		ReturnType: "VARCHAR",
	},
	"bin": {
		Description: "Converts the value to binary representation",
		Signatures: []string{
			"bin(value UHUGEINT) -> VARCHAR",
		},
		ReturnType: "VARCHAR",
	},
	"bit_and": {
		Description: "Returns the bitwise AND of all bits in a given expression.",
		Signatures: []string{
			"bit_and(arg UBIGINT) -> UBIGINT",
		},
		ReturnType: "UBIGINT",
	},
	"bit_count": {
		Description: "Returns the number of bits that are set",
		Signatures: []string{
			"bit_count(x TINYINT) -> TINYINT",
		},
		ReturnType: "TINYINT",
	},
	"bit_length": {
		Signatures: []string{
			"bit_length(col0 BIT) -> BIGINT",
		},
		ReturnType: "BIGINT",
	},
	"bit_or": {
		Description: "Returns the bitwise OR of all bits in a given expression.",
		Signatures: []string{
			"bit_or(arg TINYINT) -> TINYINT",
		},
		ReturnType: "TINYINT",
	},
	"bit_position": {
		Description: "Returns first starting index of the specified substring within bits, or zero if it is not present. The first (leftmost) bit is indexed 1",
		Signatures: []string{
			"bit_position(substring BIT, bitstring BIT) -> INTEGER",
		},
		ReturnType: "INTEGER",
	},
	"bit_xor": {
		Description: "Returns the bitwise XOR of all bits in a given expression.",
		Signatures: []string{
			"bit_xor(arg BIT) -> BIT",
		},
		ReturnType: "BIT",
	},
	"bitstring": {
		Description: "Pads the bitstring until the specified length",
		Signatures: []string{
			"bitstring(bitstring VARCHAR, length INTEGER) -> BIT",
		},
		ReturnType: "BIT",
	},
	"bitstring_agg": {
		Description: "Returns a bitstring with bits set for each distinct value.",
		Signatures: []string{
			"bitstring_agg(arg TINYINT, col1 TINYINT, col2 TINYINT) -> BIT",
		},
		ReturnType: "BIT",
	},
	"bool_and": {
		Description: "Returns TRUE if every input value is TRUE, otherwise FALSE.",
		Signatures: []string{
			"bool_and(arg BOOLEAN) -> BOOLEAN",
		},
		ReturnType: "BOOLEAN",
	},
	"bool_or": {
		Description: "Returns TRUE if any input value is TRUE, otherwise FALSE.",
		Signatures: []string{
			"bool_or(arg BOOLEAN) -> BOOLEAN",
		},
		ReturnType: "BOOLEAN",
	},
	"can_cast_implicitly": {
		Description: "Whether or not we can implicitly cast from the source type to the other type",
		Signatures: []string{
			"can_cast_implicitly(source_type ANY, target_type ANY) -> BOOLEAN",
		},
		ReturnType: "BOOLEAN",
	},
	"cardinality": {
		Description: "Returns the size of the map (or the number of entries in the map)",
		Signatures: []string{
			"cardinality(map ANY) -> UBIGINT",
		},
		ReturnType: "UBIGINT",
	},
	"cbrt": {
		Description: "Returns the cube root of x",
		Signatures: []string{
			"cbrt(x DOUBLE) -> DOUBLE",
		},
		ReturnType: "DOUBLE",
	},
	"ceil": {
		Description: "Rounds the number up",
		Signatures: []string{
			"ceil(x DOUBLE) -> DOUBLE",
		},
		ReturnType: "DOUBLE",
	},
	"ceiling": {
		Description: "Rounds the number up",
		Signatures: []string{
			"ceiling(x DECIMAL) -> DECIMAL",
		},
		ReturnType: "DECIMAL",
	},
	"century": {
		Description: "Extract the century component from a date or timestamp",
		Signatures: []string{
			"century(ts DATE) -> BIGINT",
		},
		ReturnType: "BIGINT",
	},
	"checkpoint": {
		Signatures: []string{
			"checkpoint() -> ",
		},
	},
	"chr": {
		Description: "Returns a character which is corresponding the ASCII code value or Unicode code point",
		Signatures: []string{
			"chr(code_point INTEGER) -> VARCHAR",
		},
		ReturnType: "VARCHAR",
	},
	"collations": {
		Signatures: []string{
			"collations() -> ",
		},
	},
	"combine": {
		Signatures: []string{
			"combine(col0 AGGREGATE_STATE<?>, col1 ANY) -> AGGREGATE_STATE<?>",
		},
		ReturnType: "AGGREGATE_STATE<?>",
	},
	"concat": {
		Signatures: []string{
			"concat(col0 ANY) -> ANY",
		},
		ReturnType: "ANY",
	},
	"concat_ws": {
		Signatures: []string{
			"concat_ws(col0 VARCHAR, col1 ANY) -> VARCHAR",
		},
		ReturnType: "VARCHAR",
	},
	"constant_or_null": {
		Signatures: []string{
			"constant_or_null(col0 ANY, col1 ANY) -> ANY",
		},
		ReturnType: "ANY",
	},
	"contains": {
		Signatures: []string{
			"contains(col0 MAP(ANY, col1 ANY)) -> BOOLEAN",
		},
		ReturnType: "BOOLEAN",
	},
	"copy_database": {
		Signatures: []string{
			"copy_database(col0 VARCHAR, col1 VARCHAR) -> ",
		},
	},
	"corr": {
		Description: "Returns the correlation coefficient for non-null pairs in a group.",
		Signatures: []string{
			"corr(y DOUBLE, x DOUBLE) -> DOUBLE",
		},
		ReturnType: "DOUBLE",
	},
	"cos": {
		Description: "Computes the cos of x",
		Signatures: []string{
			"cos(x DOUBLE) -> DOUBLE",
		},
		ReturnType: "DOUBLE",
	},
	"cosh": {
		Description: "Computes the hyperbolic cos of x",
		Signatures: []string{
			"cosh(x DOUBLE) -> DOUBLE",
		},
		ReturnType: "DOUBLE",
	},
	"cot": {
		Description: "Computes the cotangent of x",
		Signatures: []string{
			"cot(x DOUBLE) -> DOUBLE",
		},
		ReturnType: "DOUBLE",
	},
	"count": {
		Signatures: []string{
			"count() -> BIGINT",
		},
		ReturnType: "BIGINT",
	},
	"count_if": {
		Signatures: []string{
			"count_if(l) -> ",
		},
	},
	"count_star": {
		Signatures: []string{
			"count_star() -> BIGINT",
		},
		ReturnType: "BIGINT",
	},
	"covar_pop": {
		Description: "Returns the population covariance of input values.",
		Signatures: []string{
			"covar_pop(y DOUBLE, x DOUBLE) -> DOUBLE",
		},
		ReturnType: "DOUBLE",
	},
	"covar_samp": {
		Description: "Returns the sample covariance for non-null pairs in a group.",
		Signatures: []string{
			"covar_samp(y DOUBLE, x DOUBLE) -> DOUBLE",
		},
		ReturnType: "DOUBLE",
	},
	"create_sort_key": {
		Description: "Constructs a binary-comparable sort key based on a set of input parameters and sort qualifiers",
		Signatures: []string{
			"create_sort_key(parameters... ANY) -> BLOB",
		},
		ReturnType: "BLOB",
	},
	"current_catalog": {
		Signatures: []string{
			"current_catalog() -> ",
		},
	},
	"current_database": {
		Description: "Returns the name of the currently active database",
		Signatures: []string{
			"current_database() -> VARCHAR",
		},
		ReturnType: "VARCHAR",
	},
	"current_date": {
		Description: "Returns the current date",
		Signatures: []string{
			"current_date() -> DATE",
		},
		ReturnType: "DATE",
	},
	"current_query": {
		Description: "Returns the current query as a string",
		Signatures: []string{
			"current_query() -> VARCHAR",
		},
		ReturnType: "VARCHAR",
	},
	"current_role": {
		Signatures: []string{
			"current_role() -> ",
		},
	},
	"current_schema": {
		Description: "Returns the name of the currently active schema. Default is main",
		Signatures: []string{
			"current_schema() -> VARCHAR",
		},
		ReturnType: "VARCHAR",
	},
	"current_schemas": {
		Description: "Returns list of schemas. Pass a parameter of True to include implicit schemas",
		Signatures: []string{
			"current_schemas(include_implicit BOOLEAN) -> VARCHAR[]",
		},
		ReturnType: "VARCHAR[]",
	},
	"current_setting": {
		Description: "Returns the current value of the configuration setting",
		Signatures: []string{
			"current_setting(setting_name VARCHAR) -> ANY",
		},
		ReturnType: "ANY",
	},
	"current_user": {
		Signatures: []string{
			"current_user() -> ",
		},
	},
	"currval": {
		Signatures: []string{
			"currval(col0 VARCHAR) -> BIGINT",
		},
		ReturnType: "BIGINT",
	},
	"damerau_levenshtein": {
		Description: "Extension of Levenshtein distance to also include transposition of adjacent characters as an allowed edit operation. In other words, the minimum number of edit operations (insertions, deletions, substitutions or transpositions) required to change one string to another. Different case is considered different",
		Signatures: []string{
			"damerau_levenshtein(str1 VARCHAR, str2 VARCHAR) -> BIGINT",
		},
		ReturnType: "BIGINT",
	},
	"database_list": {
		Signatures: []string{
			"database_list() -> ",
		},
	},
	"database_size": {
		Signatures: []string{
			"database_size() -> ",
		},
	},
	"date_add": {
		Signatures: []string{
			"date_add(date, interval) -> ",
		},
	},
	"date_diff": {
		Description: "The number of partition boundaries between the timestamps",
		Signatures: []string{
			"date_diff(part VARCHAR, startdate DATE, enddate DATE) -> BIGINT",
		},
		ReturnType: "BIGINT",
	},
	"date_part": {
		Description: "Get subfield (equivalent to extract)",
		Signatures: []string{
			"date_part(ts VARCHAR, col1 DATE) -> BIGINT",
		},
		ReturnType: "BIGINT",
	},
	"date_sub": {
		Description: "The number of complete partitions between the timestamps",
		Signatures: []string{
			"date_sub(part VARCHAR, startdate DATE, enddate DATE) -> BIGINT",
		},
		ReturnType: "BIGINT",
	},
	"date_trunc": {
		Description: "Truncate to specified precision",
		Signatures: []string{
			"date_trunc(part VARCHAR, timestamp TIMESTAMP) -> TIMESTAMP",
		},
		ReturnType: "TIMESTAMP",
	},
	"datediff": {
		Description: "The number of partition boundaries between the timestamps",
		Signatures: []string{
			"datediff(part VARCHAR, startdate TIMESTAMP, enddate TIMESTAMP) -> BIGINT",
		},
		ReturnType: "BIGINT",
	},
	"datepart": {
		Description: "Get subfield (equivalent to extract)",
		Signatures: []string{
			"datepart(ts VARCHAR, col1 TIME) -> BIGINT",
		},
		ReturnType: "BIGINT",
	},
	"datesub": {
		Description: "The number of complete partitions between the timestamps",
		Signatures: []string{
			"datesub(part VARCHAR, startdate DATE, enddate DATE) -> BIGINT",
		},
		ReturnType: "BIGINT",
	},
	"datetrunc": {
		Description: "Truncate to specified precision",
		Signatures: []string{
			"datetrunc(part VARCHAR, timestamp TIMESTAMP) -> TIMESTAMP",
		},
		ReturnType: "TIMESTAMP",
	},
	"day": {
		Description: "Extract the day component from a date or timestamp",
		Signatures: []string{
			"day(ts TIMESTAMP) -> BIGINT",
		},
		ReturnType: "BIGINT",
	},
	"dayname": {
		Description: "The (English) name of the weekday",
		Signatures: []string{
			"dayname(ts TIMESTAMP) -> VARCHAR",
		},
		ReturnType: "VARCHAR",
	},
	"dayofmonth": {
		Description: "Extract the dayofmonth component from a date or timestamp",
		Signatures: []string{
			"dayofmonth(ts INTERVAL) -> BIGINT",
		},
		ReturnType: "BIGINT",
	},
	"dayofweek": {
		Description: "Extract the dayofweek component from a date or timestamp",
		Signatures: []string{
			"dayofweek(ts INTERVAL) -> BIGINT",
		},
		ReturnType: "BIGINT",
	},
	"dayofyear": {
		Description: "Extract the dayofyear component from a date or timestamp",
		Signatures: []string{
			"dayofyear(ts INTERVAL) -> BIGINT",
		},
		ReturnType: "BIGINT",
	},
	"decade": {
		Description: "Extract the decade component from a date or timestamp",
		Signatures: []string{
			"decade(ts TIMESTAMP) -> BIGINT",
		},
		ReturnType: "BIGINT",
	},
	"decode": {
		Description: "Convert blob to varchar. Fails if blob is not valid utf-8",
		Signatures: []string{
			"decode(blob BLOB) -> VARCHAR",
		},
		ReturnType: "VARCHAR",
	},
	"degrees": {
		Description: "Converts radians to degrees",
		Signatures: []string{
			"degrees(x DOUBLE) -> DOUBLE",
		},
		ReturnType: "DOUBLE",
	},
	"disable_checkpoint_on_shutdown": {
		Signatures: []string{
			"disable_checkpoint_on_shutdown() -> ",
		},
	},
	"disable_object_cache": {
		Signatures: []string{
			"disable_object_cache() -> ",
		},
	},
	"disable_optimizer": {
		Signatures: []string{
			"disable_optimizer() -> ",
		},
	},
	"disable_print_progress_bar": {
		Signatures: []string{
			"disable_print_progress_bar() -> ",
		},
	},
	"disable_profile": {
		Signatures: []string{
			"disable_profile() -> ",
		},
	},
	"disable_profiling": {
		Signatures: []string{
			"disable_profiling() -> ",
		},
	},
	"disable_progress_bar": {
		Signatures: []string{
			"disable_progress_bar() -> ",
		},
	},
	"disable_verification": {
		Signatures: []string{
			"disable_verification() -> ",
		},
	},
	"disable_verify_external": {
		Signatures: []string{
			"disable_verify_external() -> ",
		},
	},
	"disable_verify_fetch_row": {
		Signatures: []string{
			"disable_verify_fetch_row() -> ",
		},
	},
	"disable_verify_parallelism": {
		Signatures: []string{
			"disable_verify_parallelism() -> ",
		},
	},
	"disable_verify_serializer": {
		Signatures: []string{
			"disable_verify_serializer() -> ",
		},
	},
	"divide": {
		Signatures: []string{
			"divide(col0 INTEGER, col1 INTEGER) -> INTEGER",
		},
		ReturnType: "INTEGER",
	},
	"duckdb_columns": {
		Signatures: []string{
			"duckdb_columns() -> ",
		},
	},
	"duckdb_constraints": {
		Signatures: []string{
			"duckdb_constraints() -> ",
		},
	},
	"duckdb_databases": {
		Signatures: []string{
			"duckdb_databases() -> ",
		},
	},
	"duckdb_dependencies": {
		Signatures: []string{
			"duckdb_dependencies() -> ",
		},
	},
	"duckdb_extensions": {
		Signatures: []string{
			"duckdb_extensions() -> ",
		},
	},
	"duckdb_functions": {
		Signatures: []string{
			"duckdb_functions() -> ",
		},
	},
	"duckdb_indexes": {
		Signatures: []string{
			"duckdb_indexes() -> ",
		},
	},
	"duckdb_keywords": {
		Signatures: []string{
			"duckdb_keywords() -> ",
		},
	},
	"duckdb_memory": {
		Signatures: []string{
			"duckdb_memory() -> ",
		},
	},
	"duckdb_optimizers": {
		Signatures: []string{
			"duckdb_optimizers() -> ",
		},
	},
	"duckdb_schemas": {
		Signatures: []string{
			"duckdb_schemas() -> ",
		},
	},
	"duckdb_secrets": {
		Signatures: []string{
			"duckdb_secrets(redact BOOLEAN) -> ",
		},
	},
	"duckdb_sequences": {
		Signatures: []string{
			"duckdb_sequences() -> ",
		},
	},
	"duckdb_settings": {
		Signatures: []string{
			"duckdb_settings() -> ",
		},
	},
	"duckdb_tables": {
		Signatures: []string{
			"duckdb_tables() -> ",
		},
	},
	"duckdb_temporary_files": {
		Signatures: []string{
			"duckdb_temporary_files() -> ",
		},
	},
	"duckdb_types": {
		Signatures: []string{
			"duckdb_types() -> ",
		},
	},
	"duckdb_variables": {
		Signatures: []string{
			"duckdb_variables() -> ",
		},
	},
	"duckdb_views": {
		Signatures: []string{
			"duckdb_views() -> ",
		},
	},
	"editdist3": {
		Description: "The minimum number of single-character edits (insertions, deletions or substitutions) required to change one string to the other. Different case is considered different",
		Signatures: []string{
			"editdist3(str1 VARCHAR, str2 VARCHAR) -> BIGINT",
		},
		ReturnType: "BIGINT",
	},
	"element_at": {
		Description: "Returns a list containing the value for a given key or an empty list if the key is not contained in the map. The type of the key provided in the second parameter must match the type of the map’s keys else an error is returned",
		Signatures: []string{
			"element_at(map ANY, key ANY) -> ANY",
		},
		ReturnType: "ANY",
	},
	"enable_checkpoint_on_shutdown": {
		Signatures: []string{
			"enable_checkpoint_on_shutdown() -> ",
		},
	},
	"enable_object_cache": {
		Signatures: []string{
			"enable_object_cache() -> ",
		},
	},
	"enable_optimizer": {
		Signatures: []string{
			"enable_optimizer() -> ",
		},
	},
	"enable_print_progress_bar": {
		Signatures: []string{
			"enable_print_progress_bar() -> ",
		},
	},
	"enable_profile": {
		Signatures: []string{
			"enable_profile() -> ",
		},
	},
	"enable_profiling": {
		Signatures: []string{
			"enable_profiling() -> ",
		},
	},
	"enable_progress_bar": {
		Signatures: []string{
			"enable_progress_bar() -> ",
		},
	},
	"enable_verification": {
		Signatures: []string{
			"enable_verification() -> ",
		},
	},
	"encode": {
		Description: "Convert varchar to blob. Converts utf-8 characters into literal encoding",
		Signatures: []string{
			"encode(string VARCHAR) -> BLOB",
		},
		ReturnType: "BLOB",
	},
	"ends_with": {
		Signatures: []string{
			"ends_with(col0 VARCHAR, col1 VARCHAR) -> BOOLEAN",
		},
		ReturnType: "BOOLEAN",
	},
	"entropy": {
		Description: "Returns the log-2 entropy of count input-values.",
		Signatures: []string{
			"entropy(x TIMESTAMP) -> DOUBLE",
		},
		ReturnType: "DOUBLE",
	},
	"enum_code": {
		Description: "Returns the numeric value backing the given enum value",
		Signatures: []string{
			"enum_code(enum ANY) -> ANY",
		},
		ReturnType: "ANY",
	},
	"enum_first": {
		Description: "Returns the first value of the input enum type",
		Signatures: []string{
			"enum_first(enum ANY) -> VARCHAR",
		},
		ReturnType: "VARCHAR",
	},
	"enum_last": {
		Description: "Returns the last value of the input enum type",
		Signatures: []string{
			"enum_last(enum ANY) -> VARCHAR",
		},
		ReturnType: "VARCHAR",
	},
	"enum_range": {
		Description: "Returns all values of the input enum type as an array",
		Signatures: []string{
			"enum_range(enum ANY) -> VARCHAR[]",
		},
		ReturnType: "VARCHAR[]",
	},
	"enum_range_boundary": {
		Description: "Returns the range between the two given enum values as an array. The values must be of the same enum type. When the first parameter is NULL, the result starts with the first value of the enum type. When the second parameter is NULL, the result ends with the last value of the enum type",
		Signatures: []string{
			"enum_range_boundary(start ANY, end ANY) -> VARCHAR[]",
		},
		ReturnType: "VARCHAR[]",
	},
	"epoch": {
		Description: "Extract the epoch component from a temporal type",
		Signatures: []string{
			"epoch(temporal INTERVAL) -> DOUBLE",
		},
		ReturnType: "DOUBLE",
	},
	"epoch_ms": {
		Description: "Extract the epoch component in milliseconds from a temporal type",
		Signatures: []string{
			"epoch_ms(temporal TIMESTAMP WITH TIME ZONE) -> BIGINT",
		},
		ReturnType: "BIGINT",
	},
	"epoch_ns": {
		Description: "Extract the epoch component in nanoseconds from a temporal type",
		Signatures: []string{
			"epoch_ns(temporal TIMESTAMP) -> BIGINT",
		},
		ReturnType: "BIGINT",
	},
	"epoch_us": {
		Description: "Extract the epoch component in microseconds from a temporal type",
		Signatures: []string{
			"epoch_us(temporal TIMESTAMP) -> BIGINT",
		},
		ReturnType: "BIGINT",
	},
	"equi_width_bins": {
		Description: "Generates bin_count equi-width bins between the min and max. If enabled nice_rounding makes the numbers more readable/less jagged",
		Signatures: []string{
			"equi_width_bins(min BIGINT, max BIGINT, bin_count BIGINT, nice_rounding BOOLEAN) -> ANY[]",
		},
		ReturnType: "ANY[]",
	},
	"era": {
		Description: "Extract the era component from a date or timestamp",
		Signatures: []string{
			"era(ts DATE) -> BIGINT",
		},
		ReturnType: "BIGINT",
	},
	"error": {
		Description: "Throws the given error message",
		Signatures: []string{
			"error(message VARCHAR) -> \"NULL\"",
		},
		ReturnType: "\"NULL\"",
	},
	"even": {
		Description: "Rounds x to next even number by rounding away from zero",
		Signatures: []string{
			"even(x DOUBLE) -> DOUBLE",
		},
		ReturnType: "DOUBLE",
	},
	"exp": {
		Description: "Computes e to the power of x",
		Signatures: []string{
			"exp(x DOUBLE) -> DOUBLE",
		},
		ReturnType: "DOUBLE",
	},
	"extension_versions": {
		Signatures: []string{
			"extension_versions() -> ",
		},
	},
	"factorial": {
		Description: "Factorial of x. Computes the product of the current integer and all integers below it",
		Signatures: []string{
			"factorial(x INTEGER) -> HUGEINT",
		},
		ReturnType: "HUGEINT",
	},
	"favg": {
		Description: "Calculates the average using a more accurate floating point summation (Kahan Sum)",
		Signatures: []string{
			"favg(x DOUBLE) -> DOUBLE",
		},
		ReturnType: "DOUBLE",
	},
	"fdiv": {
		Signatures: []string{
			"fdiv(x, y) -> ",
		},
	},
	"filter": {
		Description: "Constructs a list from those elements of the input list for which the lambda function returns true",
		Signatures: []string{
			"filter(list ANY[], lambda LAMBDA) -> ANY[]",
		},
		ReturnType: "ANY[]",
	},
	"finalize": {
		Signatures: []string{
			"finalize(col0 AGGREGATE_STATE<?>) -> INVALID",
		},
		ReturnType: "INVALID",
	},
	"first": {
		Signatures: []string{
			"first(col0 DECIMAL) -> DECIMAL",
		},
		ReturnType: "DECIMAL",
	},
	"flatten": {
		Description: "Flatten a nested list by one level",
		Signatures: []string{
			"flatten(nested_list ANY[][]) -> ANY[]",
		},
		ReturnType: "ANY[]",
	},
	"floor": {
		Description: "Rounds the number down",
		Signatures: []string{
			"floor(x DECIMAL) -> DECIMAL",
		},
		ReturnType: "DECIMAL",
	},
	"fmod": {
		Signatures: []string{
			"fmod(x, y) -> ",
		},
	},
	"force_checkpoint": {
		Signatures: []string{
			"force_checkpoint() -> ",
			"force_checkpoint(col0 VARCHAR) -> ",
		},
	},
	"format": {
		Description: "Formats a string using fmt syntax",
		Signatures: []string{
			"format(format VARCHAR) -> VARCHAR",
		},
		ReturnType: "VARCHAR",
	},
	"format_bytes": {
		Description: "Converts bytes to a human-readable presentation (e.g. 16000 -> 15.6 KiB)",
		Signatures: []string{
			"format_bytes(bytes BIGINT) -> VARCHAR",
		},
		ReturnType: "VARCHAR",
	},
	"formatreadabledecimalsize": {
		Description: "Converts bytes to a human-readable presentation (e.g. 16000 -> 16.0 KB)",
		Signatures: []string{
			"formatreadabledecimalsize(bytes BIGINT) -> VARCHAR",
		},
		ReturnType: "VARCHAR",
	},
	"formatreadablesize": {
		Description: "Converts bytes to a human-readable presentation (e.g. 16000 -> 15.6 KiB)",
		Signatures: []string{
			"formatreadablesize(bytes BIGINT) -> VARCHAR",
		},
		ReturnType: "VARCHAR",
	},
	"from_base64": {
		Description: "Convert a base64 encoded string to a character string",
		Signatures: []string{
			"from_base64(string VARCHAR) -> BLOB",
		},
		ReturnType: "BLOB",
	},
	"from_binary": {
		Description: "Converts a value from binary representation to a blob",
		Signatures: []string{
			"from_binary(value VARCHAR) -> BLOB",
		},
		ReturnType: "BLOB",
	},
	"from_hex": {
		Description: "Converts a value from hexadecimal representation to a blob",
		Signatures: []string{
			"from_hex(value VARCHAR) -> BLOB",
		},
		ReturnType: "BLOB",
	},
	"from_json": {
		Signatures: []string{
			"from_json(col0 JSON, col1 VARCHAR) -> ANY",
		},
		ReturnType: "ANY",
	},
	"from_json_strict": {
		Signatures: []string{
			"from_json_strict(col0 JSON, col1 VARCHAR) -> ANY",
		},
		ReturnType: "ANY",
	},
	"fsum": {
		Description: "Calculates the sum using a more accurate floating point summation (Kahan Sum).",
		Signatures: []string{
			"fsum(arg DOUBLE) -> DOUBLE",
		},
		ReturnType: "DOUBLE",
	},
	"functions": {
		Signatures: []string{
			"functions() -> ",
		},
	},
	"gamma": {
		Description: "Interpolation of (x-1) factorial (so decimal inputs are allowed)",
		Signatures: []string{
			"gamma(x DOUBLE) -> DOUBLE",
		},
		ReturnType: "DOUBLE",
	},
	"gcd": {
		Description: "Computes the greatest common divisor of x and y",
		Signatures: []string{
			"gcd(x BIGINT, y BIGINT) -> BIGINT",
		},
		ReturnType: "BIGINT",
	},
	"gen_random_uuid": {
		Description: "Returns a random UUID similar to this: eeccb8c5-9943-b2bb-bb5e-222f4e14b687",
		Signatures: []string{
			"gen_random_uuid() -> UUID",
		},
		ReturnType: "UUID",
	},
	"generate_series": {
		Description: "Create a list of values between start and stop - the stop parameter is inclusive",
		Signatures: []string{
			"generate_series(start BIGINT, stop BIGINT) -> BIGINT[]",
			"generate_series(col0 BIGINT, col1 BIGINT) -> ",
		},
		ReturnType: "BIGINT[]",
	},
	"generate_subscripts": {
		Signatures: []string{
			"generate_subscripts(arr, dim) -> ",
		},
	},
	"geomean": {
		Signatures: []string{
			"geomean(x) -> ",
		},
	},
	"geometric_mean": {
		Signatures: []string{
			"geometric_mean(x) -> ",
		},
	},
	"get_bit": {
		Description: "Extracts the nth bit from bitstring; the first (leftmost) bit is indexed 0",
		Signatures: []string{
			"get_bit(bitstring BIT, index INTEGER) -> INTEGER",
		},
		ReturnType: "INTEGER",
	},
	"get_block_size": {
		Signatures: []string{
			"get_block_size(db_name) -> ",
		},
	},
	"get_current_time": {
		Description: "Returns the current time",
		Signatures: []string{
			"get_current_time() -> TIME",
		},
		ReturnType: "TIME",
	},
	"get_current_timestamp": {
		Description: "Returns the current timestamp",
		Signatures: []string{
			"get_current_timestamp() -> TIMESTAMP WITH TIME ZONE",
		},
		ReturnType: "TIMESTAMP WITH TIME ZONE",
	},
	"getvariable": {
		Signatures: []string{
			"getvariable(col0 VARCHAR) -> ANY",
		},
		ReturnType: "ANY",
	},
	"glob": {
		Signatures: []string{
			"glob(col0 VARCHAR) -> ",
		},
	},
	"grade_up": {
		Description: "Returns the index of their sorted position.",
		Signatures: []string{
			"grade_up(list ANY[]) -> ANY[]",
		},
		ReturnType: "ANY[]",
	},
	"greatest": {
		Description: "Returns the highest value of the set of input parameters",
		Signatures: []string{
			"greatest(arg1 ANY) -> ANY",
		},
		ReturnType: "ANY",
	},
	"greatest_common_divisor": {
		Description: "Computes the greatest common divisor of x and y",
		Signatures: []string{
			"greatest_common_divisor(x HUGEINT, y HUGEINT) -> HUGEINT",
		},
		ReturnType: "HUGEINT",
	},
	"group_concat": {
		Description: "Concatenates the column string values with an optional separator.",
		Signatures: []string{
			"group_concat(str ANY, arg VARCHAR) -> VARCHAR",
		},
		ReturnType: "VARCHAR",
	},
	"hamming": {
		Description: "The number of positions with different characters for 2 strings of equal length. Different case is considered different",
		Signatures: []string{
			"hamming(str1 VARCHAR, str2 VARCHAR) -> BIGINT",
		},
		ReturnType: "BIGINT",
	},
	"hash": {
		Description: "Returns an integer with the hash of the value. Note that this is not a cryptographic hash",
		Signatures: []string{
			"hash(param ANY) -> UBIGINT",
		},
		ReturnType: "UBIGINT",
	},
	"hex": {
		Description: "Converts the value to hexadecimal representation",
		Signatures: []string{
			"hex(value HUGEINT) -> VARCHAR",
		},
		ReturnType: "VARCHAR",
	},
	"histogram": {
		Description: "Returns a LIST of STRUCTs with the fields bucket and count.",
		Signatures: []string{
			"histogram(arg ANY, col1 ANY[]) -> MAP",
			"histogram(source, col_name, technique, bin_count) -> ",
		},
		ReturnType: "MAP",
	},
	"histogram_exact": {
		Description: "Returns a LIST of STRUCTs with the fields bucket and count matching the buckets exactly.",
		Signatures: []string{
			"histogram_exact(arg ANY, bins ANY[]) -> MAP",
		},
		ReturnType: "MAP",
	},
	"histogram_values": {
		Signatures: []string{
			"histogram_values(source, col_name, technique, bin_count) -> ",
		},
	},
	"hour": {
		Description: "Extract the hour component from a date or timestamp",
		Signatures: []string{
			"hour(ts TIME) -> BIGINT",
		},
		ReturnType: "BIGINT",
	},
	"ilike_escape": {
		Signatures: []string{
			"ilike_escape(col0 VARCHAR, col1 VARCHAR, col2 VARCHAR) -> BOOLEAN",
		},
		ReturnType: "BOOLEAN",
	},
	"import_database": {
		Signatures: []string{
			"import_database(col0 VARCHAR) -> ",
		},
	},
	"in_search_path": {
		Description: "Returns whether or not the database/schema are in the search path",
		Signatures: []string{
			"in_search_path(database_name VARCHAR, schema_name VARCHAR) -> BOOLEAN",
		},
		ReturnType: "BOOLEAN",
	},
	"index_scan": {
		Signatures: []string{
			"index_scan() -> ",
		},
	},
	"instr": {
		Description: "Returns location of first occurrence of needle in haystack, counting from 1. Returns 0 if no match found",
		Signatures: []string{
			"instr(haystack VARCHAR, needle VARCHAR) -> BIGINT",
		},
		ReturnType: "BIGINT",
	},
	"is_histogram_other_bin": {
		Description: "Whether or not the provided value is the histogram \\\"other\\\" bin (used for values not belonging to any provided bin)",
		Signatures: []string{
			"is_histogram_other_bin(val ANY) -> BOOLEAN",
		},
		ReturnType: "BOOLEAN",
	},
	"isfinite": {
		Description: "Returns true if the floating point value is finite, false otherwise",
		Signatures: []string{
			"isfinite(x DOUBLE) -> BOOLEAN",
		},
		ReturnType: "BOOLEAN",
	},
	"isinf": {
		Description: "Returns true if the floating point value is infinite, false otherwise",
		Signatures: []string{
			"isinf(x FLOAT) -> BOOLEAN",
		},
		ReturnType: "BOOLEAN",
	},
	"isnan": {
		Description: "Returns true if the floating point value is not a number, false otherwise",
		Signatures: []string{
			"isnan(x FLOAT) -> BOOLEAN",
		},
		ReturnType: "BOOLEAN",
	},
	"isodow": {
		Description: "Extract the isodow component from a date or timestamp",
		Signatures: []string{
			"isodow(ts TIMESTAMP) -> BIGINT",
		},
		ReturnType: "BIGINT",
	},
	"isoyear": {
		Description: "Extract the isoyear component from a date or timestamp",
		Signatures: []string{
			"isoyear(ts DATE) -> BIGINT",
		},
		ReturnType: "BIGINT",
	},
	"jaccard": {
		Description: "The Jaccard similarity between two strings. Different case is considered different. Returns a number between 0 and 1",
		Signatures: []string{
			"jaccard(str1 VARCHAR, str2 VARCHAR) -> DOUBLE",
		},
		ReturnType: "DOUBLE",
	},
	"jaro_similarity": {
		Description: "The Jaro similarity between two strings. Different case is considered different. Returns a number between 0 and 1",
		Signatures: []string{
			"jaro_similarity(str1 VARCHAR, str2 VARCHAR) -> DOUBLE",
		},
		ReturnType: "DOUBLE",
	},
	"jaro_winkler_similarity": {
		Description: "The Jaro-Winkler similarity between two strings. Different case is considered different. Returns a number between 0 and 1",
		Signatures: []string{
			"jaro_winkler_similarity(str1 VARCHAR, str2 VARCHAR) -> DOUBLE",
		},
		ReturnType: "DOUBLE",
	},
	"json": {
		Signatures: []string{
			"json(x) -> ",
		},
	},
	"json_array": {
		Signatures: []string{
			"json_array() -> JSON",
		},
		ReturnType: "JSON",
	},
	"json_array_length": {
		Signatures: []string{
			"json_array_length(col0 VARCHAR, col1 VARCHAR[]) -> UBIGINT[]",
		},
		ReturnType: "UBIGINT[]",
	},
	"json_contains": {
		Signatures: []string{
			"json_contains(col0 JSON, col1 JSON) -> BOOLEAN",
		},
		ReturnType: "BOOLEAN",
	},
	"json_deserialize_sql": {
		Signatures: []string{
			"json_deserialize_sql(col0 JSON) -> VARCHAR",
		},
		ReturnType: "VARCHAR",
	},
	"json_execute_serialized_sql": {
		Signatures: []string{
			"json_execute_serialized_sql(col0 VARCHAR) -> ",
		},
	},
	"json_exists": {
		Signatures: []string{
			"json_exists(col0 JSON, col1 VARCHAR[]) -> BOOLEAN[]",
		},
		ReturnType: "BOOLEAN[]",
	},
	"json_extract": {
		Signatures: []string{
			"json_extract(col0 VARCHAR, col1 VARCHAR[]) -> JSON[]",
		},
		ReturnType: "JSON[]",
	},
	"json_extract_path": {
		Signatures: []string{
			"json_extract_path(col0 JSON, col1 BIGINT) -> JSON",
		},
		ReturnType: "JSON",
	},
	"json_extract_path_text": {
		Signatures: []string{
			"json_extract_path_text(col0 VARCHAR, col1 VARCHAR[]) -> VARCHAR[]",
		},
		ReturnType: "VARCHAR[]",
	},
	"json_extract_string": {
		Signatures: []string{
			"json_extract_string(col0 VARCHAR, col1 VARCHAR[]) -> VARCHAR[]",
		},
		ReturnType: "VARCHAR[]",
	},
	"json_group_array": {
		Signatures: []string{
			"json_group_array(x) -> ",
		},
	},
	"json_group_object": {
		Signatures: []string{
			"json_group_object(name, value) -> ",
		},
	},
	"json_group_structure": {
		Signatures: []string{
			"json_group_structure(x) -> ",
		},
	},
	"json_keys": {
		Signatures: []string{
			"json_keys(col0 JSON, col1 VARCHAR[]) -> VARCHAR[][]",
		},
		ReturnType: "VARCHAR[][]",
	},
	"json_merge_patch": {
		Signatures: []string{
			"json_merge_patch() -> JSON",
		},
		ReturnType: "JSON",
	},
	"json_object": {
		Signatures: []string{
			"json_object() -> JSON",
		},
		ReturnType: "JSON",
	},
	"json_pretty": {
		Signatures: []string{
			"json_pretty(col0 JSON) -> VARCHAR",
		},
		ReturnType: "VARCHAR",
	},
	"json_quote": {
		Signatures: []string{
			"json_quote() -> JSON",
		},
		ReturnType: "JSON",
	},
	"json_serialize_plan": {
		Signatures: []string{
			"json_serialize_plan(col0 VARCHAR) -> JSON",
		},
		ReturnType: "JSON",
	},
	"json_serialize_sql": {
		Signatures: []string{
			"json_serialize_sql(col0 VARCHAR) -> JSON",
		},
		ReturnType: "JSON",
	},
	"json_structure": {
		Signatures: []string{
			"json_structure(col0 VARCHAR) -> JSON",
		},
		ReturnType: "JSON",
	},
	"json_transform": {
		Signatures: []string{
			"json_transform(col0 VARCHAR, col1 VARCHAR) -> ANY",
		},
		ReturnType: "ANY",
	},
	"json_transform_strict": {
		Signatures: []string{
			"json_transform_strict(col0 VARCHAR, col1 VARCHAR) -> ANY",
		},
		ReturnType: "ANY",
	},
	"json_type": {
		Signatures: []string{
			"json_type(col0 JSON, col1 VARCHAR) -> VARCHAR",
		},
		ReturnType: "VARCHAR",
	},
	"json_valid": {
		Signatures: []string{
			"json_valid(col0 VARCHAR) -> BOOLEAN",
		},
		ReturnType: "BOOLEAN",
	},
	"json_value": {
		Signatures: []string{
			"json_value(col0 VARCHAR, col1 BIGINT) -> VARCHAR",
		},
		ReturnType: "VARCHAR",
	},
	"julian": {
		Description: "Extract the Julian Day number from a date or timestamp",
		Signatures: []string{
			"julian(ts DATE) -> DOUBLE",
		},
		ReturnType: "DOUBLE",
	},
	"kahan_sum": {
		Description: "Calculates the sum using a more accurate floating point summation (Kahan Sum).",
		Signatures: []string{
			"kahan_sum(arg DOUBLE) -> DOUBLE",
		},
		ReturnType: "DOUBLE",
	},
	"kurtosis": {
		Description: "Returns the excess kurtosis (Fisher’s definition) of all input values, with a bias correction according to the sample size",
		Signatures: []string{
			"kurtosis(x DOUBLE) -> DOUBLE",
		},
		ReturnType: "DOUBLE",
	},
	"kurtosis_pop": {
		Description: "Returns the excess kurtosis (Fisher’s definition) of all input values, without bias correction",
		Signatures: []string{
			"kurtosis_pop(x DOUBLE) -> DOUBLE",
		},
		ReturnType: "DOUBLE",
	},
	"last": {
		Signatures: []string{
			"last(col0 ANY) -> ANY",
		},
		ReturnType: "ANY",
	},
	"last_day": {
		Description: "Returns the last day of the month",
		Signatures: []string{
			"last_day(ts DATE) -> DATE",
		},
		ReturnType: "DATE",
	},
	"lcase": {
		Signatures: []string{
			"lcase(col0 VARCHAR) -> VARCHAR",
		},
		ReturnType: "VARCHAR",
	},
	"lcm": {
		Description: "Computes the least common multiple of x and y",
		Signatures: []string{
			"lcm(x HUGEINT, y HUGEINT) -> HUGEINT",
		},
		ReturnType: "HUGEINT",
	},
	"least": {
		Description: "Returns the lowest value of the set of input parameters",
		Signatures: []string{
			"least(arg1 ANY) -> ANY",
		},
		ReturnType: "ANY",
	},
	"least_common_multiple": {
		Description: "Computes the least common multiple of x and y",
		Signatures: []string{
			"least_common_multiple(x HUGEINT, y HUGEINT) -> HUGEINT",
		},
		ReturnType: "HUGEINT",
	},
	"left": {
		Description: "Extract the left-most count characters",
		Signatures: []string{
			"left(string VARCHAR, count BIGINT) -> VARCHAR",
		},
		ReturnType: "VARCHAR",
	},
	"left_grapheme": {
		Description: "Extract the left-most count grapheme clusters",
		Signatures: []string{
			"left_grapheme(string VARCHAR, count BIGINT) -> VARCHAR",
		},
		ReturnType: "VARCHAR",
	},
	"len": {
		Signatures: []string{
			"len(col0 VARCHAR) -> BIGINT",
		},
		ReturnType: "BIGINT",
	},
	"length": {
		Signatures: []string{
			"length(col0 VARCHAR) -> BIGINT",
		},
		ReturnType: "BIGINT",
	},
	"length_grapheme": {
		Signatures: []string{
			"length_grapheme(col0 VARCHAR) -> BIGINT",
		},
		ReturnType: "BIGINT",
	},
	"levenshtein": {
		Description: "The minimum number of single-character edits (insertions, deletions or substitutions) required to change one string to the other. Different case is considered different",
		Signatures: []string{
			"levenshtein(str1 VARCHAR, str2 VARCHAR) -> BIGINT",
		},
		ReturnType: "BIGINT",
	},
	"lgamma": {
		Description: "Computes the log of the gamma function",
		Signatures: []string{
			"lgamma(x DOUBLE) -> DOUBLE",
		},
		ReturnType: "DOUBLE",
	},
	"like_escape": {
		Signatures: []string{
			"like_escape(col0 VARCHAR, col1 VARCHAR, col2 VARCHAR) -> BOOLEAN",
		},
		ReturnType: "BOOLEAN",
	},
	"list": {
		Description: "Returns a LIST containing all the values of a column.",
		Signatures: []string{
			"list(arg ANY) -> LIST",
		},
		ReturnType: "LIST",
	},
	"list_aggr": {
		Description: "Executes the aggregate function name on the elements of list",
		Signatures: []string{
			"list_aggr(list ANY[], name VARCHAR) -> ANY",
		},
		ReturnType: "ANY",
	},
	"list_aggregate": {
		Description: "Executes the aggregate function name on the elements of list",
		Signatures: []string{
			"list_aggregate(list ANY[], name VARCHAR) -> ANY",
		},
		ReturnType: "ANY",
	},
	"list_any_value": {
		Signatures: []string{
			"list_any_value(l) -> ",
		},
	},
	"list_append": {
		Signatures: []string{
			"list_append(l, e) -> ",
		},
	},
	"list_apply": {
		Description: "Returns a list that is the result of applying the lambda function to each element of the input list. See the Lambda Functions section for more details",
		Signatures: []string{
			"list_apply(list ANY[], lambda LAMBDA) -> ANY[]",
		},
		ReturnType: "ANY[]",
	},
	"list_approx_count_distinct": {
		Signatures: []string{
			"list_approx_count_distinct(l) -> ",
		},
	},
	"list_avg": {
		Signatures: []string{
			"list_avg(l) -> ",
		},
	},
	"list_bit_and": {
		Signatures: []string{
			"list_bit_and(l) -> ",
		},
	},
	"list_bit_or": {
		Signatures: []string{
			"list_bit_or(l) -> ",
		},
	},
	"list_bit_xor": {
		Signatures: []string{
			"list_bit_xor(l) -> ",
		},
	},
	"list_bool_and": {
		Signatures: []string{
			"list_bool_and(l) -> ",
		},
	},
	"list_bool_or": {
		Signatures: []string{
			"list_bool_or(l) -> ",
		},
	},
	"list_cat": {
		Signatures: []string{
			"list_cat(col0 ANY[], col1 ANY[]) -> ANY[]",
		},
		ReturnType: "ANY[]",
	},
	"list_concat": {
		Signatures: []string{
			"list_concat(col0 ANY[], col1 ANY[]) -> ANY[]",
		},
		ReturnType: "ANY[]",
	},
	"list_contains": {
		Signatures: []string{
			"list_contains(col0 ANY[], col1 ANY) -> BOOLEAN",
		},
		ReturnType: "BOOLEAN",
	},
	"list_cosine_distance": {
		Description: "Compute the cosine distance between two lists",
		Signatures: []string{
			"list_cosine_distance(list1 FLOAT[], list2 FLOAT[]) -> FLOAT",
		},
		ReturnType: "FLOAT",
	},
	"list_cosine_similarity": {
		Description: "Compute the cosine similarity between two lists",
		Signatures: []string{
			"list_cosine_similarity(list1 FLOAT[], list2 FLOAT[]) -> FLOAT",
		},
		ReturnType: "FLOAT",
	},
	"list_count": {
		Signatures: []string{
			"list_count(l) -> ",
		},
	},
	"list_distance": {
		Description: "Compute the distance between two lists",
		Signatures: []string{
			"list_distance(list1 FLOAT[], list2 FLOAT[]) -> FLOAT",
		},
		ReturnType: "FLOAT",
	},
	"list_distinct": {
		Description: "Removes all duplicates and NULLs from a list. Does not preserve the original order",
		Signatures: []string{
			"list_distinct(list ANY[]) -> ANY[]",
		},
		ReturnType: "ANY[]",
	},
	"list_dot_product": {
		Description: "Compute the inner product between two lists",
		Signatures: []string{
			"list_dot_product(list1 FLOAT[], list2 FLOAT[]) -> FLOAT",
		},
		ReturnType: "FLOAT",
	},
	"list_element": {
		Signatures: []string{
			"list_element(col0 ANY[], col1 BIGINT) -> ANY",
		},
		ReturnType: "ANY",
	},
	"list_entropy": {
		Signatures: []string{
			"list_entropy(l) -> ",
		},
	},
	"list_extract": {
		Signatures: []string{
			"list_extract(col0 ANY[], col1 BIGINT) -> ANY",
		},
		ReturnType: "ANY",
	},
	"list_filter": {
		Description: "Constructs a list from those elements of the input list for which the lambda function returns true",
		Signatures: []string{
			"list_filter(list ANY[], lambda LAMBDA) -> ANY[]",
		},
		ReturnType: "ANY[]",
	},
	"list_first": {
		Signatures: []string{
			"list_first(l) -> ",
		},
	},
	"list_grade_up": {
		Description: "Returns the index of their sorted position.",
		Signatures: []string{
			"list_grade_up(list ANY[]) -> ANY[]",
		},
		ReturnType: "ANY[]",
	},
	"list_has": {
		Signatures: []string{
			"list_has(col0 ANY[], col1 ANY) -> BOOLEAN",
		},
		ReturnType: "BOOLEAN",
	},
	"list_has_all": {
		Description: "Returns true if all elements of l2 are in l1. NULLs are ignored.",
		Signatures: []string{
			"list_has_all(l1 ANY[], l2 ANY[]) -> BOOLEAN",
		},
		ReturnType: "BOOLEAN",
	},
	"list_has_any": {
		Description: "Returns true if the lists have any element in common. NULLs are ignored.",
		Signatures: []string{
			"list_has_any(l1 ANY[], l2 ANY[]) -> BOOLEAN",
		},
		ReturnType: "BOOLEAN",
	},
	"list_histogram": {
		Signatures: []string{
			"list_histogram(l) -> ",
		},
	},
	"list_indexof": {
		Signatures: []string{
			"list_indexof(col0 ANY[], col1 ANY) -> INTEGER",
		},
		ReturnType: "INTEGER",
	},
	"list_inner_product": {
		Description: "Compute the inner product between two lists",
		Signatures: []string{
			"list_inner_product(list1 FLOAT[], list2 FLOAT[]) -> FLOAT",
		},
		ReturnType: "FLOAT",
	},
	"list_intersect": {
		Signatures: []string{
			"list_intersect(l1, l2) -> ",
		},
	},
	"list_kurtosis": {
		Signatures: []string{
			"list_kurtosis(l) -> ",
		},
	},
	"list_kurtosis_pop": {
		Signatures: []string{
			"list_kurtosis_pop(l) -> ",
		},
	},
	"list_last": {
		Signatures: []string{
			"list_last(l) -> ",
		},
	},
	"list_mad": {
		Signatures: []string{
			"list_mad(l) -> ",
		},
	},
	"list_max": {
		Signatures: []string{
			"list_max(l) -> ",
		},
	},
	"list_median": {
		Signatures: []string{
			"list_median(l) -> ",
		},
	},
	"list_min": {
		Signatures: []string{
			"list_min(l) -> ",
		},
	},
	"list_mode": {
		Signatures: []string{
			"list_mode(l) -> ",
		},
	},
	"list_negative_dot_product": {
		Description: "Compute the negative inner product between two lists",
		Signatures: []string{
			"list_negative_dot_product(list1 DOUBLE[], list2 DOUBLE[]) -> DOUBLE",
		},
		ReturnType: "DOUBLE",
	},
	"list_negative_inner_product": {
		Description: "Compute the negative inner product between two lists",
		Signatures: []string{
			"list_negative_inner_product(list1 DOUBLE[], list2 DOUBLE[]) -> DOUBLE",
		},
		ReturnType: "DOUBLE",
	},
	"list_pack": {
		Description: "Create a LIST containing the argument values",
		Signatures: []string{
			"list_pack() -> LIST",
		},
		ReturnType: "LIST",
	},
	"list_position": {
		Signatures: []string{
			"list_position(col0 ANY[], col1 ANY) -> INTEGER",
		},
		ReturnType: "INTEGER",
	},
	"list_prepend": {
		Signatures: []string{
			"list_prepend(e, l) -> ",
		},
	},
	"list_product": {
		Signatures: []string{
			"list_product(l) -> ",
		},
	},
	"list_reduce": {
		Description: "Returns a single value that is the result of applying the lambda function to each element of the input list, starting with the first element and then repeatedly applying the lambda function to the result of the previous application and the next element of the list.",
		Signatures: []string{
			"list_reduce(list ANY[], lambda LAMBDA) -> ANY",
		},
		ReturnType: "ANY",
	},
	"list_resize": {
		Signatures: []string{
			"list_resize(col0 ANY[], col1 ANY, col2 ANY) -> ANY[]",
		},
		ReturnType: "ANY[]",
	},
	"list_reverse": {
		Signatures: []string{
			"list_reverse(l) -> ",
		},
	},
	"list_reverse_sort": {
		Description: "Sorts the elements of the list in reverse order",
		Signatures: []string{
			"list_reverse_sort(list ANY[], col1 VARCHAR) -> ANY[]",
		},
		ReturnType: "ANY[]",
	},
	"list_select": {
		Signatures: []string{
			"list_select(col0 ANY[], col1 BIGINT[]) -> ANY[]",
		},
		ReturnType: "ANY[]",
	},
	"list_sem": {
		Signatures: []string{
			"list_sem(l) -> ",
		},
	},
	"list_skewness": {
		Signatures: []string{
			"list_skewness(l) -> ",
		},
	},
	"list_slice": {
		Description: "Extract a sublist using slice conventions. Negative values are accepted",
		Signatures: []string{
			"list_slice(list ANY, begin ANY, end[ ANY, step] BIGINT) -> ANY",
		},
		ReturnType: "ANY",
	},
	"list_sort": {
		Description: "Sorts the elements of the list",
		Signatures: []string{
			"list_sort(list ANY[], col1 VARCHAR, col2 VARCHAR) -> ANY[]",
		},
		ReturnType: "ANY[]",
	},
	"list_stddev_pop": {
		Signatures: []string{
			"list_stddev_pop(l) -> ",
		},
	},
	"list_stddev_samp": {
		Signatures: []string{
			"list_stddev_samp(l) -> ",
		},
	},
	"list_string_agg": {
		Signatures: []string{
			"list_string_agg(l) -> ",
		},
	},
	"list_sum": {
		Signatures: []string{
			"list_sum(l) -> ",
		},
	},
	"list_transform": {
		Description: "Returns a list that is the result of applying the lambda function to each element of the input list. See the Lambda Functions section for more details",
		Signatures: []string{
			"list_transform(list ANY[], lambda LAMBDA) -> ANY[]",
		},
		ReturnType: "ANY[]",
	},
	"list_unique": {
		Description: "Counts the unique elements of a list",
		Signatures: []string{
			"list_unique(list ANY[]) -> UBIGINT",
		},
		ReturnType: "UBIGINT",
	},
	"list_value": {
		Description: "Create a LIST containing the argument values",
		Signatures: []string{
			"list_value() -> LIST",
		},
		ReturnType: "LIST",
	},
	"list_var_pop": {
		Signatures: []string{
			"list_var_pop(l) -> ",
		},
	},
	"list_var_samp": {
		Signatures: []string{
			"list_var_samp(l) -> ",
		},
	},
	"list_where": {
		Signatures: []string{
			"list_where(col0 ANY[], col1 BOOLEAN[]) -> ANY[]",
		},
		ReturnType: "ANY[]",
	},
	"list_zip": {
		Signatures: []string{
			"list_zip() -> STRUCT[]",
		},
		ReturnType: "STRUCT[]",
	},
	"listagg": {
		Description: "Concatenates the column string values with an optional separator.",
		Signatures: []string{
			"listagg(str ANY) -> VARCHAR",
		},
		ReturnType: "VARCHAR",
	},
	"ln": {
		Description: "Computes the natural logarithm of x",
		Signatures: []string{
			"ln(x DOUBLE) -> DOUBLE",
		},
		ReturnType: "DOUBLE",
	},
	"log": {
		Description: "Computes the logarithm of x to base b. b may be omitted, in which case the default 10",
		Signatures: []string{
			"log(b DOUBLE, x DOUBLE) -> DOUBLE",
		},
		ReturnType: "DOUBLE",
	},
	"log10": {
		Description: "Computes the 10-log of x",
		Signatures: []string{
			"log10(x DOUBLE) -> DOUBLE",
		},
		ReturnType: "DOUBLE",
	},
	"log2": {
		Description: "Computes the 2-log of x",
		Signatures: []string{
			"log2(x DOUBLE) -> DOUBLE",
		},
		ReturnType: "DOUBLE",
	},
	"lower": {
		Signatures: []string{
			"lower(col0 VARCHAR) -> VARCHAR",
		},
		ReturnType: "VARCHAR",
	},
	"lpad": {
		Description: "Pads the string with the character from the left until it has count characters",
		Signatures: []string{
			"lpad(string VARCHAR, count INTEGER, character VARCHAR) -> VARCHAR",
		},
		ReturnType: "VARCHAR",
	},
	"ltrim": {
		Description: "Removes any occurrences of any of the characters from the left side of the string",
		Signatures: []string{
			"ltrim(string VARCHAR) -> VARCHAR",
		},
		ReturnType: "VARCHAR",
	},
	"mad": {
		Description: "Returns the median absolute deviation for the values within x. NULL values are ignored. Temporal types return a positive INTERVAL.\\t",
		Signatures: []string{
			"mad(x DECIMAL) -> DECIMAL",
		},
		ReturnType: "DECIMAL",
	},
	"make_date": {
		Description: "The date for the given parts",
		Signatures: []string{
			"make_date(year BIGINT, month BIGINT, day BIGINT) -> DATE",
		},
		ReturnType: "DATE",
	},
	"make_time": {
		Description: "The time for the given parts",
		Signatures: []string{
			"make_time(hour BIGINT, minute BIGINT, seconds DOUBLE) -> TIME",
		},
		ReturnType: "TIME",
	},
	"make_timestamp": {
		Description: "The timestamp for the given parts",
		Signatures: []string{
			"make_timestamp(year BIGINT, month BIGINT, day BIGINT, hour BIGINT, minute BIGINT, seconds DOUBLE) -> TIMESTAMP",
		},
		ReturnType: "TIMESTAMP",
	},
	"map": {
		Description: "Creates a map from a set of keys and values",
		Signatures: []string{
			"map() -> MAP",
		},
		ReturnType: "MAP",
	},
	"map_concat": {
		Description: "Returns a map created from merging the input maps, on key collision the value is taken from the last map with that key",
		Signatures: []string{
			"map_concat() -> LIST",
		},
		ReturnType: "LIST",
	},
	"map_contains": {
		Description: "Returns true if the map contains the key, false otherwise",
		Signatures: []string{
			"map_contains(map MAP(ANY, key ANY)) -> BOOLEAN",
		},
		ReturnType: "BOOLEAN",
	},
	"map_contains_entry": {
		Signatures: []string{
			"map_contains_entry(map, key, value) -> ",
		},
	},
	"map_contains_value": {
		Signatures: []string{
			"map_contains_value(map, value) -> ",
		},
	},
	"map_entries": {
		Description: "Returns the map entries as a list of keys/values",
		Signatures: []string{
			"map_entries() -> LIST",
		},
		ReturnType: "LIST",
	},
	"map_extract": {
		Description: "Returns a list containing the value for a given key or an empty list if the key is not contained in the map. The type of the key provided in the second parameter must match the type of the map’s keys else an error is returned",
		Signatures: []string{
			"map_extract(map ANY, key ANY) -> ANY",
		},
		ReturnType: "ANY",
	},
	"map_from_entries": {
		Description: "Returns a map created from the entries of the array",
		Signatures: []string{
			"map_from_entries() -> MAP",
		},
		ReturnType: "MAP",
	},
	"map_keys": {
		Description: "Returns the keys of a map as a list",
		Signatures: []string{
			"map_keys() -> LIST",
		},
		ReturnType: "LIST",
	},
	"map_values": {
		Description: "Returns the values of a map as a list",
		Signatures: []string{
			"map_values() -> LIST",
		},
		ReturnType: "LIST",
	},
	"max": {
		Description: "Returns the maximum value present in arg.",
		Signatures: []string{
			"max(arg ANY, col1 BIGINT) -> ANY[]",
		},
		ReturnType: "ANY[]",
	},
	"max_by": {
		Description: "Finds the row with the maximum val. Calculates the non-NULL arg expression at that row.",
		Signatures: []string{
			"max_by(arg ANY, val BLOB) -> ANY",
		},
		ReturnType: "ANY",
	},
	"md5": {
		Description: "Returns the MD5 hash of the value as a string",
		Signatures: []string{
			"md5(value VARCHAR) -> VARCHAR",
		},
		ReturnType: "VARCHAR",
	},
	"md5_number": {
		Description: "Returns the MD5 hash of the value as an INT128",
		Signatures: []string{
			"md5_number(value VARCHAR) -> HUGEINT",
		},
		ReturnType: "HUGEINT",
	},
	"md5_number_lower": {
		Signatures: []string{
			"md5_number_lower(param) -> ",
		},
	},
	"md5_number_upper": {
		Signatures: []string{
			"md5_number_upper(param) -> ",
		},
	},
	"mean": {
		Description: "Calculates the average value for all tuples in x.",
		Signatures: []string{
			"mean(x DOUBLE) -> DOUBLE",
		},
		ReturnType: "DOUBLE",
	},
	"median": {
		Description: "Returns the middle value of the set. NULL values are ignored. For even value counts, quantitative values are averaged and ordinal values return the lower value.",
		Signatures: []string{
			"median(x ANY) -> ANY",
		},
		ReturnType: "ANY",
	},
	"metadata_info": {
		Signatures: []string{
			"metadata_info() -> ",
		},
	},
	"microsecond": {
		Description: "Extract the microsecond component from a date or timestamp",
		Signatures: []string{
			"microsecond(ts TIME WITH TIME ZONE) -> BIGINT",
		},
		ReturnType: "BIGINT",
	},
	"millennium": {
		Description: "Extract the millennium component from a date or timestamp",
		Signatures: []string{
			"millennium(ts TIMESTAMP) -> BIGINT",
		},
		ReturnType: "BIGINT",
	},
	"millisecond": {
		Description: "Extract the millisecond component from a date or timestamp",
		Signatures: []string{
			"millisecond(ts TIME) -> BIGINT",
		},
		ReturnType: "BIGINT",
	},
	"min": {
		Description: "Returns the minimum value present in arg.",
		Signatures: []string{
			"min(arg ANY, col1 BIGINT) -> ANY[]",
		},
		ReturnType: "ANY[]",
	},
	"min_by": {
		Description: "Finds the row with the minimum val. Calculates the non-NULL arg expression at that row.",
		Signatures: []string{
			"min_by(arg ANY, val DATE) -> ANY",
		},
		ReturnType: "ANY",
	},
	"minute": {
		Description: "Extract the minute component from a date or timestamp",
		Signatures: []string{
			"minute(ts INTERVAL) -> BIGINT",
		},
		ReturnType: "BIGINT",
	},
	"mismatches": {
		Description: "The number of positions with different characters for 2 strings of equal length. Different case is considered different",
		Signatures: []string{
			"mismatches(str1 VARCHAR, str2 VARCHAR) -> BIGINT",
		},
		ReturnType: "BIGINT",
	},
	"mod": {
		Signatures: []string{
			"mod(col0 TINYINT, col1 TINYINT) -> TINYINT",
		},
		ReturnType: "TINYINT",
	},
	"mode": {
		Description: "Returns the most frequent value for the values within x. NULL values are ignored.",
		Signatures: []string{
			"mode(x ANY) -> ANY",
		},
		ReturnType: "ANY",
	},
	"month": {
		Description: "Extract the month component from a date or timestamp",
		Signatures: []string{
			"month(ts INTERVAL) -> BIGINT",
		},
		ReturnType: "BIGINT",
	},
	"monthname": {
		Description: "The (English) name of the month",
		Signatures: []string{
			"monthname(ts DATE) -> VARCHAR",
		},
		ReturnType: "VARCHAR",
	},
	"multiply": {
		Signatures: []string{
			"multiply(col0 BIGINT, col1 BIGINT) -> BIGINT",
		},
		ReturnType: "BIGINT",
	},
	"nanosecond": {
		Description: "Extract the nanosecond component from a date or timestamp",
		Signatures: []string{
			"nanosecond(tsns TIMESTAMP WITH TIME ZONE) -> BIGINT",
		},
		ReturnType: "BIGINT",
	},
	"nextafter": {
		Description: "Returns the next floating point value after x in the direction of y",
		Signatures: []string{
			"nextafter(x DOUBLE, y DOUBLE) -> DOUBLE",
		},
		ReturnType: "DOUBLE",
	},
	"nextval": {
		Signatures: []string{
			"nextval(col0 VARCHAR) -> BIGINT",
		},
		ReturnType: "BIGINT",
	},
	"nfc_normalize": {
		Signatures: []string{
			"nfc_normalize(col0 VARCHAR) -> VARCHAR",
		},
		ReturnType: "VARCHAR",
	},
	"not_ilike_escape": {
		Signatures: []string{
			"not_ilike_escape(col0 VARCHAR, col1 VARCHAR, col2 VARCHAR) -> BOOLEAN",
		},
		ReturnType: "BOOLEAN",
	},
	"not_like_escape": {
		Signatures: []string{
			"not_like_escape(col0 VARCHAR, col1 VARCHAR, col2 VARCHAR) -> BOOLEAN",
		},
		ReturnType: "BOOLEAN",
	},
	"now": {
		Description: "Returns the current timestamp",
		Signatures: []string{
			"now() -> TIMESTAMP WITH TIME ZONE",
		},
		ReturnType: "TIMESTAMP WITH TIME ZONE",
	},
	"nullif": {
		Signatures: []string{
			"nullif(a, b) -> ",
		},
	},
	"octet_length": {
		Signatures: []string{
			"octet_length(col0 BIT) -> BIGINT",
		},
		ReturnType: "BIGINT",
	},
	"ord": {
		Description: "Returns the unicode codepoint of the first character of the string",
		Signatures: []string{
			"ord(str VARCHAR) -> INTEGER",
		},
		ReturnType: "INTEGER",
	},
	"parquet_file_metadata": {
		Signatures: []string{
			"parquet_file_metadata(col0 VARCHAR) -> ",
		},
	},
	"parquet_kv_metadata": {
		Signatures: []string{
			"parquet_kv_metadata(col0 VARCHAR[]) -> ",
		},
	},
	"parquet_metadata": {
		Signatures: []string{
			"parquet_metadata(col0 VARCHAR[]) -> ",
		},
	},
	"parquet_scan": {
		Signatures: []string{
			"parquet_scan(col0 VARCHAR[], schema MAP(INTEGER, file_row_number STRUCT(\"NAME\" VARCHAR, debug_use_openssl \"TYPE\" VARCHAR, union_by_name DEFAULT_VALUE VARCHAR)), explicit_cardinality BOOLEAN, compression BOOLEAN, encryption_config BOOLEAN, hive_partitioning UBIGINT, hive_types VARCHAR, filename ANY, binary_as_string BOOLEAN, hive_types_autocast ANY) -> ",
		},
	},
	"parquet_schema": {
		Signatures: []string{
			"parquet_schema(col0 VARCHAR[]) -> ",
		},
	},
	"parse_dirname": {
		Description: "Returns the top-level directory name. separator options: system, both_slash (default), forward_slash, backslash",
		Signatures: []string{
			"parse_dirname(string VARCHAR) -> VARCHAR",
		},
		ReturnType: "VARCHAR",
	},
	"parse_dirpath": {
		Description: "Returns the head of the path similarly to Python's os.path.dirname. separator options: system, both_slash (default), forward_slash, backslash",
		Signatures: []string{
			"parse_dirpath(string VARCHAR) -> VARCHAR",
		},
		ReturnType: "VARCHAR",
	},
	"parse_filename": {
		Description: "Returns the last component of the path similarly to Python's os.path.basename. If trim_extension is true, the file extension will be removed (it defaults to false). separator options: system, both_slash (default), forward_slash, backslash",
		Signatures: []string{
			"parse_filename(string VARCHAR, trim_extension BOOLEAN, separator VARCHAR) -> VARCHAR",
		},
		ReturnType: "VARCHAR",
	},
	"parse_path": {
		Description: "Returns a list of the components (directories and filename) in the path similarly to Python's pathlib.PurePath::parts. separator options: system, both_slash (default), forward_slash, backslash",
		Signatures: []string{
			"parse_path(string VARCHAR, separator VARCHAR) -> VARCHAR[]",
		},
		ReturnType: "VARCHAR[]",
	},
	"pi": {
		Description: "Returns the value of pi",
		Signatures: []string{
			"pi() -> DOUBLE",
		},
		ReturnType: "DOUBLE",
	},
	"platform": {
		Signatures: []string{
			"platform() -> ",
		},
	},
	"position": {
		Description: "Returns location of first occurrence of needle in haystack, counting from 1. Returns 0 if no match found",
		Signatures: []string{
			"position(haystack VARCHAR, needle VARCHAR) -> BIGINT",
		},
		ReturnType: "BIGINT",
	},
	"pow": {
		Description: "Computes x to the power of y",
		Signatures: []string{
			"pow(x DOUBLE, y DOUBLE) -> DOUBLE",
		},
		ReturnType: "DOUBLE",
	},
	"power": {
		Description: "Computes x to the power of y",
		Signatures: []string{
			"power(x DOUBLE, y DOUBLE) -> DOUBLE",
		},
		ReturnType: "DOUBLE",
	},
	"pragma_collations": {
		Signatures: []string{
			"pragma_collations() -> ",
		},
	},
	"pragma_database_size": {
		Signatures: []string{
			"pragma_database_size() -> ",
		},
	},
	"pragma_metadata_info": {
		Signatures: []string{
			"pragma_metadata_info(col0 VARCHAR) -> ",
		},
	},
	"pragma_platform": {
		Signatures: []string{
			"pragma_platform() -> ",
		},
	},
	"pragma_show": {
		Signatures: []string{
			"pragma_show(col0 VARCHAR) -> ",
		},
	},
	"pragma_storage_info": {
		Signatures: []string{
			"pragma_storage_info(col0 VARCHAR) -> ",
		},
	},
	"pragma_table_info": {
		Signatures: []string{
			"pragma_table_info(col0 VARCHAR) -> ",
		},
	},
	"pragma_user_agent": {
		Signatures: []string{
			"pragma_user_agent() -> ",
		},
	},
	"pragma_version": {
		Signatures: []string{
			"pragma_version() -> ",
		},
	},
	"prefix": {
		Signatures: []string{
			"prefix(col0 VARCHAR, col1 VARCHAR) -> BOOLEAN",
		},
		ReturnType: "BOOLEAN",
	},
	"printf": {
		Description: "Formats a string using printf syntax",
		Signatures: []string{
			"printf(format VARCHAR) -> VARCHAR",
		},
		ReturnType: "VARCHAR",
	},
	"product": {
		Description: "Calculates the product of all tuples in arg.",
		Signatures: []string{
			"product(arg DOUBLE) -> DOUBLE",
		},
		ReturnType: "DOUBLE",
	},
	"quantile": {
		Description: "Returns the exact quantile number between 0 and 1 . If pos is a LIST of FLOATs, then the result is a LIST of the corresponding exact quantiles.",
		Signatures: []string{
			"quantile(x ANY) -> ANY",
		},
		ReturnType: "ANY",
	},
	"quantile_cont": {
		Description: "Returns the interpolated quantile number between 0 and 1 . If pos is a LIST of FLOATs, then the result is a LIST of the corresponding interpolated quantiles.\\t",
		Signatures: []string{
			"quantile_cont(x DECIMAL, pos DOUBLE[]) -> DECIMAL",
		},
		ReturnType: "DECIMAL",
	},
	"quantile_disc": {
		Description: "Returns the exact quantile number between 0 and 1 . If pos is a LIST of FLOATs, then the result is a LIST of the corresponding exact quantiles.",
		Signatures: []string{
			"quantile_disc(x ANY, pos DOUBLE) -> ANY",
		},
		ReturnType: "ANY",
	},
	"quarter": {
		Description: "Extract the quarter component from a date or timestamp",
		Signatures: []string{
			"quarter(ts INTERVAL) -> BIGINT",
		},
		ReturnType: "BIGINT",
	},
	"query": {
		Signatures: []string{
			"query(col0 VARCHAR) -> ",
		},
	},
	"query_table": {
		Signatures: []string{
			"query_table(col0 VARCHAR[]) -> ",
		},
	},
	"radians": {
		Description: "Converts degrees to radians",
		Signatures: []string{
			"radians(x DOUBLE) -> DOUBLE",
		},
		ReturnType: "DOUBLE",
	},
	"random": {
		Description: "Returns a random number between 0 and 1",
		Signatures: []string{
			"random() -> DOUBLE",
		},
		ReturnType: "DOUBLE",
	},
	"range": {
		Description: "Create a list of values between start and stop - the stop parameter is exclusive",
		Signatures: []string{
			"range(start BIGINT) -> BIGINT[]",
			"range(col0 TIMESTAMP, col1 TIMESTAMP, col2 INTERVAL) -> ",
		},
		ReturnType: "BIGINT[]",
	},
	"read_blob": {
		Signatures: []string{
			"read_blob(col0 VARCHAR[]) -> ",
		},
	},
	"read_csv": {
		Signatures: []string{
			"read_csv(col0 VARCHAR[], delim VARCHAR, dateformat VARCHAR, column_names VARCHAR[], sep VARCHAR, hive_partitioning BOOLEAN, header BOOLEAN, escape VARCHAR, allow_quoted_nulls BOOLEAN, comment VARCHAR, maximum_line_size VARCHAR, new_line VARCHAR, columns ANY, rejects_limit BIGINT, force_not_null VARCHAR[], timestampformat VARCHAR, auto_detect BOOLEAN, sample_size BIGINT, auto_type_candidates ANY, nullstr ANY, normalize_names BOOLEAN, rejects_table VARCHAR, column_types ANY, skip BIGINT, types ANY, max_line_size VARCHAR, quote VARCHAR, rejects_scan VARCHAR, ignore_errors BOOLEAN, compression VARCHAR, names VARCHAR[], store_rejects BOOLEAN, all_varchar BOOLEAN, buffer_size UBIGINT, decimal_separator VARCHAR, parallel BOOLEAN, null_padding BOOLEAN, dtypes ANY, filename ANY, union_by_name BOOLEAN, hive_types ANY, hive_types_autocast BOOLEAN) -> ",
		},
	},
	"read_csv_auto": {
		Signatures: []string{
			"read_csv_auto(col0 VARCHAR[], delim VARCHAR, dateformat VARCHAR, column_names VARCHAR[], sep VARCHAR, hive_partitioning BOOLEAN, header BOOLEAN, escape VARCHAR, allow_quoted_nulls BOOLEAN, comment VARCHAR, maximum_line_size VARCHAR, new_line VARCHAR, columns ANY, rejects_limit BIGINT, force_not_null VARCHAR[], timestampformat VARCHAR, auto_detect BOOLEAN, sample_size BIGINT, auto_type_candidates ANY, nullstr ANY, normalize_names BOOLEAN, rejects_table VARCHAR, column_types ANY, skip BIGINT, types ANY, max_line_size VARCHAR, quote VARCHAR, rejects_scan VARCHAR, ignore_errors BOOLEAN, compression VARCHAR, names VARCHAR[], store_rejects BOOLEAN, all_varchar BOOLEAN, buffer_size UBIGINT, decimal_separator VARCHAR, parallel BOOLEAN, null_padding BOOLEAN, dtypes ANY, filename ANY, union_by_name BOOLEAN, hive_types ANY, hive_types_autocast BOOLEAN) -> ",
		},
	},
	"read_json": {
		Signatures: []string{
			"read_json(col0 VARCHAR[], filename ANY, hive_types_autocast BOOLEAN, hive_partitioning BOOLEAN, hive_types ANY, timestamp_format VARCHAR, compression VARCHAR, maximum_sample_files BIGINT, union_by_name BOOLEAN, auto_detect BOOLEAN, maximum_depth BIGINT, maximum_object_size UINTEGER, ignore_errors BOOLEAN, format VARCHAR, convert_strings_to_integers BOOLEAN, columns ANY, sample_size BIGINT, dateformat VARCHAR, date_format VARCHAR, field_appearance_threshold DOUBLE, timestampformat VARCHAR, records VARCHAR, map_inference_threshold BIGINT) -> ",
		},
	},
	"read_json_auto": {
		Signatures: []string{
			"read_json_auto(col0 VARCHAR[], filename ANY, hive_types_autocast BOOLEAN, hive_partitioning BOOLEAN, hive_types ANY, timestamp_format VARCHAR, compression VARCHAR, maximum_sample_files BIGINT, union_by_name BOOLEAN, auto_detect BOOLEAN, maximum_depth BIGINT, maximum_object_size UINTEGER, ignore_errors BOOLEAN, format VARCHAR, convert_strings_to_integers BOOLEAN, columns ANY, sample_size BIGINT, dateformat VARCHAR, date_format VARCHAR, field_appearance_threshold DOUBLE, timestampformat VARCHAR, records VARCHAR, map_inference_threshold BIGINT) -> ",
		},
	},
	"read_json_objects": {
		Signatures: []string{
			"read_json_objects(col0 VARCHAR[], filename ANY, hive_types_autocast BOOLEAN, hive_partitioning BOOLEAN, hive_types ANY, compression VARCHAR, union_by_name BOOLEAN, maximum_object_size UINTEGER, ignore_errors BOOLEAN, format VARCHAR) -> ",
		},
	},
	"read_json_objects_auto": {
		Signatures: []string{
			"read_json_objects_auto(col0 VARCHAR[], filename ANY, hive_types_autocast BOOLEAN, hive_partitioning BOOLEAN, hive_types ANY, compression VARCHAR, union_by_name BOOLEAN, maximum_object_size UINTEGER, ignore_errors BOOLEAN, format VARCHAR) -> ",
		},
	},
	"read_ndjson": {
		Signatures: []string{
			"read_ndjson(col0 VARCHAR[], filename ANY, hive_types_autocast BOOLEAN, hive_partitioning BOOLEAN, hive_types ANY, timestamp_format VARCHAR, compression VARCHAR, maximum_sample_files BIGINT, union_by_name BOOLEAN, auto_detect BOOLEAN, maximum_depth BIGINT, maximum_object_size UINTEGER, ignore_errors BOOLEAN, format VARCHAR, convert_strings_to_integers BOOLEAN, columns ANY, sample_size BIGINT, dateformat VARCHAR, date_format VARCHAR, field_appearance_threshold DOUBLE, timestampformat VARCHAR, records VARCHAR, map_inference_threshold BIGINT) -> ",
		},
	},
	"read_ndjson_auto": {
		Signatures: []string{
			"read_ndjson_auto(col0 VARCHAR[], filename ANY, hive_types_autocast BOOLEAN, hive_partitioning BOOLEAN, hive_types ANY, timestamp_format VARCHAR, compression VARCHAR, maximum_sample_files BIGINT, union_by_name BOOLEAN, auto_detect BOOLEAN, maximum_depth BIGINT, maximum_object_size UINTEGER, ignore_errors BOOLEAN, format VARCHAR, convert_strings_to_integers BOOLEAN, columns ANY, sample_size BIGINT, dateformat VARCHAR, date_format VARCHAR, field_appearance_threshold DOUBLE, timestampformat VARCHAR, records VARCHAR, map_inference_threshold BIGINT) -> ",
		},
	},
	"read_ndjson_objects": {
		Signatures: []string{
			"read_ndjson_objects(col0 VARCHAR[], filename ANY, hive_types_autocast BOOLEAN, hive_partitioning BOOLEAN, hive_types ANY, compression VARCHAR, union_by_name BOOLEAN, maximum_object_size UINTEGER, ignore_errors BOOLEAN, format VARCHAR) -> ",
		},
	},
	"read_parquet": {
		Signatures: []string{
			"read_parquet(col0 VARCHAR[], schema MAP(INTEGER, file_row_number STRUCT(\"NAME\" VARCHAR, debug_use_openssl \"TYPE\" VARCHAR, union_by_name DEFAULT_VALUE VARCHAR)), explicit_cardinality BOOLEAN, compression BOOLEAN, encryption_config BOOLEAN, hive_partitioning UBIGINT, hive_types VARCHAR, filename ANY, binary_as_string BOOLEAN, hive_types_autocast ANY) -> ",
		},
	},
	"read_text": {
		Signatures: []string{
			"read_text(col0 VARCHAR[]) -> ",
		},
	},
	"reduce": {
		Description: "Returns a single value that is the result of applying the lambda function to each element of the input list, starting with the first element and then repeatedly applying the lambda function to the result of the previous application and the next element of the list.",
		Signatures: []string{
			"reduce(list ANY[], lambda LAMBDA) -> ANY",
		},
		ReturnType: "ANY",
	},
	"regexp_escape": {
		Description: "Escapes all potentially meaningful regexp characters in the input string",
		Signatures: []string{
			"regexp_escape(string VARCHAR) -> VARCHAR",
		},
		ReturnType: "VARCHAR",
	},
	"regexp_extract": {
		Signatures: []string{
			"regexp_extract(col0 VARCHAR, col1 VARCHAR) -> VARCHAR",
		},
		ReturnType: "VARCHAR",
	},
	"regexp_extract_all": {
		Signatures: []string{
			"regexp_extract_all(col0 VARCHAR, col1 VARCHAR) -> VARCHAR[]",
		},
		ReturnType: "VARCHAR[]",
	},
	"regexp_full_match": {
		Signatures: []string{
			"regexp_full_match(col0 VARCHAR, col1 VARCHAR, col2 VARCHAR) -> BOOLEAN",
		},
		ReturnType: "BOOLEAN",
	},
	"regexp_matches": {
		Signatures: []string{
			"regexp_matches(col0 VARCHAR, col1 VARCHAR) -> BOOLEAN",
		},
		ReturnType: "BOOLEAN",
	},
	"regexp_replace": {
		Signatures: []string{
			"regexp_replace(col0 VARCHAR, col1 VARCHAR, col2 VARCHAR, col3 VARCHAR) -> VARCHAR",
		},
		ReturnType: "VARCHAR",
	},
	"regexp_split_to_array": {
		Description: "Splits the string along the regex",
		Signatures: []string{
			"regexp_split_to_array(string VARCHAR, separator VARCHAR, col2 VARCHAR) -> VARCHAR[]",
		},
		ReturnType: "VARCHAR[]",
	},
	"regexp_split_to_table": {
		Signatures: []string{
			"regexp_split_to_table(text, pattern) -> ",
		},
	},
	"regr_avgx": {
		Description: "Returns the average of the independent variable for non-null pairs in a group, where x is the independent variable and y is the dependent variable.",
		Signatures: []string{
			"regr_avgx(y DOUBLE, x DOUBLE) -> DOUBLE",
		},
		ReturnType: "DOUBLE",
	},
	"regr_avgy": {
		Description: "Returns the average of the dependent variable for non-null pairs in a group, where x is the independent variable and y is the dependent variable.",
		Signatures: []string{
			"regr_avgy(y DOUBLE, x DOUBLE) -> DOUBLE",
		},
		ReturnType: "DOUBLE",
	},
	"regr_count": {
		Description: "Returns the number of non-null number pairs in a group.",
		Signatures: []string{
			"regr_count(y DOUBLE, x DOUBLE) -> UINTEGER",
		},
		ReturnType: "UINTEGER",
	},
	"regr_intercept": {
		Description: "Returns the intercept of the univariate linear regression line for non-null pairs in a group.",
		Signatures: []string{
			"regr_intercept(y DOUBLE, x DOUBLE) -> DOUBLE",
		},
		ReturnType: "DOUBLE",
	},
	"regr_r2": {
		Description: "Returns the coefficient of determination for non-null pairs in a group.",
		Signatures: []string{
			"regr_r2(y DOUBLE, x DOUBLE) -> DOUBLE",
		},
		ReturnType: "DOUBLE",
	},
	"regr_slope": {
		Description: "Returns the slope of the linear regression line for non-null pairs in a group.",
		Signatures: []string{
			"regr_slope(y DOUBLE, x DOUBLE) -> DOUBLE",
		},
		ReturnType: "DOUBLE",
	},
	"regr_sxx": {
		Signatures: []string{
			"regr_sxx(y DOUBLE, x DOUBLE) -> DOUBLE",
		},
		ReturnType: "DOUBLE",
	},
	"regr_sxy": {
		Description: "Returns the population covariance of input values",
		Signatures: []string{
			"regr_sxy(y DOUBLE, x DOUBLE) -> DOUBLE",
		},
		ReturnType: "DOUBLE",
	},
	"regr_syy": {
		Signatures: []string{
			"regr_syy(y DOUBLE, x DOUBLE) -> DOUBLE",
		},
		ReturnType: "DOUBLE",
	},
	"repeat": {
		Description: "Repeats the string count number of times",
		Signatures: []string{
			"repeat(string VARCHAR, count BIGINT) -> VARCHAR",
			"repeat(col0 ANY, col1 BIGINT) -> ",
		},
		ReturnType: "VARCHAR",
	},
	"repeat_row": {
		Signatures: []string{
			"repeat_row(num_rows BIGINT) -> ",
		},
	},
	"replace": {
		Description: "Replaces any occurrences of the source with target in string",
		Signatures: []string{
			"replace(string VARCHAR, source VARCHAR, target VARCHAR) -> VARCHAR",
		},
		ReturnType: "VARCHAR",
	},
	"reservoir_quantile": {
		Description: "Gives the approximate quantile using reservoir sampling, the sample size is optional and uses 8192 as a default size.",
		Signatures: []string{
			"reservoir_quantile(x TINYINT, quantile DOUBLE) -> TINYINT",
		},
		ReturnType: "TINYINT",
	},
	"reverse": {
		Description: "Reverses the string",
		Signatures: []string{
			"reverse(string VARCHAR) -> VARCHAR",
		},
		ReturnType: "VARCHAR",
	},
	"right": {
		Description: "Extract the right-most count characters",
		Signatures: []string{
			"right(string VARCHAR, count BIGINT) -> VARCHAR",
		},
		ReturnType: "VARCHAR",
	},
	"right_grapheme": {
		Description: "Extract the right-most count grapheme clusters",
		Signatures: []string{
			"right_grapheme(string VARCHAR, count BIGINT) -> VARCHAR",
		},
		ReturnType: "VARCHAR",
	},
	"round": {
		Description: "Rounds x to s decimal places",
		Signatures: []string{
			"round(x FLOAT, precision INTEGER) -> FLOAT",
		},
		ReturnType: "FLOAT",
	},
	"round_even": {
		Signatures: []string{
			"round_even(x, n) -> ",
		},
	},
	"roundbankers": {
		Signatures: []string{
			"roundbankers(x, n) -> ",
		},
	},
	"row": {
		Description: "Creates an unnamed STRUCT containing the argument values.",
		Signatures: []string{
			"row() -> STRUCT",
		},
		ReturnType: "STRUCT",
	},
	"row_to_json": {
		Signatures: []string{
			"row_to_json() -> JSON",
		},
		ReturnType: "JSON",
	},
	"rpad": {
		Description: "Pads the string with the character from the right until it has count characters",
		Signatures: []string{
			"rpad(string VARCHAR, count INTEGER, character VARCHAR) -> VARCHAR",
		},
		ReturnType: "VARCHAR",
	},
	"rtrim": {
		Description: "Removes any occurrences of any of the characters from the right side of the string",
		Signatures: []string{
			"rtrim(string VARCHAR, characters VARCHAR) -> VARCHAR",
		},
		ReturnType: "VARCHAR",
	},
	"second": {
		Description: "Extract the second component from a date or timestamp",
		Signatures: []string{
			"second(ts DATE) -> BIGINT",
		},
		ReturnType: "BIGINT",
	},
	"sem": {
		Description: "Returns the standard error of the mean",
		Signatures: []string{
			"sem(x DOUBLE) -> DOUBLE",
		},
		ReturnType: "DOUBLE",
	},
	"seq_scan": {
		Signatures: []string{
			"seq_scan() -> ",
		},
	},
	"session_user": {
		Signatures: []string{
			"session_user() -> ",
		},
	},
	"set_bit": {
		Description: "Sets the nth bit in bitstring to newvalue; the first (leftmost) bit is indexed 0. Returns a new bitstring",
		Signatures: []string{
			"set_bit(bitstring BIT, index INTEGER, new_value INTEGER) -> BIT",
		},
		ReturnType: "BIT",
	},
	"setseed": {
		Description: "Sets the seed to be used for the random function",
		Signatures: []string{
			"setseed() -> \"NULL\"",
		},
		ReturnType: "\"NULL\"",
	},
	"sha1": {
		Description: "Returns the SHA1 hash of the value",
		Signatures: []string{
			"sha1(value BLOB) -> VARCHAR",
		},
		ReturnType: "VARCHAR",
	},
	"sha256": {
		Description: "Returns the SHA256 hash of the value",
		Signatures: []string{
			"sha256(value VARCHAR) -> VARCHAR",
		},
		ReturnType: "VARCHAR",
	},
	"show": {
		Signatures: []string{
			"show(col0 VARCHAR) -> ",
		},
	},
	"show_databases": {
		Signatures: []string{
			"show_databases() -> ",
		},
	},
	"show_tables": {
		Signatures: []string{
			"show_tables() -> ",
		},
	},
	"show_tables_expanded": {
		Signatures: []string{
			"show_tables_expanded() -> ",
		},
	},
	"sign": {
		Description: "Returns the sign of x as -1, 0 or 1",
		Signatures: []string{
			"sign(x UINTEGER) -> TINYINT",
		},
		ReturnType: "TINYINT",
	},
	"signbit": {
		Description: "Returns whether the signbit is set or not",
		Signatures: []string{
			"signbit(x DOUBLE) -> BOOLEAN",
		},
		ReturnType: "BOOLEAN",
	},
	"sin": {
		Description: "Computes the sin of x",
		Signatures: []string{
			"sin(x DOUBLE) -> DOUBLE",
		},
		ReturnType: "DOUBLE",
	},
	"sinh": {
		Description: "Computes the hyperbolic sin of x",
		Signatures: []string{
			"sinh(x DOUBLE) -> DOUBLE",
		},
		ReturnType: "DOUBLE",
	},
	"skewness": {
		Description: "Returns the skewness of all input values.",
		Signatures: []string{
			"skewness(x DOUBLE) -> DOUBLE",
		},
		ReturnType: "DOUBLE",
	},
	"sniff_csv": {
		Signatures: []string{
			"sniff_csv(col0 VARCHAR, delim VARCHAR, dateformat VARCHAR, column_names VARCHAR[], sep VARCHAR, hive_partitioning BOOLEAN, header BOOLEAN, escape VARCHAR, allow_quoted_nulls BOOLEAN, comment VARCHAR, maximum_line_size VARCHAR, new_line VARCHAR, columns ANY, rejects_limit BIGINT, force_not_null VARCHAR[], timestampformat VARCHAR, auto_detect BOOLEAN, sample_size BIGINT, auto_type_candidates ANY, nullstr ANY, normalize_names BOOLEAN, rejects_table VARCHAR, column_types ANY, skip BIGINT, types ANY, max_line_size VARCHAR, quote VARCHAR, rejects_scan VARCHAR, ignore_errors BOOLEAN, compression VARCHAR, names VARCHAR[], store_rejects BOOLEAN, all_varchar BOOLEAN, buffer_size UBIGINT, decimal_separator VARCHAR, parallel BOOLEAN, null_padding BOOLEAN, dtypes ANY, filename ANY, union_by_name BOOLEAN, hive_types ANY, hive_types_autocast BOOLEAN) -> ",
		},
	},
	"split": {
		Description: "Splits the string along the separator",
		Signatures: []string{
			"split(string VARCHAR, separator VARCHAR) -> VARCHAR[]",
		},
		ReturnType: "VARCHAR[]",
	},
	"split_part": {
		Signatures: []string{
			"split_part(string, delimiter, position) -> ",
		},
	},
	"sqrt": {
		Description: "Returns the square root of x",
		Signatures: []string{
			"sqrt(x DOUBLE) -> DOUBLE",
		},
		ReturnType: "DOUBLE",
	},
	"starts_with": {
		Description: "Returns true if string begins with search_string",
		Signatures: []string{
			"starts_with(string VARCHAR, search_string VARCHAR) -> BOOLEAN",
		},
		ReturnType: "BOOLEAN",
	},
	"stats": {
		Description: "Returns a string with statistics about the expression. Expression can be a column, constant, or SQL expression",
		Signatures: []string{
			"stats(expression ANY) -> VARCHAR",
		},
		ReturnType: "VARCHAR",
	},
	"stddev": {
		Description: "Returns the sample standard deviation",
		Signatures: []string{
			"stddev(x DOUBLE) -> DOUBLE",
		},
		ReturnType: "DOUBLE",
	},
	"stddev_pop": {
		Description: "Returns the population standard deviation.",
		Signatures: []string{
			"stddev_pop(x DOUBLE) -> DOUBLE",
		},
		ReturnType: "DOUBLE",
	},
	"stddev_samp": {
		Description: "Returns the sample standard deviation",
		Signatures: []string{
			"stddev_samp(x DOUBLE) -> DOUBLE",
		},
		ReturnType: "DOUBLE",
	},
	"storage_info": {
		Signatures: []string{
			"storage_info(col0 VARCHAR) -> ",
		},
	},
	"str_split": {
		Description: "Splits the string along the separator",
		Signatures: []string{
			"str_split(string VARCHAR, separator VARCHAR) -> VARCHAR[]",
		},
		ReturnType: "VARCHAR[]",
	},
	"str_split_regex": {
		Description: "Splits the string along the regex",
		Signatures: []string{
			"str_split_regex(string VARCHAR, separator VARCHAR) -> VARCHAR[]",
		},
		ReturnType: "VARCHAR[]",
	},
	"strftime": {
		Description: "Converts timestamp to string according to the format string",
		Signatures: []string{
			"strftime(text VARCHAR, format DATE) -> VARCHAR",
		},
		ReturnType: "VARCHAR",
	},
	"string_agg": {
		Description: "Concatenates the column string values with an optional separator.",
		Signatures: []string{
			"string_agg(str ANY, arg VARCHAR) -> VARCHAR",
		},
		ReturnType: "VARCHAR",
	},
	"string_split": {
		Description: "Splits the string along the separator",
		Signatures: []string{
			"string_split(string VARCHAR, separator VARCHAR) -> VARCHAR[]",
		},
		ReturnType: "VARCHAR[]",
	},
	"string_split_regex": {
		Description: "Splits the string along the regex",
		Signatures: []string{
			"string_split_regex(string VARCHAR, separator VARCHAR, col2 VARCHAR) -> VARCHAR[]",
		},
		ReturnType: "VARCHAR[]",
	},
	"string_to_array": {
		Description: "Splits the string along the separator",
		Signatures: []string{
			"string_to_array(string VARCHAR, separator VARCHAR) -> VARCHAR[]",
		},
		ReturnType: "VARCHAR[]",
	},
	"strip_accents": {
		Signatures: []string{
			"strip_accents(col0 VARCHAR) -> VARCHAR",
		},
		ReturnType: "VARCHAR",
	},
	"strlen": {
		Signatures: []string{
			"strlen(col0 VARCHAR) -> BIGINT",
		},
		ReturnType: "BIGINT",
	},
	"strpos": {
		Description: "Returns location of first occurrence of needle in haystack, counting from 1. Returns 0 if no match found",
		Signatures: []string{
			"strpos(haystack VARCHAR, needle VARCHAR) -> BIGINT",
		},
		ReturnType: "BIGINT",
	},
	"strptime": {
		Description: "Converts string to timestamp with time zone according to the format string if %Z is specified",
		Signatures: []string{
			"strptime(text VARCHAR, format VARCHAR[]) -> TIMESTAMP",
		},
		ReturnType: "TIMESTAMP",
	},
	"struct_extract": {
		Signatures: []string{
			"struct_extract(col0 STRUCT, col1 VARCHAR) -> ANY",
		},
		ReturnType: "ANY",
	},
	"struct_insert": {
		Description: "Adds field(s)/value(s) to an existing STRUCT with the argument values. The entry name(s) will be the bound variable name(s)",
		Signatures: []string{
			"struct_insert() -> STRUCT",
		},
		ReturnType: "STRUCT",
	},
	"struct_pack": {
		Description: "Creates a STRUCT containing the argument values. The entry name will be the bound variable name",
		Signatures: []string{
			"struct_pack() -> STRUCT",
		},
		ReturnType: "STRUCT",
	},
	"substr": {
		Signatures: []string{
			"substr(col0 VARCHAR, col1 BIGINT, col2 BIGINT) -> VARCHAR",
		},
		ReturnType: "VARCHAR",
	},
	"substring": {
		Signatures: []string{
			"substring(col0 VARCHAR, col1 BIGINT) -> VARCHAR",
		},
		ReturnType: "VARCHAR",
	},
	"substring_grapheme": {
		Signatures: []string{
			"substring_grapheme(col0 VARCHAR, col1 BIGINT) -> VARCHAR",
		},
		ReturnType: "VARCHAR",
	},
	"subtract": {
		Signatures: []string{
			"subtract(col0 UBIGINT) -> UBIGINT",
		},
		ReturnType: "UBIGINT",
	},
	"suffix": {
		Signatures: []string{
			"suffix(col0 VARCHAR, col1 VARCHAR) -> BOOLEAN",
		},
		ReturnType: "BOOLEAN",
	},
	"sum": {
		Description: "Calculates the sum value for all tuples in arg.",
		Signatures: []string{
			"sum(arg HUGEINT) -> HUGEINT",
		},
		ReturnType: "HUGEINT",
	},
	"sum_no_overflow": {
		Description: "Internal only. Calculates the sum value for all tuples in arg without overflow checks.",
		Signatures: []string{
			"sum_no_overflow(arg DECIMAL) -> DECIMAL",
		},
		ReturnType: "DECIMAL",
	},
	"sumkahan": {
		Description: "Calculates the sum using a more accurate floating point summation (Kahan Sum).",
		Signatures: []string{
			"sumkahan(arg DOUBLE) -> DOUBLE",
		},
		ReturnType: "DOUBLE",
	},
	"summary": {
		Signatures: []string{
			"summary(col0 TABLE) -> ",
		},
	},
	"table_info": {
		Signatures: []string{
			"table_info(col0 VARCHAR) -> ",
		},
	},
	"tan": {
		Description: "Computes the tan of x",
		Signatures: []string{
			"tan(x DOUBLE) -> DOUBLE",
		},
		ReturnType: "DOUBLE",
	},
	"tanh": {
		Description: "Computes the hyperbolic tan of x",
		Signatures: []string{
			"tanh(x DOUBLE) -> DOUBLE",
		},
		ReturnType: "DOUBLE",
	},
	"test_all_types": {
		Signatures: []string{
			"test_all_types(use_large_enum BOOLEAN) -> ",
		},
	},
	"test_vector_types": {
		Signatures: []string{
			"test_vector_types(col0 ANY, all_flat BOOLEAN) -> ",
		},
	},
	"time_bucket": {
		Description: "Truncate TIMESTAMPTZ by the specified interval bucket_width. Buckets are aligned relative to origin TIMESTAMPTZ. The origin defaults to 2000-01-03 00:00:00+00 for buckets that do not include a month or year interval, and to 2000-01-01 00:00:00+00 for month and year buckets",
		Signatures: []string{
			"time_bucket(bucket_width INTERVAL, timestamp TIMESTAMP, origin TIMESTAMP) -> TIMESTAMP",
		},
		ReturnType: "TIMESTAMP",
	},
	"timetz_byte_comparable": {
		Description: "Converts a TIME WITH TIME ZONE to an integer sort key",
		Signatures: []string{
			"timetz_byte_comparable(time_tz TIME WITH TIME ZONE) -> UBIGINT",
		},
		ReturnType: "UBIGINT",
	},
	"timezone": {
		Description: "Extract the timezone component from a date or timestamp",
		Signatures: []string{
			"timezone(ts INTERVAL, col1 TIME WITH TIME ZONE) -> TIME WITH TIME ZONE",
		},
		ReturnType: "TIME WITH TIME ZONE",
	},
	"timezone_hour": {
		Description: "Extract the timezone_hour component from a date or timestamp",
		Signatures: []string{
			"timezone_hour(ts DATE) -> BIGINT",
		},
		ReturnType: "BIGINT",
	},
	"timezone_minute": {
		Description: "Extract the timezone_minute component from a date or timestamp",
		Signatures: []string{
			"timezone_minute(ts INTERVAL) -> BIGINT",
		},
		ReturnType: "BIGINT",
	},
	"to_base": {
		Description: "Converts a value to a string in the given base radix, optionally padding with leading zeros to the minimum length",
		Signatures: []string{
			"to_base(number BIGINT, radix INTEGER) -> VARCHAR",
		},
		ReturnType: "VARCHAR",
	},
	"to_base64": {
		Description: "Convert a blob to a base64 encoded string",
		Signatures: []string{
			"to_base64(blob BLOB) -> VARCHAR",
		},
		ReturnType: "VARCHAR",
	},
	"to_binary": {
		Description: "Converts the value to binary representation",
		Signatures: []string{
			"to_binary(value UBIGINT) -> VARCHAR",
		},
		ReturnType: "VARCHAR",
	},
	"to_centuries": {
		Description: "Construct a century interval",
		Signatures: []string{
			"to_centuries(integer INTEGER) -> INTERVAL",
		},
		ReturnType: "INTERVAL",
	},
	"to_days": {
		Description: "Construct a day interval",
		Signatures: []string{
			"to_days(integer INTEGER) -> INTERVAL",
		},
		ReturnType: "INTERVAL",
	},
	"to_decades": {
		Description: "Construct a decade interval",
		Signatures: []string{
			"to_decades(integer INTEGER) -> INTERVAL",
		},
		ReturnType: "INTERVAL",
	},
	"to_hex": {
		Description: "Converts the value to hexadecimal representation",
		Signatures: []string{
			"to_hex(value BIGINT) -> VARCHAR",
		},
		ReturnType: "VARCHAR",
	},
	"to_hours": {
		Description: "Construct a hour interval",
		Signatures: []string{
			"to_hours(integer BIGINT) -> INTERVAL",
		},
		ReturnType: "INTERVAL",
	},
	"to_json": {
		Signatures: []string{
			"to_json() -> JSON",
		},
		ReturnType: "JSON",
	},
	"to_microseconds": {
		Description: "Construct a microsecond interval",
		Signatures: []string{
			"to_microseconds(integer BIGINT) -> INTERVAL",
		},
		ReturnType: "INTERVAL",
	},
	"to_millennia": {
		Description: "Construct a millenium interval",
		Signatures: []string{
			"to_millennia(integer INTEGER) -> INTERVAL",
		},
		ReturnType: "INTERVAL",
	},
	"to_milliseconds": {
		Description: "Construct a millisecond interval",
		Signatures: []string{
			"to_milliseconds(double DOUBLE) -> INTERVAL",
		},
		ReturnType: "INTERVAL",
	},
	"to_minutes": {
		Description: "Construct a minute interval",
		Signatures: []string{
			"to_minutes(integer BIGINT) -> INTERVAL",
		},
		ReturnType: "INTERVAL",
	},
	"to_months": {
		Description: "Construct a month interval",
		Signatures: []string{
			"to_months(integer INTEGER) -> INTERVAL",
		},
		ReturnType: "INTERVAL",
	},
	"to_quarters": {
		Description: "Construct a quarter interval",
		Signatures: []string{
			"to_quarters(integer INTEGER) -> INTERVAL",
		},
		ReturnType: "INTERVAL",
	},
	"to_seconds": {
		Description: "Construct a second interval",
		Signatures: []string{
			"to_seconds(double DOUBLE) -> INTERVAL",
		},
		ReturnType: "INTERVAL",
	},
	"to_timestamp": {
		Description: "Converts secs since epoch to a timestamp with time zone",
		Signatures: []string{
			"to_timestamp(sec DOUBLE) -> TIMESTAMP WITH TIME ZONE",
		},
		ReturnType: "TIMESTAMP WITH TIME ZONE",
	},
	"to_weeks": {
		Description: "Construct a week interval",
		Signatures: []string{
			"to_weeks(integer INTEGER) -> INTERVAL",
		},
		ReturnType: "INTERVAL",
	},
	"to_years": {
		Description: "Construct a year interval",
		Signatures: []string{
			"to_years(integer INTEGER) -> INTERVAL",
		},
		ReturnType: "INTERVAL",
	},
	"today": {
		Description: "Returns the current date",
		Signatures: []string{
			"today() -> DATE",
		},
		ReturnType: "DATE",
	},
	"transaction_timestamp": {
		Description: "Returns the current timestamp",
		Signatures: []string{
			"transaction_timestamp() -> TIMESTAMP WITH TIME ZONE",
		},
		ReturnType: "TIMESTAMP WITH TIME ZONE",
	},
	"translate": {
		Description: "Replaces each character in string that matches a character in the from set with the corresponding character in the to set. If from is longer than to, occurrences of the extra characters in from are deleted",
		Signatures: []string{
			"translate(string VARCHAR, from VARCHAR, to VARCHAR) -> VARCHAR",
		},
		ReturnType: "VARCHAR",
	},
	"trim": {
		Description: "Removes any occurrences of any of the characters from either side of the string",
		Signatures: []string{
			"trim(string VARCHAR) -> VARCHAR",
		},
		ReturnType: "VARCHAR",
	},
	"trunc": {
		Description: "Truncates the number",
		Signatures: []string{
			"trunc(x TINYINT) -> TINYINT",
		},
		ReturnType: "TINYINT",
	},
	"try_strptime": {
		Description: "Converts string to timestamp using the format string (timestamp with time zone if %Z is specified). Returns NULL on failure",
		Signatures: []string{
			"try_strptime(text VARCHAR, format VARCHAR[]) -> TIMESTAMP",
		},
		ReturnType: "TIMESTAMP",
	},
	"txid_current": {
		Description: "Returns the current transaction’s ID (a BIGINT). It will assign a new one if the current transaction does not have one already",
		Signatures: []string{
			"txid_current() -> UBIGINT",
		},
		ReturnType: "UBIGINT",
	},
	"typeof": {
		Description: "Returns the name of the data type of the result of the expression",
		Signatures: []string{
			"typeof(expression ANY) -> VARCHAR",
		},
		ReturnType: "VARCHAR",
	},
	"ucase": {
		Signatures: []string{
			"ucase(col0 VARCHAR) -> VARCHAR",
		},
		ReturnType: "VARCHAR",
	},
	"unbin": {
		Description: "Converts a value from binary representation to a blob",
		Signatures: []string{
			"unbin(value VARCHAR) -> BLOB",
		},
		ReturnType: "BLOB",
	},
	"unhex": {
		Description: "Converts a value from hexadecimal representation to a blob",
		Signatures: []string{
			"unhex(value VARCHAR) -> BLOB",
		},
		ReturnType: "BLOB",
	},
	"unicode": {
		Description: "Returns the unicode codepoint of the first character of the string",
		Signatures: []string{
			"unicode(str VARCHAR) -> INTEGER",
		},
		ReturnType: "INTEGER",
	},
	"union_extract": {
		Description: "Extract the value with the named tags from the union. NULL if the tag is not currently selected",
		Signatures: []string{
			"union_extract(union UNION, tag VARCHAR) -> ANY",
		},
		ReturnType: "ANY",
	},
	"union_tag": {
		Description: "Retrieve the currently selected tag of the union as an ENUM",
		Signatures: []string{
			"union_tag(union UNION) -> ANY",
		},
		ReturnType: "ANY",
	},
	"union_value": {
		Description: "Create a single member UNION containing the argument value. The tag of the value will be the bound variable name",
		Signatures: []string{
			"union_value() -> UNION",
		},
		ReturnType: "UNION",
	},
	"unnest": {
		Signatures: []string{
			"unnest(col0 ANY) -> ",
		},
	},
	"unpivot_list": {
		Description: "Identical to list_value, but generated as part of unpivot for better error messages",
		Signatures: []string{
			"unpivot_list() -> LIST",
		},
		ReturnType: "LIST",
	},
	"upper": {
		Signatures: []string{
			"upper(col0 VARCHAR) -> VARCHAR",
		},
		ReturnType: "VARCHAR",
	},
	"url_decode": {
		Description: "Unescapes the URL encoded input.",
		Signatures: []string{
			"url_decode(input VARCHAR) -> VARCHAR",
		},
		ReturnType: "VARCHAR",
	},
	"url_encode": {
		Description: "Escapes the input string by encoding it so that it can be included in a URL query parameter.",
		Signatures: []string{
			"url_encode(input VARCHAR) -> VARCHAR",
		},
		ReturnType: "VARCHAR",
	},
	"user": {
		Signatures: []string{
			"user() -> ",
		},
	},
	"user_agent": {
		Signatures: []string{
			"user_agent() -> ",
		},
	},
	"uuid": {
		Description: "Returns a random UUID similar to this: eeccb8c5-9943-b2bb-bb5e-222f4e14b687",
		Signatures: []string{
			"uuid() -> UUID",
		},
		ReturnType: "UUID",
	},
	"var_pop": {
		Description: "Returns the population variance.",
		Signatures: []string{
			"var_pop(x DOUBLE) -> DOUBLE",
		},
		ReturnType: "DOUBLE",
	},
	"var_samp": {
		Description: "Returns the sample variance of all input values.",
		Signatures: []string{
			"var_samp(x DOUBLE) -> DOUBLE",
		},
		ReturnType: "DOUBLE",
	},
	"variance": {
		Description: "Returns the sample variance of all input values.",
		Signatures: []string{
			"variance(x DOUBLE) -> DOUBLE",
		},
		ReturnType: "DOUBLE",
	},
	"vector_type": {
		Description: "Returns the VectorType of a given column",
		Signatures: []string{
			"vector_type(col ANY) -> VARCHAR",
		},
		ReturnType: "VARCHAR",
	},
	"verify_external": {
		Signatures: []string{
			"verify_external() -> ",
		},
	},
	"verify_fetch_row": {
		Signatures: []string{
			"verify_fetch_row() -> ",
		},
	},
	"verify_parallelism": {
		Signatures: []string{
			"verify_parallelism() -> ",
		},
	},
	"verify_serializer": {
		Signatures: []string{
			"verify_serializer() -> ",
		},
	},
	"version": {
		Signatures: []string{
			"version() -> ",
			"version() -> VARCHAR",
		},
	},
	"week": {
		Description: "Extract the week component from a date or timestamp",
		Signatures: []string{
			"week(ts TIMESTAMP) -> BIGINT",
		},
		ReturnType: "BIGINT",
	},
	"weekday": {
		Description: "Extract the weekday component from a date or timestamp",
		Signatures: []string{
			"weekday(ts INTERVAL) -> BIGINT",
		},
		ReturnType: "BIGINT",
	},
	"weekofyear": {
		Description: "Extract the weekofyear component from a date or timestamp",
		Signatures: []string{
			"weekofyear(ts INTERVAL) -> BIGINT",
		},
		ReturnType: "BIGINT",
	},
	"which_secret": {
		Signatures: []string{
			"which_secret(col0 VARCHAR, col1 VARCHAR) -> ",
		},
	},
	"xor": {
		Description: "Bitwise XOR",
		Signatures: []string{
			"xor(left BIGINT, right BIGINT) -> BIGINT",
		},
		ReturnType: "BIGINT",
	},
	"year": {
		Description: "Extract the year component from a date or timestamp",
		Signatures: []string{
			"year(ts INTERVAL) -> BIGINT",
		},
		ReturnType: "BIGINT",
	},
	"yearweek": {
		Description: "Extract the yearweek component from a date or timestamp",
		Signatures: []string{
			"yearweek(ts DATE) -> BIGINT",
		},
		ReturnType: "BIGINT",
	},
}

// duckDBAggregates contains all aggregate function names.
var duckDBAggregates = []string{
	"any_value", "approx_count_distinct", "approx_quantile", "approx_top_k", "arbitrary",
	"arg_max", "arg_max_null", "arg_min", "arg_min_null", "argmax",
	"argmin", "array_agg", "avg", "bit_and", "bit_or",
	"bit_xor", "bitstring_agg", "bool_and", "bool_or", "corr",
	"count", "count_star", "covar_pop", "covar_samp", "entropy",
	"favg", "first", "fsum", "group_concat", "histogram",
	"histogram_exact", "kahan_sum", "kurtosis", "kurtosis_pop", "last",
	"list", "listagg", "mad", "max", "max_by",
	"mean", "median", "min", "min_by", "mode",
	"product", "quantile", "quantile_cont", "quantile_disc", "regr_avgx",
	"regr_avgy", "regr_count", "regr_intercept", "regr_r2", "regr_slope",
	"regr_sxx", "regr_sxy", "regr_syy", "reservoir_quantile", "sem",
	"skewness", "stddev", "stddev_pop", "stddev_samp", "string_agg",
	"sum", "sum_no_overflow", "sumkahan", "var_pop", "var_samp",
	"variance",
}

// duckDBTableFunctions contains all table-valued function names.
var duckDBTableFunctions = []string{
	"arrow_scan", "arrow_scan_dumb", "checkpoint", "duckdb_columns", "duckdb_constraints",
	"duckdb_databases", "duckdb_dependencies", "duckdb_extensions", "duckdb_functions", "duckdb_indexes",
	"duckdb_keywords", "duckdb_memory", "duckdb_optimizers", "duckdb_schemas", "duckdb_secrets",
	"duckdb_sequences", "duckdb_settings", "duckdb_tables", "duckdb_temporary_files", "duckdb_types",
	"duckdb_variables", "duckdb_views", "force_checkpoint", "generate_series", "glob",
	"index_scan", "json_execute_serialized_sql", "parquet_file_metadata", "parquet_kv_metadata", "parquet_metadata",
	"parquet_scan", "parquet_schema", "pragma_collations", "pragma_database_size", "pragma_metadata_info",
	"pragma_platform", "pragma_show", "pragma_storage_info", "pragma_table_info", "pragma_user_agent",
	"pragma_version", "query", "query_table", "range", "read_blob",
	"read_csv", "read_csv_auto", "read_json", "read_json_auto", "read_json_objects",
	"read_json_objects_auto", "read_ndjson", "read_ndjson_auto", "read_ndjson_objects", "read_parquet",
	"read_text", "repeat", "repeat_row", "seq_scan", "sniff_csv",
	"summary", "test_all_types", "test_vector_types", "unnest", "which_secret",
}
