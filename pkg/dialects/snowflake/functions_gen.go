// Code generated by scripts/gensnowflake. DO NOT EDIT.
// Source: https://docs.snowflake.com/en/sql-reference/functions-all
// Generated: 2026-01-05

package snowflake

import "github.com/leapstack-labs/leapsql/pkg/core"

// snowflakeScalars contains all scalar function names.
var snowflakeScalars = []string{
	"abs", "accepted_values", "acos", "acosh", "add_months",
	"ai_classify", "ai_complete", "ai_count_tokens", "ai_embed", "ai_extract",
	"ai_filter", "ai_parse_document", "ai_redact", "ai_sentiment", "ai_similarity",
	"ai_transcribe", "ai_translate", "application_json", "array_append", "array_cat",
	"array_compact", "array_construct", "array_construct_compact", "array_contains", "array_distinct",
	"array_except", "array_flatten", "array_generate_range", "array_insert", "array_intersection",
	"array_max", "array_min", "array_position", "array_prepend", "array_remove",
	"array_remove_at", "array_reverse", "array_size", "array_slice", "array_sort",
	"array_to_string", "arrays_overlap", "arrays_to_object", "arrays_zip", "as_array",
	"as_binary", "as_boolean", "as_char", "as_date", "as_decimal",
	"as_double", "as_integer", "as_object", "as_time", "ascii",
	"asin", "asinh", "atan", "atan2", "atanh",
	"base64_decode_binary", "base64_decode_string", "base64_encode", "bit_length", "bitand",
	"bitnot", "bitor", "bitshiftleft", "bitshiftright", "bitxor",
	"blank_count", "blank_percent", "booland", "boolnot", "boolor",
	"boolxor", "build_scoped_file_url", "build_stage_file_url", "case", "cast",
	"cbrt", "ceil", "charindex", "check_json", "check_xml",
	"chr", "classify_text", "coalesce", "collate", "collation",
	"complete", "compress", "concat", "concat_ws", "contains",
	"convert_timezone", "cos", "cosh", "cot", "count_tokens",
	"data_metric_scheduled_time", "date_from_parts", "date_part", "date_trunc", "dateadd",
	"datediff", "dayname", "decode", "decompress_binary", "decompress_string",
	"decrypt", "decrypt_raw", "degrees", "div0", "div0null",
	"dp_interval_high", "dp_interval_low", "duplicate_count", "editdistance", "email_integration_config",
	"embed_text_1024", "embed_text_768", "encrypt", "encrypt_raw", "endswith",
	"entity_sentiment", "equal_null", "exp", "explain_json", "extract",
	"extract_answer", "extract_semantic_categories", "factorial", "filter", "finetune",
	"fl_get_content_type", "fl_get_etag", "fl_get_file_type", "fl_get_last_modified", "fl_get_relative_path",
	"fl_get_scoped_file_url", "fl_get_size", "fl_get_stage", "fl_get_stage_file_url", "fl_is_audio",
	"fl_is_compressed", "fl_is_document", "fl_is_image", "fl_is_video", "floor",
	"freshness", "generate_column_description", "get", "get_absolute_path", "get_anaconda_packages_repodata",
	"get_ddl", "get_ignore_case", "get_path", "get_presigned_url", "get_python_profiler_output",
	"get_relative_path", "get_stage_location", "getbit", "greatest", "greatest_ignore_nulls",
	"h3_cell_to_boundary", "h3_cell_to_children", "h3_cell_to_children_string", "h3_cell_to_parent", "h3_cell_to_point",
	"h3_compact_cells", "h3_compact_cells_strings", "h3_coverage", "h3_coverage_strings", "h3_get_resolution",
	"h3_grid_disk", "h3_grid_distance", "h3_grid_path", "h3_int_to_string", "h3_is_pentagon",
	"h3_is_valid_cell", "h3_latlng_to_cell", "h3_latlng_to_cell_string", "h3_point_to_cell", "h3_point_to_cell_string",
	"h3_polygon_to_cells", "h3_polygon_to_cells_strings", "h3_string_to_int", "h3_try_coverage", "h3_try_coverage_strings",
	"h3_try_grid_distance", "h3_try_grid_path", "h3_try_polygon_to_cells", "h3_try_polygon_to_cells_strings", "h3_uncompact_cells",
	"h3_uncompact_cells_strings", "hash", "haversine", "hex_decode_binary", "hex_decode_string",
	"hex_encode", "hour", "iceberg_table_files", "iceberg_table_snapshot_refresh_history", "iff",
	"ifnull", "initcap", "insert", "integration", "is_array",
	"is_binary", "is_boolean", "is_char", "is_date", "is_decimal",
	"is_double", "is_integer", "is_null_value", "is_object", "is_organization_user",
	"is_organization_user_group", "is_time", "jarowinkler_similarity", "json_extract_path_text", "last_day",
	"last_successful_scheduled_time", "least", "least_ignore_nulls", "left", "length",
	"ln", "log", "lower", "lpad", "ltrim",
	"map_cat", "map_contains_key", "map_delete", "map_insert", "map_keys",
	"map_pick", "map_size", "max", "md5", "md5_binary",
	"md5_number_lower64", "md5_number_upper64", "min", "mod", "model_monitor_drift_metric",
	"model_monitor_performance_metric", "model_monitor_stat_metric", "monthname", "months_between", "next_day",
	"null_count", "null_percent", "nullif", "nullifzero", "nvl",
	"nvl2", "object_construct", "object_construct_keep_null", "object_delete", "object_insert",
	"object_keys", "object_pick", "octet_length", "online_feature_table_refresh_history", "parse_document",
	"parse_ip", "parse_json", "parse_url", "parse_xml", "pi",
	"position", "pow", "previous_day", "prompt", "radians",
	"reduce", "regexp_count", "regexp_instr", "regexp_like", "regexp_replace",
	"regexp_substr", "regexp_substr_all", "regr_valx", "regr_valy", "repeat",
	"replace", "reverse", "right", "round", "row_count",
	"rpad", "rtrim", "rtrimmed_length", "sanitize_webhook_content", "scheduled_time",
	"search", "search_ip", "search_preview", "sentiment", "sha1",
	"sha1_binary", "sha2", "sha2_binary", "show_python_packages_dependencies", "sign",
	"sin", "sinh", "soundex", "soundex_p123", "space",
	"split", "split_part", "split_text_markdown_header", "split_text_recursive_character", "sqrt",
	"square", "st_area", "st_asewkb", "st_asewkt", "st_asgeojson",
	"st_aswkb", "st_aswkt", "st_azimuth", "st_buffer", "st_centroid",
	"st_collect", "st_contains", "st_coveredby", "st_covers", "st_difference",
	"st_dimension", "st_disjoint", "st_distance", "st_dwithin", "st_endpoint",
	"st_envelope", "st_geogfromgeohash", "st_geogpointfromgeohash", "st_geographyfromwkb", "st_geographyfromwkt",
	"st_geohash", "st_geometryfromwkb", "st_geometryfromwkt", "st_geomfromgeohash", "st_geompointfromgeohash",
	"st_hausdorffdistance", "st_interpolate", "st_intersection", "st_intersection_agg", "st_intersects",
	"st_isvalid", "st_length", "st_makegeompoint", "st_makeline", "st_makepoint",
	"st_makepolygon", "st_makepolygonoriented", "st_npoints", "st_perimeter", "st_pointn",
	"st_setsrid", "st_simplify", "st_srid", "st_startpoint", "st_symdifference",
	"st_transform", "st_union", "st_union_agg", "st_within", "st_x",
	"st_xmax", "st_xmin", "st_y", "st_ymax", "st_ymin",
	"startswith", "stddev", "strip_null_value", "strtok", "strtok_to_array",
	"substr", "summarize", "tan", "tanh", "text_html",
	"text_plain", "time_from_parts", "time_slice", "timeadd", "timediff",
	"timestamp_from_parts", "timestampadd", "timestampdiff", "to_array", "to_binary",
	"to_boolean", "to_char", "to_date", "to_decfloat", "to_decimal",
	"to_double", "to_file", "to_geography", "to_geometry", "to_json",
	"to_object", "to_time", "to_timestamp", "to_variant", "to_xml",
	"transform", "translate", "trim", "truncate", "try_base64_decode_binary",
	"try_base64_decode_string", "try_cast", "try_complete", "try_decrypt", "try_decrypt_raw",
	"try_hex_decode_binary", "try_hex_decode_string", "try_parse_json", "try_to_binary", "try_to_boolean",
	"try_to_date", "try_to_decfloat", "try_to_decimal", "try_to_double", "try_to_file",
	"try_to_geography", "try_to_geometry", "try_to_time", "try_to_timestamp", "typeof",
	"unicode", "unique_count", "upper", "vector_cosine_similarity", "vector_inner_product",
	"vector_l1_distance", "vector_l2_distance", "width_bucket", "xmlget", "zeroifnull",
}

// snowflakeAggregates contains all aggregate function names.
var snowflakeAggregates = []string{
	"ai_agg", "ai_summarize_agg", "any_value", "approx_count_distinct", "approx_percentile",
	"approx_percentile_accumulate", "approx_percentile_combine", "approx_percentile_estimate", "approx_top_k", "approx_top_k_accumulate",
	"approx_top_k_combine", "approx_top_k_estimate", "approximate_jaccard_index", "approximate_similarity", "array_agg",
	"array_union_agg", "array_unique_agg", "avg", "bitand_agg", "bitmap_bit_position",
	"bitmap_bucket_number", "bitmap_construct_agg", "bitmap_count", "bitmap_or_agg", "bitor_agg",
	"bitxor_agg", "booland_agg", "boolor_agg", "boolxor_agg", "corr",
	"count", "count_if", "covar_pop", "covar_samp", "datasketches_hll",
	"datasketches_hll_accumulate", "datasketches_hll_combine", "datasketches_hll_estimate", "grouping", "grouping_id",
	"hash_agg", "hll", "hll_accumulate", "hll_combine", "hll_estimate",
	"hll_export", "hll_import", "kurtosis", "listagg", "max_by",
	"median", "min_by", "minhash", "minhash_combine", "mode",
	"object_agg", "percentile_cont", "percentile_disc", "regr_avgx", "regr_avgy",
	"regr_count", "regr_intercept", "regr_r2", "regr_slope", "regr_sxx",
	"regr_sxy", "regr_syy", "skew", "stddev_pop", "sum",
	"var_pop", "var_samp", "variance", "variance_pop", "vector_avg",
	"vector_max", "vector_min", "vector_sum",
}

// snowflakeWindows contains all window function names.
var snowflakeWindows = []string{
	"any_value", "approx_count_distinct", "approx_percentile", "approx_percentile_accumulate", "approx_percentile_combine",
	"approx_percentile_estimate", "approx_top_k", "approx_top_k_accumulate", "approx_top_k_combine", "approx_top_k_estimate",
	"approximate_jaccard_index", "approximate_similarity", "array_agg", "array_union_agg", "array_unique_agg",
	"avg", "bitand_agg", "bitor_agg", "bitxor_agg", "booland_agg",
	"boolor_agg", "boolxor_agg", "conditional_change_event", "conditional_true_event", "corr",
	"count", "count_if", "covar_pop", "covar_samp", "cume_dist",
	"datasketches_hll", "datasketches_hll_accumulate", "datasketches_hll_combine", "datasketches_hll_estimate", "dense_rank",
	"first_value", "hash_agg", "hll", "hll_accumulate", "hll_combine",
	"hll_estimate", "hll_export", "hll_import", "interpolate_bfill", "kurtosis",
	"lag", "last_value", "lead", "listagg", "median",
	"minhash", "minhash_combine", "mode", "nth_value", "ntile",
	"object_agg", "percent_rank", "percentile_cont", "percentile_disc", "rank",
	"ratio_to_report", "regr_avgx", "regr_avgy", "regr_count", "regr_intercept",
	"regr_r2", "regr_slope", "regr_sxx", "regr_sxy", "regr_syy",
	"row_number", "stddev_pop", "sum", "var_pop", "var_samp",
	"variance", "variance_pop",
}

// snowflakeTableFunctions contains all table-valued function names.
var snowflakeTableFunctions = []string{
	"alert_history", "application_specification_status_history", "auto_refresh_registration_history", "automatic_clustering_history", "available_listing_refresh_history",
	"bind_values", "complete_task_graphs", "copy_history", "cortex_search_data_scan", "cumulative_privacy_losses",
	"current_task_graphs", "data_metric_function_expectations", "data_metric_function_references", "data_quality_monitoring_expectation_status", "data_quality_monitoring_results",
	"data_transfer_history", "database_refresh_history", "database_refresh_progress", "database_replication_usage_history", "database_storage_usage_history",
	"dbt_project_execution_history", "dynamic_table_graph_history", "dynamic_table_refresh_history", "dynamic_tables", "estimate_remaining_dp_aggregates",
	"external_functions_history", "external_table_file_registration_history", "external_table_files", "flatten", "generator",
	"get_contacts", "get_job_history", "get_lineage", "get_object_references", "get_query_operator_stats",
	"infer_schema", "listing_refresh_history", "login_history", "materialized_view_refresh_history", "network_rule_references",
	"notification_history", "pipe_usage_history", "policy_references", "query_acceleration_history", "query_history",
	"replication_group_dangling_references", "replication_group_refresh_history", "replication_group_refresh_progress", "replication_group_usage_history", "replication_usage_history",
	"rest_event_history", "result_scan", "search_optimization_history", "serverless_alert_history", "serverless_task_history",
	"split_to_table", "stage_directory_file_registration_history", "stage_storage_usage_history", "storage_lifecycle_policy_history", "strtok_split_to_table",
	"tag_references", "tag_references_all_columns", "tag_references_with_lineage", "task_dependents", "task_history",
	"to_query", "validate", "validate_pipe_load", "warehouse_load_history", "warehouse_metering_history",
}

// snowflakeGenerators contains generator functions (produce values without input).
var snowflakeGenerators = []string{
	"all_user_names", "current_account", "current_account_name", "current_available_roles", "current_client",
	"current_database", "current_date", "current_ip_address", "current_organization_name", "current_organization_user",
	"current_region", "current_role", "current_role_type", "current_schema", "current_schemas",
	"current_secondary_roles", "current_session", "current_statement", "current_time", "current_timestamp",
	"current_transaction", "current_user", "current_version", "current_warehouse", "get_condition_query_uuid",
	"getdate", "getvariable", "invoker_role", "invoker_share", "is_application_role_activated",
	"is_application_role_in_session", "is_database_role_in_session", "is_granted_to_invoker_role", "is_group_activated", "is_group_imported",
	"is_instance_role_in_session", "is_organization_user_group_in_session", "is_role_activated", "is_role_in_session", "is_user_imported",
	"last_query_id", "last_transaction", "localtime", "localtimestamp", "normal",
	"policy_context", "random", "randstr", "seq1", "sys_context",
	"sysdate", "systimestamp", "uniform", "uuid_string", "zipf",
}

// snowflakeFunctionDocs contains documentation for Snowflake functions.
var snowflakeFunctionDocs = map[string]core.FunctionDoc{
	"abs": {
		Description: "Numeric functions (Rounding and Truncation)",
		Signatures:  []string{"ABS( <num_expr> )"},
	},
	"accepted_values": {
		Description: "Data metric functions",
		Signatures:  []string{"SNOWFLAKE.CORE.ACCEPTED_VALUES ON ( <column>, <lambda-expression> )"},
	},
	"acos": {
		Description: "Numeric functions (Trigonometric)",
		Signatures:  []string{"ACOS( <input_expr> )"},
	},
	"acosh": {
		Description: "Numeric functions (Trigonometric)",
		Signatures:  []string{"ACOSH( <input_expr> )"},
	},
	"add_months": {
		Description: "Date & time functions",
		Signatures:  []string{"ADD_MONTHS( <date_or_timestamp_expr> , <num_months_expr> )"},
	},
	"ai_agg": {
		Description: "Aggregate functions (General) String & binary functions (AI Functions)",
		Signatures:  []string{"AI_AGG( <expr>, <instruction> )"},
	},
	"ai_classify": {
		Description: "String & binary functions (AI Functions)",
		Signatures:  []string{"AI_CLASSIFY( <input> , <list_of_categories> [, <config_object>] )"},
	},
	"ai_complete": {
		Description: "String & binary functions (AI Functions)",
		Signatures:  []string{"AI_COMPLETE(\n    <model>, <prompt> [ , <model_parameters> ] )"},
	},
	"ai_count_tokens": {
		Description: "String & binary functions (AI Functions)",
		Signatures:  []string{"AI_COUNT_TOKENS(<function_name>, <model_name> , <input_text> )\nAI_COUNT_TOKENS(<function_name>, <input_text> )\nAI_COUNT_TOKENS(<function_name>, <input_text>, <categories> )"},
	},
	"ai_embed": {
		Description: "String & binary functions (AI Functions)",
		Signatures:  []string{"AI_EMBED( <model> , <input> )"},
	},
	"ai_extract": {
		Description: "String & binary functions (AI Functions)",
		Signatures:  []string{"AI_EXTRACT ( model => <model> ,\n            file => <file> )"},
	},
	"ai_filter": {
		Description: "String & binary functions (AI Functions)",
		Signatures:  []string{"AI_FILTER( <input> )"},
	},
	"ai_parse_document": {
		Description: "String & binary functions (AI Functions)",
		Signatures:  []string{"AI_PARSE_DOCUMENT( '@<stage>', '<path>', [ <options> ] )"},
	},
	"ai_redact": {
		Description: "String & binary functions (AI Functions)",
		Signatures:  []string{"AI_REDACT( <input> [,  <categories> ] [, <return_error_details> ] )"},
	},
	"ai_sentiment": {
		Description: "String & binary functions (AI Functions)",
		Signatures:  []string{"AI_SENTIMENT( <text> [ , <categories> ] )"},
	},
	"ai_similarity": {
		Description: "Computes a similarity score based on the vector cosine similarity value of the inputsâ€™ embedding vectors. Currently supports both text and image similarity computation.",
		Signatures:  []string{"AI_SIMILARITY( <input1>, <input2> )"},
	},
	"ai_summarize_agg": {
		Description: "Aggregate functions (General) String & binary functions (AI Functions)",
		Signatures:  []string{"AI_SUMMARIZE_AGG( <expr> )"},
	},
	"ai_transcribe": {
		Description: "File functions (AI Functions)",
		Signatures:  []string{"AI_TRANSCRIBE( <audio_file> [ , <options> ] )"},
	},
	"ai_translate": {
		Description: "String & binary functions (AI Functions)",
		Signatures:  []string{"AI_TRANSLATE(\n    <text>, <source_language>, <target_language>)"},
	},
	"alert_history": {
		Description: "Information Schema , Table functions",
		Signatures:  []string{"ALERT_HISTORY(\n      [ SCHEDULED_TIME_RANGE_START => <constant_expr> ]\n      [, SCHEDULED_TIME_RANGE_END => <constant_expr> ]\n      [, RESULT_LIMIT => <integer> ]\n      [, ALERT_NAME => '<string>' ] )"},
	},
	"all_user_names": {
		Description: "Context functions (Session)",
		Signatures:  []string{"ALL_USER_NAMES()"},
	},
	"any_value": {
		Description: "Aggregate functions (General) , Window functions (General)",
		Signatures:  []string{"ANY_VALUE( [ DISTINCT ] <expr1> )"},
	},
	"application_json": {
		Description: "Notification functions (Message Construction)",
		Signatures:  []string{"SNOWFLAKE.NOTIFICATION.APPLICATION_JSON( '<message>' )"},
	},
	"application_specification_status_history": {
		Description: "Information Schema , Table functions",
		Signatures:  []string{"APPLICATION_SPECIFICATION_STATUS_HISTORY(\n  [ APPLICATION_NAME => '<application_name>' ]\n  [ , SPECIFICATION_NAME => '<specification_name>'])\n  [ LIMIT => <number_of_rows> ]"},
	},
	"approx_count_distinct": {
		Description: "Aggregate functions (Cardinality Estimation) , Window functions",
		Signatures:  []string{"APPROX_COUNT_DISTINCT( [ DISTINCT ] <expr1>  [ , ... ] )\n\nAPPROX_COUNT_DISTINCT(*)"},
	},
	"approx_percentile": {
		Description: "Aggregate functions (Percentile Estimation) , Window functions",
		Signatures:  []string{"APPROX_PERCENTILE( <expr> , <percentile> )"},
	},
	"approx_percentile_accumulate": {
		Description: "Aggregate functions (Percentile Estimation) , Window function syntax and usage",
		Signatures:  []string{"APPROX_PERCENTILE_ACCUMULATE( <expr> )"},
	},
	"approx_percentile_combine": {
		Description: "Aggregate functions (Percentile Estimation) , Window function syntax and usage",
		Signatures:  []string{"APPROX_PERCENTILE_COMBINE( <state> )"},
	},
	"approx_percentile_estimate": {
		Description: "Aggregate functions (Percentile Estimation) , Window function syntax and usage",
		Signatures:  []string{"APPROX_PERCENTILE_ESTIMATE( <state> , <percentile> )"},
	},
	"approx_top_k": {
		Description: "Aggregate functions (Frequency Estimation) , Window functions",
		Signatures:  []string{"APPROX_TOP_K( <expr> [ , <k> [ , <counters> ] ] )"},
	},
	"approx_top_k_accumulate": {
		Description: "Aggregate functions (Frequency Estimation) , Window function syntax and usage",
		Signatures:  []string{"APPROX_TOP_K_ACCUMULATE( <expr> , <counters> )"},
	},
	"approx_top_k_combine": {
		Description: "Aggregate functions (Frequency Estimation) , Window function syntax and usage",
		Signatures:  []string{"APPROX_TOP_K_COMBINE( <state> [ , <counters> ] )"},
	},
	"approx_top_k_estimate": {
		Description: "Aggregate functions (Frequency Estimation) , Window function syntax and usage",
		Signatures:  []string{"APPROX_TOP_K_ESTIMATE( <state> [ , <k> ] )"},
	},
	"approximate_jaccard_index": {
		Description: "Aggregate functions (Similarity Estimation) , Window functions",
		Signatures:  []string{"APPROXIMATE_JACCARD_INDEX( [ DISTINCT ] <expr> [ , ... ] )\n\nAPPROXIMATE_JACCARD_INDEX(*)"},
	},
	"approximate_similarity": {
		Description: "Aggregate functions (Similarity Estimation) , Window function syntax and usage",
		Signatures:  []string{"APPROXIMATE_SIMILARITY( [ DISTINCT ] <expr> [ , ... ] )\n\nAPPROXIMATE_SIMILARITY(*)"},
	},
	"array_agg": {
		Description: "Aggregate functions (Semi-structured Data) , Window functions (General) , Semi-structured and structured data functions (Array/Object)",
		Signatures:  []string{"ARRAY_AGG( [ DISTINCT ] <expr1> ) [ WITHIN GROUP ( <orderby_clause> ) ]"},
	},
	"array_append": {
		Description: "Semi-structured and structured data functions (Array/Object)",
		Signatures:  []string{"ARRAY_APPEND( <array> , <new_element> )"},
	},
	"array_cat": {
		Description: "Semi-structured and structured data functions (Array/Object)",
		Signatures:  []string{"ARRAY_CAT( <array1> , <array2> )"},
	},
	"array_compact": {
		Description: "Semi-structured and structured data functions (Array/Object)",
		Signatures:  []string{"ARRAY_COMPACT( <array1> )"},
	},
	"array_construct": {
		Description: "Semi-structured and structured data functions (Array/Object)",
		Signatures:  []string{"ARRAY_CONSTRUCT( [ <expr1> ] [ , <expr2> [ , ... ] ] )"},
	},
	"array_construct_compact": {
		Description: "Semi-structured and structured data functions (Array/Object)",
		Signatures:  []string{"ARRAY_CONSTRUCT_COMPACT( [ <expr1> ] [ , <expr2> [ , ... ] ] )"},
	},
	"array_contains": {
		Description: "Semi-structured and structured data functions (Array/Object)",
		Signatures:  []string{"ARRAY_CONTAINS( <value_expr> , <array> )"},
	},
	"array_distinct": {
		Description: "Semi-structured and structured data functions (Array/Object)",
		Signatures:  []string{"ARRAY_DISTINCT( <array> )"},
	},
	"array_except": {
		Description: "Semi-structured and structured data functions (Array/Object)",
		Signatures:  []string{"ARRAY_EXCEPT( <source_array> , <array_of_elements_to_exclude> )"},
	},
	"array_flatten": {
		Description: "Semi-structured and structured data functions (Array/Object)",
		Signatures:  []string{"ARRAY_FLATTEN( <array> )"},
	},
	"array_generate_range": {
		Description: "Semi-structured and structured data functions (Array/Object)",
		Signatures:  []string{"ARRAY_GENERATE_RANGE( <start> , <stop> [ , <step> ] )"},
	},
	"array_insert": {
		Description: "Semi-structured and structured data functions (Array/Object)",
		Signatures:  []string{"ARRAY_INSERT( <array> , <pos> , <new_element> )"},
	},
	"array_intersection": {
		Description: "Semi-structured and structured data functions (Array/Object)",
		Signatures:  []string{"ARRAY_INTERSECTION( <array1> , <array2> )"},
	},
	"array_max": {
		Description: "Semi-structured and structured data functions (Array/Object)",
		Signatures:  []string{"ARRAY_MAX( <array> )"},
	},
	"array_min": {
		Description: "Semi-structured and structured data functions (Array/Object)",
		Signatures:  []string{"ARRAY_MIN( <array> )"},
	},
	"array_position": {
		Description: "Semi-structured and structured data functions (Array/Object)",
		Signatures:  []string{"ARRAY_POSITION( <variant_expr> , <array> )"},
	},
	"array_prepend": {
		Description: "Semi-structured and structured data functions (Array/Object)",
		Signatures:  []string{"ARRAY_PREPEND( <array> , <new_element> )"},
	},
	"array_remove": {
		Description: "Semi-structured and structured data functions (Array/Object)",
		Signatures:  []string{"ARRAY_REMOVE( <array> , <value_of_elements_to_remove> )"},
	},
	"array_remove_at": {
		Description: "Semi-structured and structured data functions (Array/Object)",
		Signatures:  []string{"ARRAY_REMOVE_AT( <array> , <position> )"},
	},
	"array_reverse": {
		Description: "Semi-structured and structured data functions (Array/Object)",
		Signatures:  []string{"ARRAY_REVERSE( <array> )"},
	},
	"array_size": {
		Description: "Semi-structured and structured data functions (Array/Object)",
		Signatures:  []string{"ARRAY_SIZE( <array> )\n\nARRAY_SIZE( <variant> )"},
	},
	"array_slice": {
		Description: "Semi-structured and structured data functions (Array/Object)",
		Signatures:  []string{"ARRAY_SLICE( <array> , <from> , <to> )"},
	},
	"array_sort": {
		Description: "Semi-structured and structured data functions (Array/Object)",
		Signatures:  []string{"ARRAY_SORT( <array> [ , <sort_ascending> [ , <nulls_first> ] ] )"},
	},
	"array_to_string": {
		Description: "Semi-structured and structured data functions (Array/Object)",
		Signatures:  []string{"ARRAY_TO_STRING( <array> , <separator_string> )"},
	},
	"array_union_agg": {
		Description: "Aggregate functions (Counting Distinct Values) , Window functions (Semi-structured Data Aggregation)",
		Signatures:  []string{"ARRAY_UNION_AGG( <column> )"},
	},
	"array_unique_agg": {
		Description: "Aggregate functions (Counting Distinct Values) , Window functions (Semi-structured Data Aggregation)",
		Signatures:  []string{"ARRAY_UNIQUE_AGG( <column> )"},
	},
	"arrays_overlap": {
		Description: "Semi-structured and structured data functions (Array/Object)",
		Signatures:  []string{"ARRAYS_OVERLAP( <array1> , <array2> )"},
	},
	"arrays_to_object": {
		Description: "Semi-structured and structured data functions (Array/Object)",
		Signatures:  []string{"ARRAYS_TO_OBJECT( <key_array> , <value_array> )"},
	},
	"arrays_zip": {
		Description: "Semi-structured and structured data functions (Array/Object Creation and Manipulation)",
		Signatures:  []string{"ARRAYS_ZIP( <array> [ , <array> ... ] )"},
	},
	"as_array": {
		Description: "Semi-structured and structured data functions (Cast)",
		Signatures:  []string{"AS_ARRAY( <variant_expr> )"},
	},
	"as_binary": {
		Description: "Semi-structured and structured data functions (Cast)",
		Signatures:  []string{"AS_BINARY( <variant_expr> )"},
	},
	"as_boolean": {
		Description: "Semi-structured and structured data functions (Cast)",
		Signatures:  []string{"AS_BOOLEAN( <variant_expr> )"},
	},
	"as_char": {
		Description: "Semi-structured and structured data functions (Cast)",
		Signatures:  []string{"AS_CHAR( <variant_expr> )\n\nAS_VARCHAR( <variant_expr> )"},
	},
	"as_date": {
		Description: "Semi-structured and structured data functions (Cast)",
		Signatures:  []string{"AS_DATE( <variant_expr> )"},
	},
	"as_decimal": {
		Description: "Semi-structured and structured data functions (Cast)",
		Signatures:  []string{"AS_DECIMAL( <variant_expr> [ , <precision> [ , <scale> ] ] )\n\nAS_NUMBER( <variant_expr> [ , <precision> [ , <scale> ] ] )"},
	},
	"as_double": {
		Description: "Semi-structured and structured data functions (Cast)",
		Signatures:  []string{"AS_DOUBLE( <variant_expr> )\n\nAS_REAL( <variant_expr> )"},
	},
	"as_integer": {
		Description: "Semi-structured and structured data functions (Cast)",
		Signatures:  []string{"AS_INTEGER( <variant_expr> )"},
	},
	"as_object": {
		Description: "Semi-structured and structured data functions (Cast)",
		Signatures:  []string{"AS_OBJECT( <variant_expr> )"},
	},
	"as_time": {
		Description: "Semi-structured and structured data functions (Cast)",
		Signatures:  []string{"AS_TIME( <variant_expr> )"},
	},
	"ascii": {
		Description: "String & binary functions (General)",
		Signatures:  []string{"ASCII( <input> )"},
	},
	"asin": {
		Description: "Numeric functions (Trigonometric)",
		Signatures:  []string{"ASIN( <input_expr> )"},
	},
	"asinh": {
		Description: "Numeric functions (Trigonometric)",
		Signatures:  []string{"ASINH( <input_expr> )"},
	},
	"atan": {
		Description: "Numeric functions (Trigonometric)",
		Signatures:  []string{"ATAN( <input_expr> )"},
	},
	"atan2": {
		Description: "Numeric functions (Trigonometric)",
		Signatures:  []string{"ATAN2( <y> , <x> )"},
	},
	"atanh": {
		Description: "Numeric functions (Trigonometric)",
		Signatures:  []string{"ATANH( <input_expr> )"},
	},
	"auto_refresh_registration_history": {
		Description: "Information Schema , Table functions",
		Signatures:  []string{"AUTO_REFRESH_REGISTRATION_HISTORY(\n      [ DATE_RANGE_START => <constant_expr> ]\n      [, DATE_RANGE_END => <constant_expr> ]\n      [, OBJECT_TYPE => '<string>' [, OBJECT_NAME => '<string>'] ])"},
	},
	"automatic_clustering_history": {
		Description: "Information Schema , Table functions",
		Signatures:  []string{"AUTOMATIC_CLUSTERING_HISTORY(\n      [ DATE_RANGE_START => <constant_expr> ]\n      [ , DATE_RANGE_END => <constant_expr> ]\n      [ , TABLE_NAME => '<string>' ] )"},
	},
	"available_listing_refresh_history": {
		Description: "Information Schema , Table functions",
		Signatures:  []string{"AVAILABLE_LISTING_REFRESH_HISTORY(\n  OBJECT_TYPE => '<object_type>',\n  OBJECT_NAME => '<object_name>' )"},
	},
	"avg": {
		Description: "Aggregate functions (General) , Window functions (General, Window Frame)",
		Signatures:  []string{"AVG( [ DISTINCT ] <expr1> )"},
	},
	"base64_decode_binary": {
		Description: "String & binary functions (Encoding/Decoding)",
		Signatures:  []string{"BASE64_DECODE_BINARY( <input> [ , <alphabet> ] )"},
	},
	"base64_decode_string": {
		Description: "String & binary functions (Encoding/Decoding)",
		Signatures:  []string{"BASE64_DECODE_STRING( <input> [ , <alphabet> ] )"},
	},
	"base64_encode": {
		Description: "String & binary functions (Encoding/Decoding)",
		Signatures:  []string{"BASE64_ENCODE( <input> [ , <max_line_length> ] [ , <alphabet> ] )"},
	},
	"bind_values": {
		Description: "Information Schema , Table functions",
		Signatures:  []string{"BIND_VALUES( <query_id> )"},
	},
	"bit_length": {
		Description: "String & binary functions (General)",
		Signatures:  []string{"BIT_LENGTH(<string_or_binary>)"},
	},
	"bitand": {
		Description: "Bitwise expression functions",
		Signatures:  []string{"BITAND( <expr1> , <expr2> [ , '<padside>' ] )"},
	},
	"bitand_agg": {
		Description: "Aggregate functions (Bitwise) , Window functions (General) , Bitwise expression functions",
		Signatures:  []string{"BITAND_AGG( <expr1> )"},
	},
	"bitmap_bit_position": {
		Description: "Aggregate functions (Counting Distinct Values)",
		Signatures:  []string{"BITMAP_BIT_POSITION( <numeric_expr> )"},
	},
	"bitmap_bucket_number": {
		Description: "Aggregate functions (Counting Distinct Values)",
		Signatures:  []string{"BITMAP_BUCKET_NUMBER( <numeric_expr> )"},
	},
	"bitmap_construct_agg": {
		Description: "Aggregate functions (Counting Distinct Values)",
		Signatures:  []string{"BITMAP_CONSTRUCT_AGG( <relative_position> )"},
	},
	"bitmap_count": {
		Description: "Aggregate functions (Counting Distinct Values)",
		Signatures:  []string{"BITMAP_COUNT( <bitmap> )"},
	},
	"bitmap_or_agg": {
		Description: "Aggregate functions (Counting Distinct Values)",
		Signatures:  []string{"BITMAP_OR_AGG( <bitmap> )"},
	},
	"bitnot": {
		Description: "Bitwise expression functions",
		Signatures:  []string{"BITNOT( <expr> )"},
	},
	"bitor": {
		Description: "Bitwise expression functions",
		Signatures:  []string{"BITOR( <expr1> , <expr2> [ , '<padside>' ] )"},
	},
	"bitor_agg": {
		Description: "Aggregate functions (Bitwise) , Window functions (General) , Bitwise expression functions",
		Signatures:  []string{"BITOR_AGG( <expr1> )"},
	},
	"bitshiftleft": {
		Description: "Bitwise expression functions",
		Signatures:  []string{"BITSHIFTLEFT( <expr1> , <n> )"},
	},
	"bitshiftright": {
		Description: "Bitwise expression functions",
		Signatures:  []string{"BITSHIFTRIGHT( <expr1> , <n> )"},
	},
	"bitxor": {
		Description: "Bitwise expression functions",
		Signatures:  []string{"BITXOR( <expr1> , <expr2> [ , '<padside>' ] )"},
	},
	"bitxor_agg": {
		Description: "Aggregate functions (Bitwise) , Window functions (General) , Bitwise expression functions",
		Signatures:  []string{"BITXOR_AGG( [ DISTINCT ] <expr1> )"},
	},
	"blank_count": {
		Description: "Data metric functions",
		Signatures:  []string{"SNOWFLAKE.CORE.BLANK_COUNT(<query>)"},
	},
	"blank_percent": {
		Description: "Data metric functions",
		Signatures:  []string{"SNOWFLAKE.CORE.BLANK_PERCENT(<query>)"},
	},
	"booland": {
		Description: "Conditional expression functions",
		Signatures:  []string{"BOOLAND( <expr1> , <expr2> )"},
	},
	"booland_agg": {
		Description: "Aggregate functions (Boolean) , Window functions , Conditional expression functions",
		Signatures:  []string{"BOOLAND_AGG( <expr> )"},
	},
	"boolnot": {
		Description: "Conditional expression functions",
		Signatures:  []string{"BOOLNOT( <expr> )"},
	},
	"boolor": {
		Description: "Conditional expression functions",
		Signatures:  []string{"BOOLOR( <expr1> , <expr2> )"},
	},
	"boolor_agg": {
		Description: "Aggregate functions (Boolean) , Window functions , Conditional expression functions",
		Signatures:  []string{"BOOLOR_AGG( <expr> )"},
	},
	"boolxor": {
		Description: "Conditional expression functions",
		Signatures:  []string{"BOOLXOR( <expr1> , <expr2> )"},
	},
	"boolxor_agg": {
		Description: "Aggregate functions (Boolean) , Window functions , Conditional expression functions",
		Signatures:  []string{"BOOLXOR_AGG( <expr> )"},
	},
	"build_scoped_file_url": {
		Description: "Generates a scoped Snowflake file URL to a staged file using the stage name and relative file path as inputs.",
		Signatures:  []string{"BUILD_SCOPED_FILE_URL(\n  @<stage_name> ,\n  '<relative_file_path>' ,\n  <use_privatelink_host_for_business_critical>)"},
	},
	"build_stage_file_url": {
		Description: "Generates a Snowflake file URL to a staged file using the stage name and relative file path as inputs. A file URL permits prolonged access to a specified file. That is, the file URL does not expire.",
		Signatures:  []string{"BUILD_STAGE_FILE_URL( @<stage_name> , '<relative_file_path>' )"},
	},
	"case": {
		Description: "Conditional expression functions",
		Signatures:  []string{"CASE\n    WHEN <condition1> THEN <result1>\n  [ WHEN <condition2> THEN <result2> ]\n  [ ... ]\n  [ ELSE <result3> ]\nEND\n\nCASE <expr>\n    WHEN <value1> THEN <result1>\n  [ WHEN <value2> THEN <result2> ]\n  [ ... ]\n  [ ELSE <result3> ]\nEND"},
	},
	"cast": {
		Description: "Converts a value of one data type into another data type. The semantics of CAST are the same as the semantics of the corresponding TO_ datatype conversion functions. If the cast is not possible, an...",
		Signatures:  []string{"CAST( <source_expr> AS <target_data_type> )\n  [ RENAME FIELDS | ADD FIELDS ]\n\n<source_expr> :: <target_data_type>"},
	},
	"cbrt": {
		Description: "Numeric functions (Exponent and Root)",
		Signatures:  []string{"CBRT( <input_expr> )"},
	},
	"ceil": {
		Description: "Numeric functions (Rounding and Truncation)",
		Signatures:  []string{"CEIL( <input_expr> [, <scale_expr> ] )"},
	},
	"charindex": {
		Description: "String & binary functions (Matching/Comparison)",
		Signatures:  []string{"CHARINDEX( <expr1>, <expr2> [ , <start_pos> ] )"},
	},
	"check_json": {
		Description: "Semi-structured and structured data functions (Parsing)",
		Signatures:  []string{"CHECK_JSON( <string_or_variant_expr> )"},
	},
	"check_xml": {
		Description: "Semi-structured and structured data functions (Parsing)",
		Signatures:  []string{"CHECK_XML( <string_containing_xml> [ , <disable_auto_convert> ] )"},
	},
	"chr": {
		Description: "String & binary functions (General)",
		Signatures:  []string{"CHR( <input> )"},
	},
	"classify_text": {
		Description: "String & binary functions (AI Functions)",
		Signatures:  []string{"SNOWFLAKE.CORTEX.CLASSIFY_TEXT( <input> , <list_of_categories>, [ <options> ] )"},
	},
	"coalesce": {
		Description: "Conditional expression functions",
		Signatures:  []string{"COALESCE( <expr1> , <expr2> [ , ... , <exprN> ] )"},
	},
	"collate": {
		Description: "String & binary functions",
		Signatures:  []string{"COLLATE(<string_expression>, '<collation_specification>')"},
	},
	"collation": {
		Description: "String & binary functions",
		Signatures:  []string{"COLLATION(<expression>)"},
	},
	"complete": {
		Description: "String & binary functions (AI Functions)",
		Signatures:  []string{"SNOWFLAKE.CORTEX.COMPLETE(\n    '<model>', '<prompt>', <file_object>)\nFROM <table>"},
	},
	"complete_task_graphs": {
		Description: "Information Schema , Table functions",
		Signatures:  []string{"COMPLETE_TASK_GRAPHS(\n      [ RESULT_LIMIT => <integer> ]\n      [, ROOT_TASK_NAME => '<string>' ]\n      [, ERROR_ONLY => { TRUE | FALSE } ] )"},
	},
	"compress": {
		Description: "String & binary functions (Compression/Decompression)",
		Signatures:  []string{"COMPRESS(<input>, <method>)"},
	},
	"concat": {
		Description: "String & binary functions (General)",
		Signatures:  []string{"CONCAT( <expr> [ , <expr> ... ] )\n\n<expr> || <expr> [ || <expr> ... ]"},
	},
	"concat_ws": {
		Description: "String & binary functions (General)",
		Signatures:  []string{"CONCAT_WS( <separator> , <expression1> [ , <expressionN> ... ] )"},
	},
	"conditional_change_event": {
		Description: "Window functions (General)",
		Signatures:  []string{"CONDITIONAL_CHANGE_EVENT( <expr1> ) OVER ( [ PARTITION BY <expr2> ] ORDER BY <expr3> )"},
	},
	"conditional_true_event": {
		Description: "Window functions (General)",
		Signatures:  []string{"CONDITIONAL_TRUE_EVENT( <expr1> ) OVER ( [ PARTITION BY <expr2> ] ORDER BY <expr3> )"},
	},
	"contains": {
		Description: "String & binary functions (Matching/Comparison)",
		Signatures:  []string{"CONTAINS( <expr1> , <expr2> )"},
	},
	"convert_timezone": {
		Description: "Date & time functions",
		Signatures:  []string{"CONVERT_TIMEZONE( <source_tz> , <target_tz> , <source_timestamp_ntz> )\n\nCONVERT_TIMEZONE( <target_tz> , <source_timestamp> )"},
	},
	"copy_history": {
		Description: "Information Schema , Table functions",
		Signatures:  []string{"COPY_HISTORY(\n      TABLE_NAME => '<string>'\n       , START_TIME => <constant_expr>\n      [, END_TIME => <constant_expr> ]\n      [, PIPE_NAME => '<string>' ] )"},
	},
	"corr": {
		Description: "Aggregate functions (General) , Window functions (General)",
		Signatures:  []string{"CORR( y , x )"},
	},
	"cortex_search_data_scan": {
		Description: "This table function returns the data indexed by a Cortex Search service, including the columns defined in the source query and the computed vector embeddings for the search column.",
		Signatures:  []string{"CORTEX_SEARCH_DATA_SCAN(\n      SERVICE_NAME => '<string>' )"},
	},
	"cos": {
		Description: "Numeric functions (Trigonometric)",
		Signatures:  []string{"COS( <input_expr> )"},
	},
	"cosh": {
		Description: "Numeric functions (Trigonometric)",
		Signatures:  []string{"COSH( <input_expr> )"},
	},
	"cot": {
		Description: "Numeric functions (Trigonometric)",
		Signatures:  []string{"COT( <input_expr> )"},
	},
	"count": {
		Description: "Aggregate functions (General) , Window functions",
		Signatures:  []string{"COUNT( [ DISTINCT ] <expr1> [ , <expr2> ... ] )\n\nCOUNT(*)\n\nCOUNT(<alias>.*)"},
	},
	"count_if": {
		Description: "Aggregate functions (General) , Window functions",
		Signatures:  []string{"COUNT_IF( <condition> )"},
	},
	"count_tokens": {
		Description: "String & binary functions (AI Functions)",
		Signatures:  []string{"SNOWFLAKE.CORTEX.COUNT_TOKENS( <model_name> , <input_text> )"},
	},
	"covar_pop": {
		Description: "Aggregate functions (General) , Window functions (General)",
		Signatures:  []string{"COVAR_POP( y , x )"},
	},
	"covar_samp": {
		Description: "Aggregate functions (General) , Window functions (General)",
		Signatures:  []string{"COVAR_SAMP( y , x )"},
	},
	"cume_dist": {
		Description: "Window functions (Ranking)",
		Signatures:  []string{"CUME_DIST() OVER ( [ PARTITION BY <partition_expr> ] ORDER BY <order_expr>  [ ASC | DESC ] )"},
	},
	"cumulative_privacy_losses": {
		Description: "Enterprise Edition Feature",
		Signatures:  []string{"SNOWFLAKE.DATA_PRIVACY.CUMULATIVE_PRIVACY_LOSSES( '<privacy_policy>' )"},
	},
	"current_account": {
		Description: "Context functions (Session)",
		Signatures:  []string{"CURRENT_ACCOUNT()"},
	},
	"current_account_name": {
		Description: "Context functions (Session)",
		Signatures:  []string{"CURRENT_ACCOUNT_NAME()"},
	},
	"current_available_roles": {
		Description: "Returns a list of all account-level roles granted to the current user. The list includes all roles that are granted directly to the user plus all account-level roles lower in the hierarchies of the...",
		Signatures:  []string{"CURRENT_AVAILABLE_ROLES()"},
	},
	"current_client": {
		Description: "Context functions (General)",
		Signatures:  []string{"CURRENT_CLIENT()"},
	},
	"current_database": {
		Description: "Context functions (Session Object)",
		Signatures:  []string{"CURRENT_DATABASE()"},
	},
	"current_date": {
		Description: "Context functions (General)",
		Signatures:  []string{"CURRENT_DATE()\n\nCURRENT_DATE"},
	},
	"current_ip_address": {
		Description: "Returns the IP address of the client that submitted the request.",
		Signatures:  []string{"CURRENT_IP_ADDRESS()"},
	},
	"current_organization_name": {
		Description: "Context functions (Session)",
		Signatures:  []string{"CURRENT_ORGANIZATION_NAME()"},
	},
	"current_organization_user": {
		Description: "Context functions (Session)",
		Signatures:  []string{"CURRENT_ORGANIZATION_USER()"},
	},
	"current_region": {
		Description: "Context functions (General)",
		Signatures:  []string{"CURRENT_REGION()"},
	},
	"current_role": {
		Description: "Context functions (Session Object)",
		Signatures:  []string{"CURRENT_ROLE()"},
	},
	"current_role_type": {
		Description: "Context functions (Session Object)",
		Signatures:  []string{"CURRENT_ROLE_TYPE()"},
	},
	"current_schema": {
		Description: "Context functions (Session Object)",
		Signatures:  []string{"CURRENT_SCHEMA()"},
	},
	"current_schemas": {
		Description: "Context functions (Session Object)",
		Signatures:  []string{"CURRENT_SCHEMAS()"},
	},
	"current_secondary_roles": {
		Description: "Context functions (Session Object)",
		Signatures:  []string{"CURRENT_SECONDARY_ROLES()"},
	},
	"current_session": {
		Description: "Context functions (Session)",
		Signatures:  []string{"CURRENT_SESSION()"},
	},
	"current_statement": {
		Description: "Context functions (Session)",
		Signatures:  []string{"CURRENT_STATEMENT()"},
	},
	"current_task_graphs": {
		Description: "Information Schema , Table functions",
		Signatures:  []string{"CURRENT_TASK_GRAPHS(\n      [ RESULT_LIMIT => <integer> ]\n      [, ROOT_TASK_NAME => '<string>' ] )"},
	},
	"current_time": {
		Description: "Context functions (General)",
		Signatures:  []string{"CURRENT_TIME( [ <fract_sec_precision> ] )\n\nCURRENT_TIME"},
	},
	"current_timestamp": {
		Description: "Context functions (General)",
		Signatures:  []string{"CURRENT_TIMESTAMP( [ <fract_sec_precision> ] )\n\nCURRENT_TIMESTAMP"},
	},
	"current_transaction": {
		Description: "Context functions (Session)",
		Signatures:  []string{"CURRENT_TRANSACTION()"},
	},
	"current_user": {
		Description: "Context functions (Session)",
		Signatures:  []string{"CURRENT_USER()\n\nCURRENT_USER"},
	},
	"current_version": {
		Description: "Context functions (General)",
		Signatures:  []string{"CURRENT_VERSION()"},
	},
	"current_warehouse": {
		Description: "Context functions (Session Object)",
		Signatures:  []string{"CURRENT_WAREHOUSE()"},
	},
	"data_metric_function_expectations": {
		Description: "Information Schema , Table functions",
		Signatures:  []string{"DATA_METRIC_FUNCTION_EXPECTATIONS(\n  [ METRIC_NAME => '<string>' ]\n  [, REF_ENTITY_NAME => '<string>' ]\n  [, REF_ENTITY_DOMAIN => '<string>' ]\n)"},
	},
	"data_metric_function_references": {
		Description: "Information Schema , Table functions",
		Signatures:  []string{"DATA_METRIC_FUNCTION_REFERENCES(\n  METRIC_NAME => '<string>' )\n\nDATA_METRIC_FUNCTION_REFERENCES(\n  REF_ENTITY_NAME => '<string>' ,\n  REF_ENTITY_DOMAIN => '<string>'\n  )"},
	},
	"data_metric_scheduled_time": {
		Description: "Data metric functions",
		Signatures:  []string{"SNOWFLAKE.CORE.DATA_METRIC_SCHEDULED_TIME()"},
	},
	"data_quality_monitoring_expectation_status": {
		Description: "LOCAL schema , Table functions",
		Signatures:  []string{"DATA_QUALITY_MONITORING_EXPECTATION_STATUS(\n  REF_ENTITY_NAME => '<string>' ,\n  REF_ENTITY_DOMAIN => '<string>'\n  )"},
	},
	"data_quality_monitoring_results": {
		Description: "LOCAL schema , Table functions",
		Signatures:  []string{"DATA_QUALITY_MONITORING_RESULTS(\n  REF_ENTITY_NAME => '<string>' ,\n  REF_ENTITY_DOMAIN => '<string>'\n  )"},
	},
	"data_transfer_history": {
		Description: "Information Schema , Table functions",
		Signatures:  []string{"DATA_TRANSFER_HISTORY(\n      [ DATE_RANGE_START => <constant_expr> ]\n      [, DATE_RANGE_END => <constant_expr> ] )"},
	},
	"database_refresh_history": {
		Description: "Information Schema , Table functions",
		Signatures:  []string{"DATABASE_REFRESH_HISTORY( '<secondary_db_name>' )"},
	},
	"database_refresh_progress": {
		Description: "Information Schema , Table functions",
		Signatures:  []string{"DATABASE_REFRESH_PROGRESS( '<secondary_db_name>' )\n\nDATABASE_REFRESH_PROGRESS_BY_JOB( '<query_id>' )"},
	},
	"database_replication_usage_history": {
		Description: "Information Schema , Table functions",
		Signatures:  []string{"DATABASE_REPLICATION_USAGE_HISTORY(\n  [ DATE_RANGE_START => <constant_expr> ]\n  [ , DATE_RANGE_END => <constant_expr> ]\n  [ , DATABASE_NAME => '<string>' ] )"},
	},
	"database_storage_usage_history": {
		Description: "Information Schema , Table functions",
		Signatures:  []string{"DATABASE_STORAGE_USAGE_HISTORY(\n      [ DATE_RANGE_START => <constant_expr> ]\n      [, DATE_RANGE_END => <constant_expr> ]\n      [, DATABASE_NAME => '<string>' ] )"},
	},
	"datasketches_hll": {
		Description: "Aggregate functions (Cardinality Estimation) , Window functions",
		Signatures:  []string{"DATASKETCHES_HLL( [ DISTINCT ] <expr1> [ , <max_log_k> ] )"},
	},
	"datasketches_hll_accumulate": {
		Description: "Aggregate functions (Cardinality Estimation) , Window function syntax and usage",
		Signatures:  []string{"DATASKETCHES_HLL_ACCUMULATE( [ DISTINCT ] <expr> [ , <max_log_k> ] )"},
	},
	"datasketches_hll_combine": {
		Description: "Aggregate functions (Cardinality Estimation) , Window function syntax and usage",
		Signatures:  []string{"DATASKETCHES_HLL_COMBINE( [ DISTINCT ]  <state> [ , <max_log_k> ] )"},
	},
	"datasketches_hll_estimate": {
		Description: "Aggregate functions (Cardinality Estimation) , Window function syntax and usage",
		Signatures:  []string{"DATASKETCHES_HLL_ESTIMATE( <binary_sketch> )"},
	},
	"date_from_parts": {
		Description: "Date & time functions",
		Signatures:  []string{"DATE_FROM_PARTS( <year>, <month>, <day> )"},
	},
	"date_part": {
		Description: "Date & time functions",
		Signatures:  []string{"DATE_PART( <date_or_time_part> , <date_time_or_timestamp_expr> )"},
	},
	"date_trunc": {
		Description: "Date & time functions",
		Signatures:  []string{"DATE_TRUNC( <date_or_time_part>, <date_or_time_expr> )"},
	},
	"dateadd": {
		Description: "Date & time functions",
		Signatures:  []string{"DATEADD( <date_or_time_part>, <value>, <date_or_time_expr> )"},
	},
	"datediff": {
		Description: "Date & time functions",
		Signatures:  []string{"DATEDIFF( <date_or_time_part>, <date_or_time_expr1>, <date_or_time_expr2> )"},
	},
	"dayname": {
		Description: "Date & time functions",
		Signatures:  []string{"DAYNAME( <date_or_timestamp_expr> )"},
	},
	"dbt_project_execution_history": {
		Description: "Information Schema , Table functions",
		Signatures:  []string{"DBT_PROJECT_EXECUTION_HISTORY (\n  [ OBJECT_NAME => '<name>' ]\n  [ , OBJECT_TYPE = { WORKSPACE | DBT PROJECT }]\n  [ , START_TIME_RANGE_START => <start_time> ]\n  [ , START_TIME_RANGE_END => <end_time>  ]\n  [ , RESULT_LIMIT = <integer> ]\n  [ , COMMAND = <dbt_command> ]\n  [ , USER_NAME = <user_name> ]\n  [ , DATABASE = <db_name> ]\n  [ , SCHEMA = <schema_name> ]\n)"},
	},
	"decode": {
		Description: "Conditional expression functions",
		Signatures:  []string{"DECODE( <expr> , <search1> , <result1> [ , <search2> , <result2> ... ] [ , <default> ] )"},
	},
	"decompress_binary": {
		Description: "String & binary functions (Compression/Decompression)",
		Signatures:  []string{"DECOMPRESS_BINARY(<input>, <method>)"},
	},
	"decompress_string": {
		Description: "String & binary functions (Compression/Decompression)",
		Signatures:  []string{"DECOMPRESS_STRING(<input>, <method>)"},
	},
	"decrypt": {
		Description: "Decrypts a BINARY value using a VARCHAR passphrase.",
		Signatures:  []string{"DECRYPT( <value_to_decrypt> , <passphrase> ,\n         [ [ <additional_authenticated_data> , ] <encryption_method> ]\n       )"},
	},
	"decrypt_raw": {
		Description: "Decrypts a BINARY value using a BINARY key.",
		Signatures:  []string{"DECRYPT_RAW( <value_to_decrypt> , <key> , <iv> ,\n         [ [ [ <additional_authenticated_data> , ] <encryption_method> , ] <aead_tag> ]\n       )"},
	},
	"degrees": {
		Description: "Numeric functions (Trigonometric)",
		Signatures:  []string{"DEGREES( <input_expr> )"},
	},
	"dense_rank": {
		Description: "Window function syntax and usage (Ranking)",
		Signatures:  []string{"DENSE_RANK() OVER ( [ PARTITION BY <expr1> ] ORDER BY <expr2> [ ASC | DESC ] [ <window_frame> ] )"},
	},
	"div0": {
		Description: "Performs division like the division operator (/), but returns 0 when the divisor is 0 (rather than reporting an error).",
		Signatures:  []string{"DIV0( <dividend> , <divisor> )"},
	},
	"div0null": {
		Description: "Performs division like the division operator (/), but returns 0 when the divisor is 0 or NULL (rather than reporting an error or returning NULL).",
		Signatures:  []string{"DIV0NULL( <dividend> , <divisor> )"},
	},
	"dp_interval_high": {
		Description: "Differential privacy functions",
		Signatures:  []string{"DP_INTERVAL_HIGH( <aggregated_column> )"},
	},
	"dp_interval_low": {
		Description: "Differential privacy functions",
		Signatures:  []string{"DP_INTERVAL_LOW( <aggregated_column> )"},
	},
	"duplicate_count": {
		Description: "Data metric functions",
		Signatures:  []string{"SNOWFLAKE.CORE.DUPLICATE_COUNT(<query>)"},
	},
	"dynamic_table_graph_history": {
		Description: "Information Schema , Table functions",
		Signatures:  []string{"DYNAMIC_TABLE_GRAPH_HISTORY(\n  [ AS_OF => <constant_expr> ]\n  [ , HISTORY_START => <constant_expr> [ , HISTORY_END => <constant_expr> ] ]\n)"},
	},
	"dynamic_table_refresh_history": {
		Description: "Information Schema , Table functions",
		Signatures:  []string{"DYNAMIC_TABLE_REFRESH_HISTORY(\n  [ DATA_TIMESTAMP_START => <constant_expr> ]\n  [ , DATA_TIMESTAMP_END => <constant_expr> ]\n  [ , RESULT_LIMIT => <integer> ]\n  [ , NAME => '<string>' ]\n  [ , NAME_PREFIX => '<string>' ]\n  [ , ERROR_ONLY => { TRUE | FALSE } ]\n)"},
	},
	"dynamic_tables": {
		Description: "Information Schema , Table functions",
		Signatures:  []string{"DYNAMIC_TABLES (\n  [ NAME => '<string>' ]\n  [ , REFRESH_DATA_TIMESTAMP_START => <constant_expr> ]\n  [ , RESULT_LIMIT => <integer> ]\n  [ , INCLUDE_CONNECTED => { TRUE | FALSE } ]\n)"},
	},
	"editdistance": {
		Description: "String & binary functions (Matching/Comparison)",
		Signatures:  []string{"EDITDISTANCE( <string_expr1> , <string_expr2> [ , <max_distance> ] )"},
	},
	"email_integration_config": {
		Description: "Notification functions (Integration Configuration)",
		Signatures:  []string{"SNOWFLAKE.NOTIFICATION.EMAIL_INTEGRATION_CONFIG(\n  '<email_integration_name>',\n  '<subject>',\n  <array_of_email_addresses_for_to_line> )"},
	},
	"embed_text_1024": {
		Description: "String & binary functions (AI Functions)",
		Signatures:  []string{"SNOWFLAKE.CORTEX.EMBED_TEXT_1024( <model>, <text> )"},
	},
	"embed_text_768": {
		Description: "String & binary functions (AI Functions)",
		Signatures:  []string{"SNOWFLAKE.CORTEX.EMBED_TEXT_768( <model>, <text> )"},
	},
	"encrypt": {
		Description: "Encrypts a VARCHAR or BINARY value using a VARCHAR passphrase.",
		Signatures:  []string{"ENCRYPT( <value_to_encrypt> , <passphrase> ,\n         [ [ <additional_authenticated_data> , ] <encryption_method> ]\n       )"},
	},
	"encrypt_raw": {
		Description: "Encrypts a BINARY value using a BINARY key.",
		Signatures:  []string{"ENCRYPT_RAW( <value_to_encrypt> , <key> , <iv> ,\n         [ [ <additional_authenticated_data> , ] <encryption_method> ]\n       )"},
	},
	"endswith": {
		Description: "String & binary functions (Matching/Comparison)",
		Signatures:  []string{"ENDSWITH( <expr1> , <expr2> )"},
	},
	"entity_sentiment": {
		Description: "String & binary functions (AI Functions)",
		Signatures:  []string{"SNOWFLAKE.CORTEX.ENTITY_SENTIMENT(<text> [, <entities> ])"},
	},
	"equal_null": {
		Description: "Conditional expression functions",
		Signatures:  []string{"EQUAL_NULL( <expr1> , <expr2> )"},
	},
	"estimate_remaining_dp_aggregates": {
		Description: "Differential privacy functions , Table functions",
		Signatures:  []string{"SNOWFLAKE.DATA_PRIVACY.ESTIMATE_REMAINING_DP_AGGREGATES('<table_name>')"},
	},
	"exp": {
		Description: "Numeric functions (Exponent and Root)",
		Signatures:  []string{"EXP( <input_expr> )"},
	},
	"explain_json": {
		Description: "This function converts an EXPLAIN plan from JSON to a table. The output is the same as the output of the command EXPLAIN USING TABULAR <statement>.",
		Signatures:  []string{"EXPLAIN_JSON( <explain_output_in_json_format> )"},
	},
	"external_functions_history": {
		Description: "Information Schema , Table functions",
		Signatures:  []string{"EXTERNAL_FUNCTIONS_HISTORY(\n      [ DATE_RANGE_START => <constant_date_expression> ]\n      [, DATE_RANGE_END => <constant_date_expression> ]\n      [, FUNCTION_SIGNATURE => '<string>' ] )"},
	},
	"external_table_file_registration_history": {
		Description: "Information Schema , Table functions",
		Signatures:  []string{"EXTERNAL_TABLE_FILE_REGISTRATION_HISTORY (\n      TABLE_NAME => '<string>'\n      [, START_TIME => <constant_expr> ] )"},
	},
	"external_table_files": {
		Description: "Information Schema , Table functions",
		Signatures:  []string{"EXTERNAL_TABLE_FILES(\n      TABLE_NAME => '<string>' )"},
	},
	"extract": {
		Description: "Date & time functions",
		Signatures:  []string{"EXTRACT( <date_or_time_part> FROM <date_time_or_timestamp_expr> )"},
	},
	"extract_answer": {
		Description: "String & binary functions (AI Functions)",
		Signatures:  []string{"SNOWFLAKE.CORTEX.EXTRACT_ANSWER(\n    <source_document>, <question>)"},
	},
	"extract_semantic_categories": {
		Description: "Enterprise Edition Feature",
		Signatures:  []string{"EXTRACT_SEMANTIC_CATEGORIES( '<object_name>' [ , <max_rows_to_scan> ] )"},
	},
	"factorial": {
		Description: "Numeric functions (Exponent and Root)",
		Signatures:  []string{"FACTORIAL( <integer_expr> )"},
	},
	"filter": {
		Description: "Semi-structured and structured data functions (Higher-order)",
		Signatures:  []string{"FILTER( <array> , <lambda_expression> )"},
	},
	"finetune": {
		Description: "Feature â€” Generally Available",
		Signatures:  []string{"SNOWFLAKE.CORTEX.FINETUNE(\n  'CANCEL',\n  '<finetune_job_id>'\n)"},
	},
	"first_value": {
		Description: "Window function syntax and usage (Ranking)",
		Signatures:  []string{"FIRST_VALUE( <expr> ) [ { IGNORE | RESPECT } NULLS ]\n  OVER ( [ PARTITION BY <expr1> ] ORDER BY <expr2>  [ { ASC | DESC } ] [ <window_frame> ] )"},
	},
	"fl_get_content_type": {
		Description: "Returns the content type (also known as the MIME type) of a FILE.",
		Signatures:  []string{"FL_GET_CONTENT_TYPE( <file_expression> )\n\nFL_GET_CONTENT_TYPE( <variant_expression> )"},
	},
	"fl_get_etag": {
		Description: "Returns the content hash (ETAG) of a FILE.",
		Signatures:  []string{"FL_GET_ETAG( <file_expression> )\n\nFL_GET_ETAG( <variant_expression> )"},
	},
	"fl_get_file_type": {
		Description: "Returns the file type (modality) of a FILE. This is a more general classification than the content type (see FL_GET_CONTENT_TYPE).",
		Signatures:  []string{"FL_GET_FILE_TYPE( <file_expression> )\n\nFL_GET_FILE_TYPE( <variant_expression> )"},
	},
	"fl_get_last_modified": {
		Description: "Returns the last modified date of a FILE.",
		Signatures:  []string{"FL_GET_LAST_MODIFIED( <file_expression> )\n\nFL_GET_LAST_MODIFIED( <variant_expression> )"},
	},
	"fl_get_relative_path": {
		Description: "Returns the relative path of a FILE.",
		Signatures:  []string{"FL_GET_RELATIVE_PATH( <file_expression> )\n\nFL_GET_RELATIVE_PATH( <variant_expression> )"},
	},
	"fl_get_scoped_file_url": {
		Description: "Returns the scoped URL of a FILE.",
		Signatures:  []string{"FL_GET_SCOPED_FILE_URL( <file_expression> )\n\nFL_GET_SCOPED_FILE_URL( <variant_expression> )"},
	},
	"fl_get_size": {
		Description: "Returns the size, in bytes, of a FILE.",
		Signatures:  []string{"FL_GET_SIZE( <file_expression> )\n\nFL_GET_SIZE( <variant_expression> )"},
	},
	"fl_get_stage": {
		Description: "Returns the stage name of a FILE.",
		Signatures:  []string{"FL_GET_STAGE( <file_expression> )\n\nFL_GET_STAGE( <variant_expression> )"},
	},
	"fl_get_stage_file_url": {
		Description: "Returns the stage URL of a FILE.",
		Signatures:  []string{"FL_GET_STAGE_FILE_URL( <file_expression> )\n\nFL_GET_STAGE_FILE_URL( <variant_expression> )"},
	},
	"fl_is_audio": {
		Description: "Checks if the input is an audio FILE.",
		Signatures:  []string{"FL_IS_AUDIO( <file_expression> )\n\nFL_IS_AUDIO( <variant_expression> )"},
	},
	"fl_is_compressed": {
		Description: "Checks if the input is a compressed FILE.",
		Signatures:  []string{"FL_IS_COMPRESSED( <file_expression> )\n\nFL_IS_COMPRESSED( <variant_expression> )"},
	},
	"fl_is_document": {
		Description: "Checks if the input is a document FILE.",
		Signatures:  []string{"FL_IS_DOCUMENT( <file_expression> )\n\nFL_IS_DOCUMENT( <variant_expression> )"},
	},
	"fl_is_image": {
		Description: "Checks if the input is an image FILE.",
		Signatures:  []string{"FL_IS_IMAGE( <file_expression> )\n\nFL_IS_IMAGE( <variant_expression> )"},
	},
	"fl_is_video": {
		Description: "Checks if the input is a video FILE.",
		Signatures:  []string{"FL_IS_VIDEO( <file_expression> )\n\nFL_IS_VIDEO( <variant_expression> )"},
	},
	"flatten": {
		Description: "Table functions , Semi-structured and structured data functions (Extraction)",
		Signatures:  []string{"FLATTEN( INPUT => <expr> [ , PATH => <constant_expr> ]\n                         [ , OUTER => TRUE | FALSE ]\n                         [ , RECURSIVE => TRUE | FALSE ]\n                         [ , MODE => 'OBJECT' | 'ARRAY' | 'BOTH' ] )"},
	},
	"floor": {
		Description: "Numeric functions (Rounding and Truncation)",
		Signatures:  []string{"FLOOR( <input_expr> [, <scale_expr> ] )"},
	},
	"freshness": {
		Description: "Data metric functions",
		Signatures:  []string{"SNOWFLAKE.CORE.FRESHNESS( [ <query> ] )"},
	},
	"generate_column_description": {
		Description: "Generates a list of columns from a set of staged files that contain semi-structured data using the INFER_SCHEMA function output.",
		Signatures:  []string{"GENERATE_COLUMN_DESCRIPTION( <expr> , '<string>' )"},
	},
	"generator": {
		Description: "Creates rows of data based either on a specified number of rows, a specified generation period (in seconds), or both. This system-defined table function enables synthetic row generation.",
		Signatures:  []string{"GENERATOR( ROWCOUNT => <count> [ , TIMELIMIT => <sec> ] )\n\nGENERATOR( [ TIMELIMIT => <sec> ] )"},
	},
	"get": {
		Description: "Semi-structured and structured data functions (Extraction)",
		Signatures:  []string{"GET( <array> , <index> )\n\nGET( <variant> , <index> )"},
	},
	"get_absolute_path": {
		Description: "Retrieves the absolute path of a staged file using the stage name and path of the file relative to its location in the stage as inputs.",
		Signatures:  []string{"GET_ABSOLUTE_PATH( @<stage_name> , '<relative_file_path>' )"},
	},
	"get_anaconda_packages_repodata": {
		Description: "System functions (System Information)",
		Signatures:  []string{"SNOWFLAKE.SNOWPARK.GET_ANACONDA_PACKAGES_REPODATA( '<architecture>' )"},
	},
	"get_condition_query_uuid": {
		Description: "Context functions (Alerts)",
		Signatures:  []string{"SNOWFLAKE.ALERT.GET_CONDITION_QUERY_UUID()"},
	},
	"get_contacts": {
		Description: "Returns the contacts associated with an object.",
		Signatures:  []string{"SNOWFLAKE.CORE.GET_CONTACTS (\n  '<object_name>',\n  '<object_type>'\n  [ , '<contact_name>' ]\n)"},
	},
	"get_ddl": {
		Description: "Returns a DDL statement that can be used to recreate the specified object. For databases and schemas, GET_DDL is recursive (that is, it returns the DDL statements for recreating all supported objec...",
		Signatures:  []string{"GET_DDL( '<object_type>' , '[<namespace>.]<object_name>' [ , <use_fully_qualified_names_for_recreated_objects> ] )"},
	},
	"get_ignore_case": {
		Description: "Semi-structured and structured data functions (Extraction)",
		Signatures:  []string{"GET_IGNORE_CASE( <object> , <field_name> )\n\nGET_IGNORE_CASE( <variant> , <field_name> )"},
	},
	"get_job_history": {
		Description: "Returns the job history for Snowpark Container Services jobs that ran within the specified time range. The function returns both the running and deleted job.",
		Signatures:  []string{"SNOWFLAKE.SPCS.GET_JOB_HISTORY(\n  [ CREATED_TIME_START => <constant_expr> ],\n  [ CREATED_TIME_END => <constant_expr> ],\n  [ RESULT_LIMIT = <integer> ])"},
	},
	"get_lineage": {
		Description: "Enterprise Edition Feature",
		Signatures:  []string{"SNOWFLAKE.CORE.GET_LINEAGE(\n    '<object_name>',\n    '<object_domain>',\n    '<direction>',\n    [ <distance>, ]\n    [ '<object_version>' ]\n)"},
	},
	"get_object_references": {
		Description: "Table functions (Object Modeling)",
		Signatures:  []string{"GET_OBJECT_REFERENCES(\n  DATABASE_NAME => '<string>'\n  , SCHEMA_NAME => '<string>'\n  , OBJECT_NAME => '<string>' )"},
	},
	"get_path": {
		Description: "Semi-structured and structured data functions (Extraction)",
		Signatures:  []string{"GET_PATH( <column_identifier> , '<path_name>' )\n\n<column_identifier>:<path_name>\n\n:( <column_identifier> , '<path_name>' )"},
	},
	"get_presigned_url": {
		Description: "Generates a pre-signed URL to a file on a stage using the stage name and relative file path as inputs.",
		Signatures:  []string{"GET_PRESIGNED_URL( @<stage_name> , '<relative_file_path>' , [ <expiration_time> ] )"},
	},
	"get_python_profiler_output": {
		Description: "System functions (System Information)",
		Signatures:  []string{"SNOWFLAKE.CORE.GET_PYTHON_PROFILER_OUTPUT(<query_id>)"},
	},
	"get_query_operator_stats": {
		Description: "System functions (Query Information) , Table functions",
		Signatures:  []string{"GET_QUERY_OPERATOR_STATS( <query_id> )"},
	},
	"get_relative_path": {
		Description: "Extracts the path of a staged file relative to its location in the stage using the stage name and absolute file path in cloud storage as inputs.",
		Signatures:  []string{"GET_RELATIVE_PATH( @<stage_name> , '<absolute_file_path>' )"},
	},
	"get_stage_location": {
		Description: "Retrieves the URL for an external or internal named stage using the stage name as the input.",
		Signatures:  []string{"GET_STAGE_LOCATION( @<stage_name> )"},
	},
	"getbit": {
		Description: "Bitwise expression functions",
		Signatures:  []string{"GETBIT( <integer_expr>, <bit_position> )"},
	},
	"getdate": {
		Description: "Context functions (General)",
		Signatures:  []string{"GETDATE()"},
	},
	"getvariable": {
		Description: "Context functions (Session)",
		Signatures:  []string{"GETVARIABLE( '<name>' )"},
	},
	"greatest": {
		Description: "Conditional expression functions",
		Signatures:  []string{"GREATEST( <expr1> [ , <expr2> ... ] )"},
	},
	"greatest_ignore_nulls": {
		Description: "Conditional expression functions",
		Signatures:  []string{"GREATEST_IGNORE_NULLS( <expr1> [ , <expr2> ... ] )"},
	},
	"grouping": {
		Description: "Aggregate functions (General)",
		Signatures:  []string{"GROUPING( <expr1> [ , <expr2> , ... ] )"},
	},
	"grouping_id": {
		Description: "Aggregate functions (General)",
		Signatures:  []string{"GROUPING_ID( <expr1> [ , <expr2> , ... ] )"},
	},
	"h3_cell_to_boundary": {
		Description: "Returns the GEOGRAPHY object representing the boundary of an H3 cell.",
		Signatures:  []string{"H3_CELL_TO_BOUNDARY( <cell_id> )"},
	},
	"h3_cell_to_children": {
		Description: "Returns an array of the INTEGER IDs of the children of an H3 cell for a given resolution.",
		Signatures:  []string{"H3_CELL_TO_CHILDREN( <cell_id> , <target_resolution> )"},
	},
	"h3_cell_to_children_string": {
		Description: "Returns an array of the VARCHAR values containing the hexadecimal IDs of the children of an H3 cell for a given resolution.",
		Signatures:  []string{"H3_CELL_TO_CHILDREN_STRING( <cell_id> , <target_resolution> )"},
	},
	"h3_cell_to_parent": {
		Description: "Returns the ID of the parent of an H3 cell for a given resolution. The ID is returned as an INTEGER value (if an INTEGER value was provided as the input ID) or as a VARCHAR containing the hexadecim...",
		Signatures:  []string{"H3_CELL_TO_PARENT( <cell_id> , <target_resolution> )"},
	},
	"h3_cell_to_point": {
		Description: "Returns the GEOGRAPHY object representing the Point that is the centroid of an H3 cell.",
		Signatures:  []string{"H3_CELL_TO_POINT( <cell_id> )"},
	},
	"h3_compact_cells": {
		Description: "Returns an array of VARIANT values that contain the INTEGER IDs of fewer, larger H3 cells that cover the same area as the H3 cells in the input. For information about compacted cells, see Indexing.",
		Signatures:  []string{"H3_COMPACT_CELLS( <array_of_cell_ids> )"},
	},
	"h3_compact_cells_strings": {
		Description: "Returns an array of VARIANT values that contain the VARCHAR hexadecimal IDs of fewer, larger H3 cells that cover the same area as the H3 cells in the input. For information about compacted cells, s...",
		Signatures:  []string{"H3_COMPACT_CELLS_STRINGS( <array_of_cell_ids> )"},
	},
	"h3_coverage": {
		Description: "Returns an array of IDs (as INTEGER values) identifying the minimal set of H3 cells that completely cover a shape (specified by a GEOGRAPHY object).",
		Signatures:  []string{"H3_COVERAGE( <geography_expression> , <target_resolution> )"},
	},
	"h3_coverage_strings": {
		Description: "Returns an array of hexadecimal IDs (as VARCHAR values) identifying the minimal set of H3 cells that completely cover a shape (specified by a GEOGRAPHY object).",
		Signatures:  []string{"H3_COVERAGE_STRINGS( <geography_expression> , <target_resolution> )"},
	},
	"h3_get_resolution": {
		Description: "Returns the resolution of an H3 cell.",
		Signatures:  []string{"H3_GET_RESOLUTION( <cell_id> )"},
	},
	"h3_grid_disk": {
		Description: "Returns an array of the IDs of the H3 cells that are within the k-distance from the specified cell. The IDs in the returned ARRAY are INTEGER values (if an INTEGER value was provided as the input I...",
		Signatures:  []string{"H3_GRID_DISK( <cell_id> , <k_value> )"},
	},
	"h3_grid_distance": {
		Description: "Returns the distance between two H3 cells specified by their IDs.",
		Signatures:  []string{"H3_GRID_DISTANCE( <cell_id_1> , <cell_id_2> )"},
	},
	"h3_grid_path": {
		Description: "Returns an array of the IDs of the H3 cells that represent the line between two cells. The IDs in the returned ARRAY are INTEGER values (if INTEGER values were provided as the input IDs) or VARCHAR...",
		Signatures:  []string{"H3_GRID_PATH( <cell_id_1> , <cell_id_2> )"},
	},
	"h3_int_to_string": {
		Description: "Converts the INTEGER value of an H3 cell ID to hexadecimal format.",
		Signatures:  []string{"H3_INT_TO_STRING( <cell_id> )"},
	},
	"h3_is_pentagon": {
		Description: "Returns TRUE if the boundary of an H3 cell represents a pentagon.",
		Signatures:  []string{"H3_IS_PENTAGON( <cell_id> )"},
	},
	"h3_is_valid_cell": {
		Description: "Returns TRUE if the input represents a valid H3 cell.",
		Signatures:  []string{"H3_IS_VALID_CELL( <cell_id> )"},
	},
	"h3_latlng_to_cell": {
		Description: "Returns the INTEGER value of the H3 cell ID for a given latitude, longitude, and resolution.",
		Signatures:  []string{"H3_LATLNG_TO_CELL( <latitude> , <longitude> , <target_resolution> )"},
	},
	"h3_latlng_to_cell_string": {
		Description: "Returns the H3 cell ID in hexadecimal format (as a VARCHAR value) for a given latitude, longitude, and resolution.",
		Signatures:  []string{"H3_LATLNG_TO_CELL_STRING( <latitude> , <longitude> , <target_resolution> )"},
	},
	"h3_point_to_cell": {
		Description: "Returns the INTEGER value of an H3 cell ID for a Point (specified by a GEOGRAPHY object) at a given resolution.",
		Signatures:  []string{"H3_POINT_TO_CELL( <geography_point> , <target_resolution> )"},
	},
	"h3_point_to_cell_string": {
		Description: "Returns the hexadecimal value of an H3 cell ID for a Point (specified by a GEOGRAPHY object) at a given resolution.",
		Signatures:  []string{"H3_POINT_TO_CELL_STRING( <geography_point> , <target_resolution> )"},
	},
	"h3_polygon_to_cells": {
		Description: "Returns an array of INTEGER values of the IDs of H3 cells that have centroids contained by a Polygon (specified by a GEOGRAPHY object).",
		Signatures:  []string{"H3_POLYGON_TO_CELLS( <geography_polygon> , <target_resolution> )"},
	},
	"h3_polygon_to_cells_strings": {
		Description: "Returns an array of VARCHAR values of the hexadecimal IDs of H3 cells that have centroids contained by a Polygon (specified by a GEOGRAPHY object).",
		Signatures:  []string{"H3_POLYGON_TO_CELLS_STRINGS( <geography_polygon> , <target_resolution> )"},
	},
	"h3_string_to_int": {
		Description: "Converts an H3 cell ID in hexadecimal format to an INTEGER value.",
		Signatures:  []string{"H3_STRING_TO_INT( <cell_id> )"},
	},
	"h3_try_coverage": {
		Description: "A special version of H3_COVERAGE that returns NULL if an error occurs when it attempts to return an array of IDs (as INTEGER values) identifying the minimal set of H3 cells that completely cover a ...",
		Signatures:  []string{"H3_TRY_COVERAGE( <geography_expression> , <target_resolution> )"},
	},
	"h3_try_coverage_strings": {
		Description: "A special version of H3_COVERAGE_STRINGS that returns NULL if an error occurs when it attempts to return an array of hexadecimal IDs (as VARCHAR values) identifying the minimal set of H3 cells that...",
		Signatures:  []string{"H3_TRY_COVERAGE_STRINGS( <geography_expression> , <target_resolution> )"},
	},
	"h3_try_grid_distance": {
		Description: "A special version of H3_GRID_DISTANCE that returns NULL if an error occurs when it attempts to return the distance between two H3 cells.",
		Signatures:  []string{"H3_TRY_GRID_DISTANCE( <cell_id_1> , <cell_id_2> )"},
	},
	"h3_try_grid_path": {
		Description: "A special version of H3_GRID_PATH that returns NULL if an error occurs when it attempts to return an array of VARIANT values that contain the IDs of the H3 cells that represent the line between two...",
		Signatures:  []string{"H3_TRY_GRID_PATH( <cell_id_1> , <cell_id_2> )"},
	},
	"h3_try_polygon_to_cells": {
		Description: "A special version of H3_POLYGON_TO_CELLS that returns NULL if an error occurs when it attempts to return an array of INTEGER values of the IDs of H3 cells that have centroids contained by a Polygon...",
		Signatures:  []string{"H3_TRY_POLYGON_TO_CELLS( <geography_polygon> , <target_resolution> )"},
	},
	"h3_try_polygon_to_cells_strings": {
		Description: "A special version of H3_POLYGON_TO_CELLS_STRINGS that returns NULL if an error occurs when it attempts to return an array of VARCHAR values of the hexadecimal IDs of H3 cells that have centroids co...",
		Signatures:  []string{"H3_TRY_POLYGON_TO_CELLS_STRINGS( <geography_polygon> , <target_resolution> )"},
	},
	"h3_uncompact_cells": {
		Description: "Returns an array of VARIANT values that contain the INTEGER IDs of H3 cells at the specified resolution that cover the same area as the H3 cells in the input.",
		Signatures:  []string{"H3_UNCOMPACT_CELLS( <array_of_cell_ids> , <target_resolution> )"},
	},
	"h3_uncompact_cells_strings": {
		Description: "Returns an array of VARIANT values that contain the VARCHAR hexadecimal IDs of H3 cells at the specified resolution that cover the same area as the H3 cells in the input.",
		Signatures:  []string{"H3_UNCOMPACT_CELLS_STRINGS( <array_of_cell_ids> , <target_resolution> )"},
	},
	"hash": {
		Description: "Returns a signed 64-bit hash value. Note that HASH never returns NULL, even for NULL inputs.",
		Signatures:  []string{"HASH( <expr> [ , <expr> ... ] )\n\nHASH(*)"},
	},
	"hash_agg": {
		Description: "Aggregate functions , Window functions",
		Signatures:  []string{"HASH_AGG( [ DISTINCT ] <expr> [ , <expr2> ... ] )\n\nHASH_AGG(*)"},
	},
	"haversine": {
		Description: "Calculates the great-circle distance in kilometers between two points on the Earthâ€™s surface, using the Haversine formula. The two points are specified by their latitude and longitude in decimal ...",
		Signatures:  []string{"HAVERSINE( <lat1>, <lon1>, <lat2>, <lon2> )"},
	},
	"hex_decode_binary": {
		Description: "String & binary functions (Encoding/Decoding)",
		Signatures:  []string{"HEX_DECODE_BINARY(<input>)"},
	},
	"hex_decode_string": {
		Description: "String & binary functions (Encoding/Decoding)",
		Signatures:  []string{"HEX_DECODE_STRING(<input>)"},
	},
	"hex_encode": {
		Description: "String & binary functions (Encoding/Decoding)",
		Signatures:  []string{"HEX_ENCODE(<input> [, <case>])"},
	},
	"hll": {
		Description: "Aggregate functions (Cardinality Estimation) , Window functions",
		Signatures:  []string{"HLL( [ DISTINCT ] <expr1> [ , ... ] )\n\nHLL(*)"},
	},
	"hll_accumulate": {
		Description: "Aggregate functions (Cardinality Estimation) , Window function syntax and usage",
		Signatures:  []string{"HLL_ACCUMULATE( [ DISTINCT ] <expr> )\n\nHLL_ACCUMULATE(*)"},
	},
	"hll_combine": {
		Description: "Aggregate functions (Cardinality Estimation) , Window function syntax and usage",
		Signatures:  []string{"HLL_COMBINE( [ DISTINCT ] <state> )"},
	},
	"hll_estimate": {
		Description: "Aggregate functions (Cardinality Estimation) , Window function syntax and usage",
		Signatures:  []string{"HLL_ESTIMATE( <state> )"},
	},
	"hll_export": {
		Description: "Aggregate functions (Cardinality Estimation) , Window function syntax and usage",
		Signatures:  []string{"HLL_EXPORT( <binary_expr> )"},
	},
	"hll_import": {
		Description: "Aggregate functions (Cardinality Estimation) , Window function syntax and usage",
		Signatures:  []string{"HLL_IMPORT(obj)"},
	},
	"hour": {
		Description: "Date & time functions",
		Signatures:  []string{"HOUR( <time_or_timestamp_expr> )\n\nMINUTE( <time_or_timestamp_expr> )\n\nSECOND( <time_or_timestamp_expr> )"},
	},
	"iceberg_table_files": {
		Description: "Returns information about the data files registered to an externally managed Apache Icebergâ„¢ table at a specified point in time.",
		Signatures:  []string{"ICEBERG_TABLE_FILES(\n  TABLE_NAME => '<table_name>'\n  [, AT => '<timestamp_ltz>']\n)"},
	},
	"iceberg_table_snapshot_refresh_history": {
		Description: "Returns metadata and snapshot information about the most recent refresh history for a specified externally managed Apache Icebergâ„¢ table.",
		Signatures:  []string{"ICEBERG_TABLE_SNAPSHOT_REFRESH_HISTORY(\n  TABLE_NAME => '<table_name>'\n)"},
	},
	"iff": {
		Description: "Conditional expression functions",
		Signatures:  []string{"IFF( <condition> , <expr1> , <expr2> )"},
	},
	"ifnull": {
		Description: "Conditional expression functions",
		Signatures:  []string{"IFNULL( <expr1> , <expr2> )"},
	},
	"infer_schema": {
		Description: "Automatically detects the file metadata schema in a set of staged data files that contain semi-structured data and retrieves the column definitions.",
		Signatures:  []string{"INFER_SCHEMA(\n  LOCATION => '{ internalStage | externalStage }'\n  , FILE_FORMAT => '<file_format_name>'\n  , FILES => ( '<file_name>' [ , '<file_name>' ] [ , ... ] )\n  , IGNORE_CASE => TRUE | FALSE\n  , MAX_FILE_COUNT => <num>\n  , MAX_RECORDS_PER_FILE => <num>\n  , KIND => '<kind_name>'\n)"},
	},
	"initcap": {
		Description: "String & binary functions (Case Conversion)",
		Signatures:  []string{"INITCAP( <expr> [ , '<delimiters>' ] )"},
	},
	"insert": {
		Description: "String & binary functions (General)",
		Signatures:  []string{"INSERT( <base_expr>, <pos>, <len>, <insert_expr> )"},
	},
	"integration": {
		Description: "Notification functions (Integration Configuration)",
		Signatures:  []string{"SNOWFLAKE.NOTIFICATION.INTEGRATION( '<integration_name>' )"},
	},
	"interpolate_bfill": {
		Description: "Window functions (General)",
		Signatures:  []string{"INTERPOLATE_BFILL( <expr> )\n  OVER ( [ PARTITION BY <expr1> ] ORDER BY <expr2> [ { ASC | DESC } ] )"},
	},
	"invoker_role": {
		Description: "Context functions (Session Object)",
		Signatures:  []string{"INVOKER_ROLE()"},
	},
	"invoker_share": {
		Description: "Context functions (Session Object)",
		Signatures:  []string{"INVOKER_SHARE()"},
	},
	"is_application_role_activated": {
		Description: "Context functions (General)",
		Signatures:  []string{"SYS_CONTEXT(\n  'SNOWFLAKE$APPLICATION' ,\n  'IS_APPLICATION_ROLE_ACTIVATED' ,\n  '<context>' ,\n  '<app_role>'\n)"},
	},
	"is_application_role_in_session": {
		Description: "Context functions (Session Object)",
		Signatures:  []string{"IS_APPLICATION_ROLE_IN_SESSION( '<string_literal>' )"},
	},
	"is_array": {
		Description: "Semi-structured and structured data functions (Type Predicates)",
		Signatures:  []string{"IS_ARRAY( <variant_expr> )"},
	},
	"is_binary": {
		Description: "Semi-structured and structured data functions (Type Predicates)",
		Signatures:  []string{"IS_BINARY( <variant_expr> )"},
	},
	"is_boolean": {
		Description: "Semi-structured and structured data functions (Type Predicates)",
		Signatures:  []string{"IS_BOOLEAN( <variant_expr> )"},
	},
	"is_char": {
		Description: "Semi-structured and structured data functions (Type Predicates)",
		Signatures:  []string{"IS_CHAR( <variant_expr> )\n\nIS_VARCHAR( <variant_expr> )"},
	},
	"is_database_role_in_session": {
		Description: "Context functions (Session Object)",
		Signatures:  []string{"IS_DATABASE_ROLE_IN_SESSION( '<string_literal>' )"},
	},
	"is_date": {
		Description: "Semi-structured and structured data functions (Type Predicates)",
		Signatures:  []string{"IS_DATE( <variant_expr> )\n\nIS_DATE_VALUE( <variant_expr> )"},
	},
	"is_decimal": {
		Description: "Semi-structured and structured data functions (Type Predicates)",
		Signatures:  []string{"IS_DECIMAL( <variant_expr> )"},
	},
	"is_double": {
		Description: "Semi-structured and structured data functions (Type Predicates)",
		Signatures:  []string{"IS_DOUBLE( <variant_expr> )\n\nIS_REAL( <variant_expr> )"},
	},
	"is_granted_to_invoker_role": {
		Description: "Context functions (Session Object)",
		Signatures:  []string{"IS_GRANTED_TO_INVOKER_ROLE( '<string_literal>' )"},
	},
	"is_group_activated": {
		Description: "Context functions (General)",
		Signatures:  []string{"SYS_CONTEXT(\n  'SNOWFLAKE$ORGANIZATION' ,\n  'IS_GROUP_ACTIVATED' ,\n  '<context>' ,\n  '<group_name>'\n)"},
	},
	"is_group_imported": {
		Description: "Context functions (General)",
		Signatures:  []string{"SYS_CONTEXT(\n  'SNOWFLAKE$ORGANIZATION' ,\n  'IS_GROUP_IMPORTED' ,\n  '<group_name>'\n)"},
	},
	"is_instance_role_in_session": {
		Description: "Context functions (Session Object)",
		Signatures:  []string{"IS_INSTANCE_ROLE_IN_SESSION( '<instance_name>' , '<instance_role_name>' )"},
	},
	"is_integer": {
		Description: "Semi-structured and structured data functions (Type Predicates)",
		Signatures:  []string{"IS_INTEGER( <variant_expr> )"},
	},
	"is_null_value": {
		Description: "Conditional expression functions , Semi-structured and structured data functions (Type Predicates)",
		Signatures:  []string{"IS_NULL_VALUE( <variant_expr> )"},
	},
	"is_object": {
		Description: "Semi-structured and structured data functions (Type Predicates)",
		Signatures:  []string{"IS_OBJECT( <variant_expr> )"},
	},
	"is_organization_user": {
		Description: "Preview Feature â€” Open",
		Signatures:  []string{"IS_ORGANIZATION_USER( <exp> )"},
	},
	"is_organization_user_group": {
		Description: "Preview Feature â€” Open",
		Signatures:  []string{"IS_ORGANIZATION_USER_GROUP( '<role>' )"},
	},
	"is_organization_user_group_in_session": {
		Description: "Context functions (Session Object)",
		Signatures:  []string{"IS_ORGANIZATION_USER_GROUP_IN_SESSION( '<string_literal>' )"},
	},
	"is_role_activated": {
		Description: "Context functions (General)",
		Signatures:  []string{"SYS_CONTEXT(\n  'SNOWFLAKE$SESSION' ,\n  'IS_ROLE_ACTIVATED' ,\n  '<role>'\n)"},
	},
	"is_role_in_session": {
		Description: "Context functions (Session Object)",
		Signatures:  []string{"IS_ROLE_IN_SESSION( '<string_literal>' )"},
	},
	"is_time": {
		Description: "Semi-structured and structured data functions (Type Predicates)",
		Signatures:  []string{"IS_TIME( <variant_expr> )"},
	},
	"is_user_imported": {
		Description: "Context functions (General)",
		Signatures:  []string{"SYS_CONTEXT(\n  'SNOWFLAKE$ORGANIZATION' ,\n  'IS_USER_IMPORTED' ,\n  '<user_name>'\n)"},
	},
	"jarowinkler_similarity": {
		Description: "String & binary functions (Matching/Comparison)",
		Signatures:  []string{"JAROWINKLER_SIMILARITY( <string_expr1> , <string_expr2> )"},
	},
	"json_extract_path_text": {
		Description: "Semi-structured and structured data functions (Extraction)",
		Signatures:  []string{"JSON_EXTRACT_PATH_TEXT( <column_identifier> , '<path_name>' )"},
	},
	"kurtosis": {
		Description: "Aggregate functions (General) , Window function syntax and usage",
		Signatures:  []string{"KURTOSIS( <expr> )"},
	},
	"lag": {
		Description: "Window function syntax and usage (Ranking)",
		Signatures:  []string{"LAG ( <expr> [ , <offset> , <default> ] ) [ { IGNORE | RESPECT } NULLS ]\n    OVER ( [ PARTITION BY <expr1> ] ORDER BY <expr2> [ { ASC | DESC } ] )"},
	},
	"last_day": {
		Description: "Date & time functions",
		Signatures:  []string{"LAST_DAY( <date_or_timetamp_expr> [ , <date_part> ] )"},
	},
	"last_query_id": {
		Description: "Context functions (Session)",
		Signatures:  []string{"LAST_QUERY_ID( [ <num> ] )"},
	},
	"last_successful_scheduled_time": {
		Description: "Date & time functions (Alerts)",
		Signatures:  []string{"SNOWFLAKE.ALERT.LAST_SUCCESSFUL_SCHEDULED_TIME()"},
	},
	"last_transaction": {
		Description: "Context functions (Session)",
		Signatures:  []string{"LAST_TRANSACTION()"},
	},
	"last_value": {
		Description: "Window function syntax and usage (Ranking)",
		Signatures:  []string{"LAST_VALUE( <expr> ) [ { IGNORE | RESPECT } NULLS ]\n  OVER ( [ PARTITION BY <expr1> ] ORDER BY <expr2> [ { ASC | DESC } ] [ NULLS { FIRST | LAST } ] [ <window_frame> ] )"},
	},
	"lead": {
		Description: "Window function syntax and usage (Ranking)",
		Signatures:  []string{"LEAD ( <expr> [ , <offset> , <default> ] ) [ { IGNORE | RESPECT } NULLS ]\n  OVER ( [ PARTITION BY <expr1> ] ORDER BY <expr2> [ { ASC | DESC } ] )"},
	},
	"least": {
		Description: "Conditional expression functions",
		Signatures:  []string{"LEAST(( <expr1> [ , <expr2> ... ] )"},
	},
	"least_ignore_nulls": {
		Description: "Conditional expression functions",
		Signatures:  []string{"LEAST_IGNORE_NULLS( <expr1> [ , <expr2> ... ] )"},
	},
	"left": {
		Description: "String & binary functions (Matching/Comparison)",
		Signatures:  []string{"LEFT( <string_expr> , <length_expr> )"},
	},
	"length": {
		Description: "String & binary functions (General)",
		Signatures:  []string{"LENGTH( <expression> )\n\nLEN( <expression> )"},
	},
	"listagg": {
		Description: "Aggregate functions (General) , Window function syntax and usage (General)",
		Signatures:  []string{"LISTAGG( [ DISTINCT ] <expr1> [, <delimiter> ] )\n    [ WITHIN GROUP ( <orderby_clause> ) ]"},
	},
	"listing_refresh_history": {
		Description: "Information Schema , Table functions",
		Signatures:  []string{"LISTING_REFRESH_HISTORY(\n  LISTING_NAME => '<listing_name>'\n  [ , SNOWFLAKE_REGION => '<snowflake_region>' ]\n  [ , REGION_GROUP => '<region_group>' ] )"},
	},
	"ln": {
		Description: "Numeric functions (Logarithmic)",
		Signatures:  []string{"LN(<expr>)"},
	},
	"localtime": {
		Description: "Context functions (General)",
		Signatures:  []string{"LOCALTIME()\n\nLOCALTIME"},
	},
	"localtimestamp": {
		Description: "Context functions (General)",
		Signatures:  []string{"LOCALTIMESTAMP( [ <fract_sec_precision> ] )\n\nLOCALTIMESTAMP"},
	},
	"log": {
		Description: "Numeric functions (Logarithmic)",
		Signatures:  []string{"LOG(<base>, <expr>)"},
	},
	"login_history": {
		Description: "Information Schema , Table functions",
		Signatures:  []string{"LOGIN_HISTORY(\n      [  TIME_RANGE_START => <constant_expr> ]\n      [, TIME_RANGE_END => <constant_expr> ]\n      [, RESULT_LIMIT => <num> ] )\n\nLOGIN_HISTORY_BY_USER(\n      [  USER_NAME => '<string>' ]\n      [, TIME_RANGE_START => <constant_expr> ]\n      [, TIME_RANGE_END => <constant_expr> ]\n      [, RESULT_LIMIT => <num> ] )"},
	},
	"lower": {
		Description: "String & binary functions (Case Conversion)",
		Signatures:  []string{"LOWER( <expr> )"},
	},
	"lpad": {
		Description: "String & binary functions (General)",
		Signatures:  []string{"LPAD( <base>, <length_expr> [, <pad>] )"},
	},
	"ltrim": {
		Description: "String & binary functions (General)",
		Signatures:  []string{"LTRIM( <expr> [, <characters> ] )"},
	},
	"map_cat": {
		Description: "Semi-structured and structured data functions (Map)",
		Signatures:  []string{"MAP_CAT( <map1> , <map2> )"},
	},
	"map_contains_key": {
		Description: "Semi-structured and structured data functions (Map)",
		Signatures:  []string{"MAP_CONTAINS_KEY( <key> , <map> )"},
	},
	"map_delete": {
		Description: "Semi-structured and structured data functions (Map)",
		Signatures:  []string{"MAP_DELETE( <map>, <key1> [, <key2>, ... ] )"},
	},
	"map_insert": {
		Description: "Semi-structured and structured data functions (Map)",
		Signatures:  []string{"MAP_INSERT( <map> , <key> , <value> [ , <updateFlag> ] )"},
	},
	"map_keys": {
		Description: "Semi-structured and structured data functions (Map)",
		Signatures:  []string{"MAP_KEYS( <map> )"},
	},
	"map_pick": {
		Description: "Semi-structured and structured data functions (Map)",
		Signatures:  []string{"MAP_PICK( <map>, <key1> [, <key2>, ... ] )\n\nMAP_PICK( <map>, <array> )"},
	},
	"map_size": {
		Description: "Semi-structured and structured data functions (Map)",
		Signatures:  []string{"MAP_SIZE( <map> )"},
	},
	"materialized_view_refresh_history": {
		Description: "Information Schema , Table functions",
		Signatures:  []string{"MATERIALIZED_VIEW_REFRESH_HISTORY(\n      [ DATE_RANGE_START => <constant_expr> ]\n      [ , DATE_RANGE_END => <constant_expr> ]\n      [ , MATERIALIZED_VIEW_NAME => '<string>' ] )"},
	},
	"max": {
		Description: "Data metric functions",
		Signatures:  []string{"SNOWFLAKE.CORE.MAX(<query>)"},
	},
	"max_by": {
		Description: "Aggregate functions (General)",
		Signatures:  []string{"MAX_BY( <col_to_return>, <col_containing_maximum> [ , <maximum_number_of_values_to_return> ] )"},
	},
	"md5": {
		Description: "String & binary functions (Checksum)",
		Signatures:  []string{"MD5(<msg>)\n\nMD5_HEX(<msg>)"},
	},
	"md5_binary": {
		Description: "String & binary functions (Checksum)",
		Signatures:  []string{"MD5_BINARY(<msg>)"},
	},
	"md5_number_lower64": {
		Description: "String & binary functions (Checksum)",
		Signatures:  []string{"MD5_NUMBER_LOWER64(<msg>)"},
	},
	"md5_number_upper64": {
		Description: "String & binary functions (Checksum)",
		Signatures:  []string{"MD5_NUMBER_UPPER64(<msg>)"},
	},
	"median": {
		Description: "Aggregate functions (General) , Window functions",
		Signatures:  []string{"MEDIAN( <expr> )"},
	},
	"min": {
		Description: "Data metric functions",
		Signatures:  []string{"SNOWFLAKE.CORE.MIN(<query>)"},
	},
	"min_by": {
		Description: "Aggregate functions (General)",
		Signatures:  []string{"MIN_BY( <col_to_return>, <col_containing_mininum> [ , <maximum_number_of_values_to_return> ] )"},
	},
	"minhash": {
		Description: "Aggregate functions (Similarity Estimation) , Window function syntax and usage",
		Signatures:  []string{"MINHASH( <k> , [ DISTINCT ] expr+ )\n\nMINHASH( <k> , * )"},
	},
	"minhash_combine": {
		Description: "Aggregate functions (Similarity Estimation) , Window function syntax and usage",
		Signatures:  []string{"MINHASH_COMBINE( [ DISTINCT ] <state> )"},
	},
	"mod": {
		Description: "Numeric functions (Rounding and Truncation)",
		Signatures:  []string{"MOD( <expr1> , <expr2> )"},
	},
	"mode": {
		Description: "Aggregate functions (General) , Window functions",
		Signatures:  []string{"MODE( <expr1> )"},
	},
	"model_monitor_drift_metric": {
		Description: "Model monitor functions",
		Signatures:  []string{"MODEL_MONITOR_DRIFT_METRIC(\n  <model_monitor_name>, <drift_metric_name>, <column_name>\n  [ , <granularity> [ , <start_time>  [ , <end_time> [ , <extra_args> ] ] ] ]\n)"},
	},
	"model_monitor_performance_metric": {
		Description: "Model monitor functions",
		Signatures:  []string{"MODEL_MONITOR_PERFORMANCE_METRIC(<model_monitor_name>, <performance_metric_name>,\n    [, <granularity> [, <start_time>  [, <end_time> [, <extra_args> ] ] ] ] )"},
	},
	"model_monitor_stat_metric": {
		Description: "Model monitor functions",
		Signatures:  []string{"MODEL_MONITOR_STAT_METRIC(<model_monitor_name>, <stat_metric_name>, <column_name>\n    [, <granularity> [, <start_time>  [, <end_time> [, <extra_args> ] ] ] ] )"},
	},
	"monthname": {
		Description: "Date & time functions",
		Signatures:  []string{"MONTHNAME( <date_or_timestamp_expr> )"},
	},
	"months_between": {
		Description: "Date & time functions",
		Signatures:  []string{"MONTHS_BETWEEN( <date_expr1> , <date_expr2> )"},
	},
	"network_rule_references": {
		Description: "Information Schema , Table functions",
		Signatures:  []string{"NETWORK_RULE_REFERENCES(\n  NETWORK_RULE_NAME => '<string>'\n)\n\nNETWORK_RULE_REFERENCES(\n  CONTAINER_NAME => '<container_name>' ,\n  CONTAINER_TYPE => { 'INTEGRATION' | 'NETWORK_POLICY' }\n)"},
	},
	"next_day": {
		Description: "Date & time functions",
		Signatures:  []string{"NEXT_DAY( <date_or_timetamp_expr> , <dow_string> )"},
	},
	"normal": {
		Description: "Data generation functions",
		Signatures:  []string{"NORMAL( <mean> , <stddev> , <gen> )"},
	},
	"notification_history": {
		Description: "Information Schema , Table functions",
		Signatures:  []string{"NOTIFICATION_HISTORY(\n  [ START_TIME => <constant_expr> ]\n  [, END_TIME => <constant_expr> ]\n  [, INTEGRATION_NAME => '<string>' ]\n  [, RESULT_LIMIT => <integer> ] )"},
	},
	"nth_value": {
		Description: "Window function syntax and usage (Ranking)",
		Signatures:  []string{"NTH_VALUE( <expr> , <n> ) [ FROM { FIRST | LAST } ] [ { IGNORE | RESPECT } NULLS ]\n  OVER ( [ PARTITION BY <expr1> ] ORDER BY <expr2> [ { ASC | DESC } ] [ <window_frame> ] )"},
	},
	"ntile": {
		Description: "Window function syntax and usage (Ranking)",
		Signatures:  []string{"NTILE( <constant_value> ) OVER ( [ PARTITION BY <expr1> ] ORDER BY <expr2> [ { ASC | DESC } ] )"},
	},
	"null_count": {
		Description: "Data metric functions",
		Signatures:  []string{"SNOWFLAKE.CORE.NULL_COUNT(<query>)"},
	},
	"null_percent": {
		Description: "Data metric functions",
		Signatures:  []string{"SNOWFLAKE.CORE.NULL_PERCENT(<query>)"},
	},
	"nullif": {
		Description: "Conditional expression functions",
		Signatures:  []string{"NULLIF( <expr1> , <expr2> )"},
	},
	"nullifzero": {
		Description: "Conditional expression functions",
		Signatures:  []string{"NULLIFZERO( <expr> )"},
	},
	"nvl": {
		Description: "Conditional expression functions",
		Signatures:  []string{"NVL( <expr1> , <expr2> )"},
	},
	"nvl2": {
		Description: "Conditional expression functions",
		Signatures:  []string{"NVL2( <expr1> , <expr2> , <expr3> )"},
	},
	"object_agg": {
		Description: "Aggregate functions (Semi-structured Data) , Window functions (General) , Semi-structured and structured data functions (Array/Object)",
		Signatures:  []string{"OBJECT_AGG(<key>, <value>)"},
	},
	"object_construct": {
		Description: "Semi-structured and structured data functions (Array/Object)",
		Signatures:  []string{"OBJECT_CONSTRUCT( [<key>, <value> [, <key>, <value> , ...]] )\n\nOBJECT_CONSTRUCT(*)"},
	},
	"object_construct_keep_null": {
		Description: "Semi-structured and structured data functions (Array/Object)",
		Signatures:  []string{"OBJECT_CONSTRUCT_KEEP_NULL( [<key>, <value> [, <key>, <value> , ...]] )\n\nOBJECT_CONSTRUCT_KEEP_NULL(*)"},
	},
	"object_delete": {
		Description: "Semi-structured and structured data functions (Array/Object)",
		Signatures:  []string{"OBJECT_DELETE( <object>, <key1> [, <key2>, ... ] )"},
	},
	"object_insert": {
		Description: "Semi-structured and structured data functions (Array/Object)",
		Signatures:  []string{"OBJECT_INSERT( <object> , <key> , <value> [ , <updateFlag> ] )"},
	},
	"object_keys": {
		Description: "Semi-structured and structured data functions (Array/Object)",
		Signatures:  []string{"OBJECT_KEYS( <object> )"},
	},
	"object_pick": {
		Description: "Semi-structured and structured data functions (Array/Object)",
		Signatures:  []string{"OBJECT_PICK( <object>, <key1> [, <key2>, ... ] )\n\nOBJECT_PICK( <object>, <array> )"},
	},
	"octet_length": {
		Description: "String & binary functions (General)",
		Signatures:  []string{"OCTET_LENGTH(<string_or_binary>)"},
	},
	"online_feature_table_refresh_history": {
		Description: "This table function returns information about each refresh (completed and running) of online feature tables.",
		Signatures:  []string{"ONLINE_FEATURE_TABLE_REFRESH_HISTORY(\n  [ REFRESH_START_TIMESTAMP => <constant_expr> ]\n  [ , REFRESH_END_TIMESTAMP => <constant_expr> ]\n  [ , RESULT_LIMIT => <integer> ]\n  [ , NAME => '<string>' ]\n  [ , NAME_PREFIX => '<string>' ]\n  [ , ERROR_ONLY => { TRUE | FALSE } ]\n)"},
	},
	"parse_document": {
		Description: "File functions (AI Functions)",
		Signatures:  []string{"SNOWFLAKE.CORTEX.PARSE_DOCUMENT( '@<stage>', '<path>', [ <options> ] )"},
	},
	"parse_ip": {
		Description: "String & binary functions (General)",
		Signatures:  []string{"PARSE_IP(<expr>, '<type>' [, <permissive>])"},
	},
	"parse_json": {
		Description: "Semi-structured and structured data functions (Parsing)",
		Signatures:  []string{"PARSE_JSON( <expr> [ , '<parameter>' ] )"},
	},
	"parse_url": {
		Description: "String & binary functions (General)",
		Signatures:  []string{"PARSE_URL(<string>, [<permissive>])"},
	},
	"parse_xml": {
		Description: "Semi-structured and structured data functions (Parsing)",
		Signatures:  []string{"PARSE_XML( <string_containing_xml> [ , <disable_auto_convert> ] )"},
	},
	"percent_rank": {
		Description: "Window functions (Ranking)",
		Signatures:  []string{"PERCENT_RANK()\n  OVER ( [ PARTITION BY <expr1> ] ORDER BY <expr2> [ { ASC | DESC } ] [ <fixedRangeFrame> ] )"},
	},
	"percentile_cont": {
		Description: "Aggregate functions (General) , Window functions",
		Signatures:  []string{"PERCENTILE_CONT( <percentile> ) WITHIN GROUP (ORDER BY <order_by_expr>)"},
	},
	"percentile_disc": {
		Description: "Aggregate functions (General) , Window functions",
		Signatures:  []string{"PERCENTILE_DISC( <percentile> ) WITHIN GROUP (ORDER BY <order_by_expr> )"},
	},
	"pi": {
		Description: "Numeric functions (Trigonometric)",
		Signatures:  []string{"PI()"},
	},
	"pipe_usage_history": {
		Description: "Information Schema , Table functions",
		Signatures:  []string{"PIPE_USAGE_HISTORY(\n      [ DATE_RANGE_START => <constant_expr> ]\n      [, DATE_RANGE_END => <constant_expr> ]\n      [, PIPE_NAME => '<string>' ] )"},
	},
	"policy_context": {
		Description: "Simulates the results of a query based upon the value of one or more context functions, which lets you determine how policies affect query results. Context functions return a value based on the cur...",
		Signatures:  []string{"EXECUTE USING\nPOLICY_CONTEXT( <arg_1> => '<string_literal>' [ , <arg_2> => '<string_literal>' , ... , <arg_n> => '<string_literal>' ] )\nAS\nSELECT <query>"},
	},
	"policy_references": {
		Description: "Information Schema , Table functions",
		Signatures:  []string{"POLICY_REFERENCES(\n      POLICY_NAME => '<string>' ,\n      POLICY_KIND => 'NETWORK_POLICY'\n      )"},
	},
	"position": {
		Description: "String & binary functions (Matching/Comparison)",
		Signatures:  []string{"POSITION( <expr1>, <expr2> [ , <start_pos> ] )\n\nPOSITION( <expr1> IN <expr2> )"},
	},
	"pow": {
		Description: "Numeric functions (Exponent and Root)",
		Signatures:  []string{"POW(x, y)\n\nPOWER (x, y)"},
	},
	"previous_day": {
		Description: "Date & time functions",
		Signatures:  []string{"PREVIOUS_DAY( <date_or_timetamp_expr> , <dow> )"},
	},
	"prompt": {
		Description: "Preview Feature â€” Open",
		Signatures:  []string{"SELECT PROMPT('<template_string>', <expr_1> [ , <expr_2>, ... ] )\n    FROM <table>;"},
	},
	"query_acceleration_history": {
		Description: "Information Schema , Table functions",
		Signatures:  []string{"QUERY_ACCELERATION_HISTORY(\n      [ DATE_RANGE_START => <constant_expr> ]\n      [ , DATE_RANGE_END => <constant_expr> ]\n      [ , WAREHOUSE_NAME => '<string>' ] )"},
	},
	"query_history": {
		Description: "Information Schema , Table functions",
		Signatures:  []string{"QUERY_HISTORY(\n      [ END_TIME_RANGE_START => <constant_expr> ]\n      [, END_TIME_RANGE_END => <constant_expr> ]\n      [, RESULT_LIMIT => <num> ]\n      [, INCLUDE_CLIENT_GENERATED_STATEMENT => <boolean_expr> ] )\n\nQUERY_HISTORY_BY_SESSION(\n      [ SESSION_ID => <constant_expr> ]\n      [, END_TIME_RANGE_START => <constant_expr> ]\n      [, END_TIME_RANGE_END => <constant_expr> ]\n      [, RESULT_LIMIT => <num> ]\n      [, INCLUDE_CLIENT_GENERATED_STATEMENT => <boolean_expr> ] )\n\nQUERY_HISTORY_BY_USER(\n      [ USER_NAME => '<string>' ]\n      [, END_TIME_RANGE_START => <constant_expr> ]\n      [, END_TIME_RANGE_END => <constant_expr> ]\n      [, RESULT_LIMIT => <num> ]\n      [, INCLUDE_CLIENT_GENERATED_STATEMENT => <boolean_expr> ] )\n\nQUERY_HISTORY_BY_WAREHOUSE(\n      [ WAREHOUSE_NAME => '<string>' ]\n      [, END_TIME_RANGE_START => <constant_expr> ]\n      [, END_TIME_RANGE_END => <constant_expr> ]\n      [, RESULT_LIMIT => <num> ]\n      [, INCLUDE_CLIENT_GENERATED_STATEMENT => <boolean_expr> ] )"},
	},
	"radians": {
		Description: "Numeric functions (Trigonometric)",
		Signatures:  []string{"RADIANS( <input_expr> )"},
	},
	"random": {
		Description: "Data generation functions",
		Signatures:  []string{"RANDOM([seed])"},
	},
	"randstr": {
		Description: "Data generation functions",
		Signatures:  []string{"RANDSTR( <length> , <gen> )"},
	},
	"rank": {
		Description: "Window functions (Ranking)",
		Signatures:  []string{"RANK() OVER ( [ PARTITION BY <expr1> ] ORDER BY <expr2> [ { ASC | DESC } ] [ <window_frame> ] )"},
	},
	"ratio_to_report": {
		Description: "Window functions (General)",
		Signatures:  []string{"RATIO_TO_REPORT( <expr1> ) [ OVER ( [ PARTITION BY <expr2> ] [ ORDER BY <expr3> ] ) ]"},
	},
	"reduce": {
		Description: "Semi-structured and structured data functions (Higher-order)",
		Signatures:  []string{"REDUCE( <array> , <init> , <lambda_expression> )"},
	},
	"regexp_count": {
		Description: "String functions (regular expressions)",
		Signatures:  []string{"REGEXP_COUNT( <subject> ,\n              <pattern>\n                [ , <position>\n                  [ , <parameters> ]\n                ]\n)"},
	},
	"regexp_instr": {
		Description: "String functions (regular expressions)",
		Signatures:  []string{"REGEXP_INSTR( <subject> , <pattern> [ , <position> [ , <occurrence> [ , <option> [ , <regexp_parameters> [ , <group_num> ] ] ] ] ] )"},
	},
	"regexp_like": {
		Description: "String functions (regular expressions)",
		Signatures:  []string{"REGEXP_LIKE( <subject> , <pattern> [ , <parameters> ] )"},
	},
	"regexp_replace": {
		Description: "String functions (regular expressions)",
		Signatures:  []string{"REGEXP_REPLACE( <subject> ,\n                 <pattern>\n                   [ , <replacement>\n                     [ , <position>\n                       [ , <occurrence>\n                         [ , <parameters> ]\n                       ]\n                     ]\n                   ]\n)"},
	},
	"regexp_substr": {
		Description: "String functions (regular expressions)",
		Signatures:  []string{"REGEXP_SUBSTR( <subject> ,\n               <pattern>\n                 [ , <position>\n                   [ , <occurrence>\n                     [ , <regex_parameters>\n                       [ , <group_num> ]\n                     ]\n                   ]\n                 ]\n)"},
	},
	"regexp_substr_all": {
		Description: "String functions (regular expressions)",
		Signatures:  []string{"REGEXP_SUBSTR_ALL( <subject> ,\n                   <pattern>\n                     [ , <position>\n                       [ , <occurrence>\n                         [ , <regex_parameters>\n                           [ , <group_num> ]\n                         ]\n                       ]\n                     ]\n)"},
	},
	"regr_avgx": {
		Description: "Aggregate functions (Linear Regression) , Window functions",
		Signatures:  []string{"REGR_AVGX(y, x)"},
	},
	"regr_avgy": {
		Description: "Aggregate functions (Linear Regression) , Window functions",
		Signatures:  []string{"REGR_AVGY(y, x)"},
	},
	"regr_count": {
		Description: "Aggregate functions (Linear Regression) , Window function syntax and usage",
		Signatures:  []string{"REGR_COUNT(y, x)"},
	},
	"regr_intercept": {
		Description: "Aggregate functions (Linear Regression) , Window function syntax and usage",
		Signatures:  []string{"REGR_INTERCEPT(y, x)"},
	},
	"regr_r2": {
		Description: "Aggregate functions (Linear Regression) , Window function syntax and usage",
		Signatures:  []string{"REGR_R2(y, x)"},
	},
	"regr_slope": {
		Description: "Aggregate functions (Linear Regression) , Window function syntax and usage",
		Signatures:  []string{"REGR_SLOPE(y, x)"},
	},
	"regr_sxx": {
		Description: "Aggregate functions (Linear Regression) , Window function syntax and usage",
		Signatures:  []string{"REGR_SXX(y, x)"},
	},
	"regr_sxy": {
		Description: "Aggregate functions (Linear Regression) , Window function syntax and usage",
		Signatures:  []string{"REGR_SXY(y, x)"},
	},
	"regr_syy": {
		Description: "Aggregate functions (Linear Regression) , Window function syntax and usage",
		Signatures:  []string{"REGR_SYY(y, x)"},
	},
	"regr_valx": {
		Description: "Conditional expression functions",
		Signatures:  []string{"REGR_VALX( <y> , <x> )"},
	},
	"regr_valy": {
		Description: "Conditional expression functions",
		Signatures:  []string{"REGR_VALY( <y> , <x> )"},
	},
	"repeat": {
		Description: "String & binary functions (General)",
		Signatures:  []string{"REPEAT(<input>, <n>)"},
	},
	"replace": {
		Description: "String & binary functions (Matching/Comparison)",
		Signatures:  []string{"REPLACE( <subject> , <pattern> [ , <replacement> ] )"},
	},
	"replication_group_dangling_references": {
		Description: "Information Schema , Table functions",
		Signatures:  []string{"REPLICATION_GROUP_DANGLING_REFERENCES( '<replication_or_failover_group_name>' )"},
	},
	"replication_group_refresh_history": {
		Description: "Information Schema , Table functions",
		Signatures:  []string{"REPLICATION_GROUP_REFRESH_HISTORY( '<secondary_group_name>' )\n\nREPLICATION_GROUP_REFRESH_HISTORY_ALL()"},
	},
	"replication_group_refresh_progress": {
		Description: "Information Schema , Table functions",
		Signatures:  []string{"REPLICATION_GROUP_REFRESH_PROGRESS( '<secondary_group_name>' )\n\nREPLICATION_GROUP_REFRESH_PROGRESS_BY_JOB( '<query_id>' )\n\nREPLICATION_GROUP_REFRESH_PROGRESS_ALL()"},
	},
	"replication_group_usage_history": {
		Description: "Information Schema , Table functions",
		Signatures:  []string{"REPLICATION_GROUP_USAGE_HISTORY(\n   [ DATE_RANGE_START => <constant_expr> ]\n   [, DATE_RANGE_END => <constant_expr> ]\n   [, REPLICATION_GROUP_NAME => '<string>' ] )"},
	},
	"replication_usage_history": {
		Description: "Information Schema , Table functions",
		Signatures:  []string{"REPLICATION_USAGE_HISTORY(\n  [ DATE_RANGE_START => <constant_expr> ]\n  [ , DATE_RANGE_END => <constant_expr> ]\n  [ , DATABASE_NAME => '<string>' ] )"},
	},
	"rest_event_history": {
		Description: "Returns a list of SCIM REST API requests made to Snowflake over a specified time interval.",
		Signatures:  []string{"REST_EVENT_HISTORY(\n      REST_SERVICE_TYPE => 'scim'\n      [, TIME_RANGE_START => <constant_expr> ]\n      [, TIME_RANGE_END => <constant_expr> ]\n      [, RESULT_LIMIT => <integer> ] )"},
	},
	"result_scan": {
		Description: "Returns the result set of a previous command (within 24 hours of when you ran the query) as if the result was a table. This function is particularly useful if you want to process the output from an...",
		Signatures:  []string{"RESULT_SCAN ( [ { '<query_id>' | <query_index>  | LAST_QUERY_ID() } ] )"},
	},
	"reverse": {
		Description: "String & binary functions (General)",
		Signatures:  []string{"REVERSE(<subject>)"},
	},
	"right": {
		Description: "String & binary functions (Matching/Comparison)",
		Signatures:  []string{"RIGHT( <string_expr> , <length_expr> )"},
	},
	"round": {
		Description: "Numeric functions (Rounding and Truncation)",
		Signatures:  []string{"ROUND( <input_expr> [ , <scale_expr> [ , '<rounding_mode>' ] ] )"},
	},
	"row_count": {
		Description: "Data metric functions",
	},
	"row_number": {
		Description: "Window function syntax and usage (Ranking)",
		Signatures:  []string{"ROW_NUMBER() OVER (\n  [ PARTITION BY <expr1> [, <expr2> ... ] ]\n  ORDER BY <expr3> [ , <expr4> ... ] [ { ASC | DESC } ]\n  )"},
	},
	"rpad": {
		Description: "String & binary functions (General)",
		Signatures:  []string{"RPAD( <base>, <length_expr> [, <pad>] )"},
	},
	"rtrim": {
		Description: "String & binary functions (General)",
		Signatures:  []string{"RTRIM(<expr> [, <characters> ])"},
	},
	"rtrimmed_length": {
		Description: "String & binary functions (General)",
		Signatures:  []string{"RTRIMMED_LENGTH( <string_expr> )"},
	},
	"sanitize_webhook_content": {
		Description: "Notification functions (Message Sanitization)",
		Signatures:  []string{"SNOWFLAKE.NOTIFICATION.SANITIZE_WEBHOOK_CONTENT( <message> )"},
	},
	"scheduled_time": {
		Description: "Date & time functions (Alerts)",
		Signatures:  []string{"SNOWFLAKE.ALERT.SCHEDULED_TIME()"},
	},
	"search": {
		Description: "String & binary functions (Full-Text Search)",
		Signatures:  []string{"SEARCH( <search_data>, '<search_string>'\n  [ , ANALYZER => '<analyzer_name>' ]\n  [ , SEARCH_MODE => { 'OR' | 'AND' | 'PHRASE' | 'EXACT' } ] )"},
	},
	"search_ip": {
		Description: "Searches for valid IPv4 and IPv6 addresses in specified character-string columns from one or more tables, including fields in VARIANT, OBJECT, and ARRAY columns. The search is based on a single IP ...",
		Signatures:  []string{"SEARCH_IP( <search_data>, '<search_string>' )"},
	},
	"search_optimization_history": {
		Description: "Information Schema , Table functions",
		Signatures:  []string{"SEARCH_OPTIMIZATION_HISTORY(\n      [ DATE_RANGE_START => <constant_expr> ]\n      [ , DATE_RANGE_END => <constant_expr> ]\n      [ , TABLE_NAME => '<string>' ] )"},
	},
	"search_preview": {
		Description: "String & binary functions (AI Functions)",
		Signatures:  []string{"SNOWFLAKE.CORTEX.SEARCH_PREVIEW(\n    '<service_name>',\n    '<query_parameters_object>'\n)"},
	},
	"sentiment": {
		Description: "String & binary functions (AI Functions)",
		Signatures:  []string{"SNOWFLAKE.CORTEX.SENTIMENT(<text>)"},
	},
	"seq1": {
		Description: "Data generation functions",
		Signatures:  []string{"SEQ1( [0|1] )\n\nSEQ2( [0|1] )\n\nSEQ4( [0|1] )\n\nSEQ8( [0|1] )"},
	},
	"serverless_alert_history": {
		Description: "Information Schema , Table functions",
		Signatures:  []string{"SERVERLESS_ALERT_HISTORY(\n  [ DATE_RANGE_START => <constant_expr> ]\n  [ , DATE_RANGE_END => <constant_expr> ]\n  [ , ALERT_NAME => '<string>' ] )"},
	},
	"serverless_task_history": {
		Description: "Information Schema , Table functions",
		Signatures:  []string{"SERVERLESS_TASK_HISTORY(\n      [ DATE_RANGE_START => <constant_expr> ]\n      [ , DATE_RANGE_END => <constant_expr> ]\n      [ , TASK_NAME => '<string>' ] )"},
	},
	"sha1": {
		Description: "String & binary functions (Cryptographic Hash)",
		Signatures:  []string{"SHA1(<msg>)\n\nSHA1_HEX(<msg>)"},
	},
	"sha1_binary": {
		Description: "String & binary functions (Cryptographic Hash)",
		Signatures:  []string{"SHA1_BINARY(<msg>)"},
	},
	"sha2": {
		Description: "String & binary functions (Cryptographic Hash)",
		Signatures:  []string{"SHA2( <msg> [, <digest_size>] )\n\nSHA2_HEX( <msg> [, <digest_size>] )"},
	},
	"sha2_binary": {
		Description: "String & binary functions (Cryptographic Hash)",
		Signatures:  []string{"SHA2_BINARY(<msg> [, <digest_size>])"},
	},
	"show_python_packages_dependencies": {
		Description: "System functions (System Information)",
		Signatures:  []string{"SNOWFLAKE.SNOWPARK.SHOW_PYTHON_PACKAGES_DEPENDENCIES( '<Python_runtime_version>', '<packages_list>' )"},
	},
	"sign": {
		Description: "Numeric functions (Rounding and Truncation)",
		Signatures:  []string{"SIGN( <expr> )"},
	},
	"sin": {
		Description: "Numeric functions (Trigonometric)",
		Signatures:  []string{"SIN( <input_expr> )"},
	},
	"sinh": {
		Description: "Numeric functions (Trigonometric)",
		Signatures:  []string{"SINH( <input_expr> )"},
	},
	"skew": {
		Description: "Aggregate functions (General)",
		Signatures:  []string{"SKEW( <expr> )"},
	},
	"soundex": {
		Description: "String & binary functions",
		Signatures:  []string{"SOUNDEX( <varchar_expr> )"},
	},
	"soundex_p123": {
		Description: "String & binary functions",
		Signatures:  []string{"SOUNDEX_P123( <varchar_expr> )"},
	},
	"space": {
		Description: "String & binary functions (General)",
		Signatures:  []string{"SPACE(<n>)"},
	},
	"split": {
		Description: "String & binary functions (General)",
		Signatures:  []string{"SPLIT(<string>, <separator>)"},
	},
	"split_part": {
		Description: "String & binary functions (General)",
		Signatures:  []string{"SPLIT_PART(<string>, <delimiter>, <partNumber>)"},
	},
	"split_text_markdown_header": {
		Description: "The SPLIT_TEXT_MARKDOWN_HEADER function splits a Markdown-formatted document into structured text chunks based on header levels. The function returns an array of objects, where each object contains...",
		Signatures:  []string{"SNOWFLAKE.CORTEX.SPLIT_TEXT_MARKDOWN_HEADER (\n  '<text_to_split>',\n  '<headers_to_split_on>',\n  <chunk_size>,\n  [ <overlap> ]\n)"},
	},
	"split_text_recursive_character": {
		Description: "The SPLIT_TEXT_RECURSIVE_CHARACTER function splits a string into shorter stings, recursively, for preprocessing text to be used with text embedding or search indexing functions. The function return...",
		Signatures:  []string{"SNOWFLAKE.CORTEX.SPLIT_TEXT_RECURSIVE_CHARACTER (\n  '<text_to_split>',\n  '<format>',\n  <chunk_size>,\n  [ <overlap> ],\n  [ <separators> ]\n)"},
	},
	"split_to_table": {
		Description: "String & binary functions (General) , Table functions",
		Signatures:  []string{"SPLIT_TO_TABLE(<string>, <delimiter>)"},
	},
	"sqrt": {
		Description: "Numeric functions (Exponent and Root)",
		Signatures:  []string{"SQRT(expr)"},
	},
	"square": {
		Description: "Numeric functions (Exponent and Root)",
		Signatures:  []string{"SQUARE(expr)"},
	},
	"st_area": {
		Description: "Returns the area of the Polygon(s) in a GEOGRAPHY or GEOMETRY object.",
		Signatures:  []string{"ST_AREA( <geography_or_geometry_expression> )"},
	},
	"st_asewkb": {
		Description: "Given a value of type GEOGRAPHY or GEOMETRY, return the binary representation of that value in EWKB (extended well-known binary) format.",
		Signatures:  []string{"ST_ASEWKB( <geography_or_geometry_expression> )"},
	},
	"st_asewkt": {
		Description: "Given a value of type GEOGRAPHY or GEOMETRY, return the text (VARCHAR) representation of that value in EWKT (extended well-known text) format.",
		Signatures:  []string{"ST_ASEWKT( <geography_or_geometry_expression> )"},
	},
	"st_asgeojson": {
		Description: "Given a value of type GEOGRAPHY or GEOMETRY, return the GeoJSON representation of that value.",
		Signatures:  []string{"ST_ASGEOJSON( <geography_or_geometry_expression> )"},
	},
	"st_aswkb": {
		Description: "Given a value of type GEOGRAPHY or GEOMETRY, return the binary representation of that value in WKB (well-known binary) format.",
		Signatures:  []string{"ST_ASWKB( <geography_or_geometry_expression> )\n\nST_ASBINARY( <geography_or_geometry_expression> )"},
	},
	"st_aswkt": {
		Description: "Given a value of type GEOGRAPHY or GEOMETRY, return the text (VARCHAR) representation of that value in WKT (well-known text) format.",
		Signatures:  []string{"ST_ASWKT( <geography_or_geometry_expression> )\n\nST_ASTEXT( <geography_or_geometry_expression> )"},
	},
	"st_azimuth": {
		Description: "Given a Point that represents the origin (the location of the observer) and a specified Point, returns the azimuth in radians. Both Points must be either GEOGRAPHY or GEOMETRY objects.",
		Signatures:  []string{"ST_AZIMUTH( <geography_expression_for_origin> , <geography_expression_for_target> )\nST_AZIMUTH( <geometry_expression_for_origin> , <geometry_expression_for_target> )"},
	},
	"st_buffer": {
		Description: "Returns a GEOMETRY object that represents a MultiPolygon containing the points within a specified distance of the input GEOMETRY object. The returned object effectively represents a â€œbufferâ€ ar...",
		Signatures:  []string{"ST_BUFFER( <geometry_expression> , <distance> )"},
	},
	"st_centroid": {
		Description: "Returns the Point representing the geometric center of a GEOGRAPHY or GEOMETRY object.",
		Signatures:  []string{"ST_CENTROID( <geography_or_geometry_expression> )"},
	},
	"st_collect": {
		Description: "There are two forms of ST_COLLECT:",
		Signatures:  []string{"Scalar:\n\n    ST_COLLECT( <geography_expression_1> , <geography_expression_2> )\n\nAggregate:\n\n    ST_COLLECT( <geography_expression_1> )"},
	},
	"st_contains": {
		Description: "Returns TRUE if a GEOGRAPHY or GEOMETRY object is completely inside another object of the same type.",
		Signatures:  []string{"ST_CONTAINS( <geography_expression_1> , <geography_expression_2> )\n\nST_CONTAINS( <geometry_expression_1> , <geometry_expression_2> )"},
	},
	"st_coveredby": {
		Description: "Returns TRUE if no point in one geospatial object is outside another geospatial object. In other words:",
		Signatures:  []string{"ST_COVEREDBY( <geography_expression_1> , <geography_expression_2> )\n\nST_COVEREDBY( <geometry_expression_1> , <geometry_expression_2> )"},
	},
	"st_covers": {
		Description: "Returns TRUE if no point in one geospatial object is outside of another geospatial object. In other words:",
		Signatures:  []string{"ST_COVERS( <geography_expression_1> , <geography_expression_2> )\n\nST_COVERS( <geometry_expression_1> , <geometry_expression_2> )"},
	},
	"st_difference": {
		Description: "Given two input GEOGRAPHY objects, returns a GEOGRAPHY object that represents the points in the first object that are not in the second object (i.e. the difference between the two objects).",
		Signatures:  []string{"ST_DIFFERENCE( <geography_expression_1> , <geography_expression_2> )"},
	},
	"st_dimension": {
		Description: "Given a value of type GEOGRAPHY or GEOMETRY, return the â€œdimensionâ€ of the value. The dimension of a GEOGRAPHY or GEOMETRY value is:",
		Signatures:  []string{"ST_DIMENSION( <geography_or_geometry_expression> )"},
	},
	"st_disjoint": {
		Description: "Returns TRUE if the two GEOGRAPHY objects or the two GEOMETRY objects are disjoint (i.e. do not share any portion of space). ST_DISJOINT is equivalent to NOT ST_INTERSECTS(expr1, expr2).",
		Signatures:  []string{"ST_DISJOINT( <geography_expression_1> , <geography_expression_2> )\n\nST_DISJOINT( <geometry_expression_1> , <geometry_expression_2> )"},
	},
	"st_distance": {
		Description: "Returns the minimum great circle distance between two GEOGRAPHY or the minimum Euclidean distance between two GEOMETRY objects.",
		Signatures:  []string{"ST_DISTANCE( <geography_or_geometry_expression_1> , <geography_or_geometry_expression_2> )"},
	},
	"st_dwithin": {
		Description: "Returns TRUE if the minimum great circle distance between two points (two GEOGRAPHY objects) is within the specified distance. Otherwise, returns FALSE.",
		Signatures:  []string{"ST_DWITHIN( <geography_expression_1> , <geography_expression_2> , <distance_in_meters> )"},
	},
	"st_endpoint": {
		Description: "Returns the last Point in a LineString.",
		Signatures:  []string{"ST_ENDPOINT( <geography_or_geometry_expression> )"},
	},
	"st_envelope": {
		Description: "This function has been deprecated for GEOGRAPHY objects. The use of this function with GEOGRAPHY objects will be obsoleted in a future release (TBD).",
		Signatures:  []string{"ST_ENVELOPE( <geography_or_geometry_expression> )"},
	},
	"st_geogfromgeohash": {
		Description: "Geospatial functions, Conversion functions",
		Signatures:  []string{"ST_GEOGFROMGEOHASH( <geohash> [, <precision> ] )"},
	},
	"st_geogpointfromgeohash": {
		Description: "Geospatial functions, Conversion functions",
		Signatures:  []string{"ST_GEOGPOINTFROMGEOHASH( <geohash> )"},
	},
	"st_geographyfromwkb": {
		Description: "Geospatial functions, Conversion functions",
		Signatures:  []string{"ST_GEOGRAPHYFROMWKB( <varchar_or_binary_expression> [ , <allow_invalid> ] )\n\nST_GEOGFROMWKB( <varchar_or_binary_expression> [ , <allow_invalid> ] )\n\nST_GEOGRAPHYFROMEWKB( <varchar_or_binary_expression> [ , <allow_invalid> ] )\n\nST_GEOGFROMEWKB( <varchar_or_binary_expression> [ , <allow_invalid> ] )"},
	},
	"st_geographyfromwkt": {
		Description: "Geospatial functions, Conversion functions",
		Signatures:  []string{"ST_GEOGRAPHYFROMWKT( <varchar_expression> [ , <allow_invalid> ] )\n\nST_GEOGFROMWKT( <varchar_expression> [ , <allow_invalid> ] )\n\nST_GEOGRAPHYFROMEWKT( <varchar_expression> [ , <allow_invalid> ] )\n\nST_GEOGFROMEWKT( <varchar_expression> [ , <allow_invalid> ] )\n\nST_GEOGRAPHYFROMTEXT( <varchar_expression> [ , <allow_invalid> ] )\n\nST_GEOGFROMTEXT( <varchar_expression> [ , <allow_invalid> ] )"},
	},
	"st_geohash": {
		Description: "Returns the geohash for a GEOGRAPHY or GEOMETRY object. A geohash is a short base32 string that identifies a great circle rectangle containing a location in the world.",
		Signatures:  []string{"ST_GEOHASH( <geography_expression> [, <precision> ] )\n\nST_GEOHASH( <geometry_expression> [, <precision> ] )"},
	},
	"st_geometryfromwkb": {
		Description: "Geospatial functions, Conversion functions",
		Signatures:  []string{"ST_GEOMETRYFROMWKB( <varchar_or_binary_expression> [ , <srid> ]  [ , <allow_invalid> ] )\n\nST_GEOMFROMWKB( <varchar_or_binary_expression> [ , <srid> ]  [ , <allow_invalid> ] )\n\nST_GEOMETRYFROMEWKB( <varchar_or_binary_expression> [ , <srid> ] [ , <allow_invalid> ] )\n\nST_GEOMFROMEWKB( <varchar_or_binary_expression> [ , <srid> ] [ , <allow_invalid> ] )"},
	},
	"st_geometryfromwkt": {
		Description: "Geospatial functions, Conversion functions",
		Signatures:  []string{"ST_GEOMETRYFROMWKT( <varchar_expression> [ , <srid> ] [ , <allow_invalid> ] )\n\nST_GEOMFROMWKT( <varchar_expression> [ , <srid> ] [ , <allow_invalid> ] )\n\nST_GEOMETRYFROMEWKT( <varchar_expression> [ , <srid> ] [ , <allow_invalid> ] )\n\nST_GEOMFROMEWKT( <varchar_expression> [ , <srid> ] [ , <allow_invalid> ] )\n\nST_GEOMETRYFROMTEXT( <varchar_expression> [ , <srid> ] [ , <allow_invalid> ] )\n\nST_GEOMFROMTEXT( <varchar_expression> [ , <srid> ] [ , <allow_invalid> ] )"},
	},
	"st_geomfromgeohash": {
		Description: "Returns a GEOMETRY object for the polygon that represents the boundaries of a geohash.",
		Signatures:  []string{"ST_GEOMFROMGEOHASH( <geohash> [, <precision> ] )"},
	},
	"st_geompointfromgeohash": {
		Description: "Returns a GEOMETRY object for the point that represents center of a geohash.",
		Signatures:  []string{"ST_GEOMPOINTFROMGEOHASH( <geohash> )"},
	},
	"st_hausdorffdistance": {
		Description: "Returns the discrete Hausdorff distance between two GEOGRAPHY objects.",
		Signatures:  []string{"ST_HAUSDORFFDISTANCE( <geography_expression_1> , <geography_expression_2> )"},
	},
	"st_interpolate": {
		Description: "Given an input GEOGRAPHY object, returns an interpolated object that is within a specified tolerance.",
		Signatures:  []string{"ST_INTERPOLATE( <geography_expression> [ , <tolerance> ] )"},
	},
	"st_intersection": {
		Description: "Given two input GEOGRAPHY objects, returns a GEOGRAPHY object that represents the shape containing the set of points that are common to both input objects (i.e. the intersection of the two objects).",
		Signatures:  []string{"ST_INTERSECTION( <geography_expression_1> , <geography_expression_2> )"},
	},
	"st_intersection_agg": {
		Description: "Given a GEOGRAPHY column, returns a GEOGRAPHY object that represents the shape containing the combined set of points that are common to the shapes represented by the objects in the column (that is,...",
		Signatures:  []string{"ST_INTERSECTION_AGG( <geography_column> )"},
	},
	"st_intersects": {
		Description: "Returns TRUE if the two GEOGRAPHY objects or the two GEOMETRY objects intersect (i.e. share any portion of space).",
		Signatures:  []string{"ST_INTERSECTS( <geography_expression_1> , <geography_expression_2> )\n\nST_INTERSECTS( <geometry_expression_1> , <geometry_expression_2> )"},
	},
	"st_isvalid": {
		Description: "Returns TRUE if the specified GEOGRAPHY or GEOMETRY object represents a valid shape. Examples of invalid shapes include shapes with self-intersections and spikes.",
		Signatures:  []string{"ST_ISVALID( <geography_or_geometry_expression> )"},
	},
	"st_length": {
		Description: "Returns the great circle length of the LineString(s) in a GEOGRAPHY object or the Euclidean length of the LineString(s) in a GEOMETRY object.",
		Signatures:  []string{"ST_LENGTH( <geography_or_geometry_expression> )"},
	},
	"st_makegeompoint": {
		Description: "Constructs a GEOMETRY object that represents a Point with the specified longitude and latitude.",
		Signatures:  []string{"ST_MAKEGEOMPOINT( <longitude> , <latitude> )"},
	},
	"st_makeline": {
		Description: "Constructs a GEOGRAPHY or GEOMETRY object that represents a line connecting the points in the input objects.",
		Signatures:  []string{"ST_MAKELINE( <geography_expression_1> , <geography_expression_2> )\n\nST_MAKELINE( <geometry_expression_1> , <geometry_expression_2> )"},
	},
	"st_makepoint": {
		Description: "Constructs a GEOGRAPHY object that represents a point with the specified longitude and latitude.",
		Signatures:  []string{"ST_MAKEPOINT( <longitude> , <latitude> )"},
	},
	"st_makepolygon": {
		Description: "Constructs a GEOGRAPHY or GEOMETRY object that represents a Polygon without holes. The function uses the specified LineString as the outer loop.",
		Signatures:  []string{"ST_MAKEPOLYGON( <geography_or_geometry_expression> )"},
	},
	"st_makepolygonoriented": {
		Description: "Constructs a GEOGRAPHY object that represents a Polygon without holes. The function uses the specified LineString as the outer loop.",
		Signatures:  []string{"ST_MAKEPOLYGONORIENTED( <geography_expression> )"},
	},
	"st_npoints": {
		Description: "Returns the number of points in a GEOGRAPHY or GEOGRAPHY object.",
		Signatures:  []string{"ST_NPOINTS( <geography_or_geometry_expression> )"},
	},
	"st_perimeter": {
		Description: "Returns the length of the perimeter of the polygon(s) in a GEOGRAPHY or GEOMETRY object.",
		Signatures:  []string{"ST_PERIMETER( <geography_or_geometry_expression> )"},
	},
	"st_pointn": {
		Description: "Returns a Point at a specified index in a LineString.",
		Signatures:  []string{"ST_POINTN( <geography_or_geometry_expression> , <index> )"},
	},
	"st_setsrid": {
		Description: "Returns a GEOMETRY object that has its SRID (spatial reference system identifier) set to the specified value.",
		Signatures:  []string{"ST_SETSRID( <geometry_expression> , <srid> )"},
	},
	"st_simplify": {
		Description: "Given an input GEOGRAPHY or GEOMETRY object that represents a Line or Polygon, returns a simpler approximation of the object. The function identifies and removes selected vertices, resulting in a s...",
		Signatures:  []string{"ST_SIMPLIFY( <geography_expression>, <tolerance> [ , <preserve_collapsed> ] )\nST_SIMPLIFY( <geometry_expression>, <tolerance> )"},
	},
	"st_srid": {
		Description: "Returns the SRID (spatial reference system identifier) of a GEOGRAPHY or GEOMETRY object.",
		Signatures:  []string{"ST_SRID( <geography_or_geometry_expression> )"},
	},
	"st_startpoint": {
		Description: "Returns the first Point in a LineString.",
		Signatures:  []string{"ST_STARTPOINT( <geography_or_geometry_expression> )"},
	},
	"st_symdifference": {
		Description: "Given two input GEOGRAPHY objects, returns a GEOGRAPHY object that represents the set of points from both input objects that are not part of the intersection of the objects (i.e. the symmetric diff...",
		Signatures:  []string{"ST_SYMDIFFERENCE( <geography_expression_1> , <geography_expression_2> )"},
	},
	"st_transform": {
		Description: "Converts a GEOMETRY object from one spatial reference system (SRS) to another.",
		Signatures:  []string{"ST_TRANSFORM( <geometry_expression> [ , <from_srid> ] , <to_srid> );"},
	},
	"st_union": {
		Description: "Given two input GEOGRAPHY objects, returns a GEOGRAPHY object that represents the combined set of shapes for both objects (i.e. the union of the two shapes).",
		Signatures:  []string{"ST_UNION( <geography_expression_1> , <geography_expression_2> )"},
	},
	"st_union_agg": {
		Description: "Given a GEOGRAPHY column, returns a GEOGRAPHY object that represents the combined set of points that are in at least one of the shapes represented by the objects in the column (that is, the union o...",
		Signatures:  []string{"ST_UNION_AGG( <geography_column> )"},
	},
	"st_within": {
		Description: "Returns true if the first geospatial object is fully contained by the second geospatial object. In other words:",
		Signatures:  []string{"ST_WITHIN( <geography_expression_1> , <geography_expression_2> )\n\nST_WITHIN( <geometry_expression_1> , <geometry_expression_2> )"},
	},
	"st_x": {
		Description: "Returns the longitude (X coordinate) of a Point represented by a GEOGRAPHY or GEOMETRY object.",
		Signatures:  []string{"ST_X( <geography_or_geometry_expression> )"},
	},
	"st_xmax": {
		Description: "Returns the maximum longitude (X coordinate) of all points contained in the specified GEOGRAPHY or GEOMETRY object.",
		Signatures:  []string{"ST_XMAX( <geography_or_geometry_expression> )"},
	},
	"st_xmin": {
		Description: "Returns the minimum longitude (X coordinate) of all points contained in the specified GEOGRAPHY or GEOMETRY object.",
		Signatures:  []string{"ST_XMIN( <geography_or_geometry_expression> )"},
	},
	"st_y": {
		Description: "Returns the latitude (Y coordinate) of a Point represented by a GEOGRAPHY or GEOMETRY object.",
		Signatures:  []string{"ST_Y( <geography_or_geometry_expression> )"},
	},
	"st_ymax": {
		Description: "Returns the maximum latitude (Y coordinate) of all points contained in the specified GEOGRAPHY or GEOMETRY object.",
		Signatures:  []string{"ST_YMAX( <geography_or_geometry_expression> )"},
	},
	"st_ymin": {
		Description: "Returns the minimum latitude (Y coordinate) of all points contained in the specified GEOGRAPHY or GEOMETRY object.",
		Signatures:  []string{"ST_YMIN( <geography_or_geometry_expression> )"},
	},
	"stage_directory_file_registration_history": {
		Description: "Information Schema , Table functions",
		Signatures:  []string{"STAGE_DIRECTORY_FILE_REGISTRATION_HISTORY (\n      STAGE_NAME => '<string>'\n      [, START_TIME => <constant_expr> ] )"},
	},
	"stage_storage_usage_history": {
		Description: "Information Schema , Table functions",
		Signatures:  []string{"STAGE_STORAGE_USAGE_HISTORY(\n      [ DATE_RANGE_START => <constant_expr> ]\n      [, DATE_RANGE_END => <constant_expr> ] )"},
	},
	"startswith": {
		Description: "String & binary functions (Matching/Comparison)",
		Signatures:  []string{"STARTSWITH( <expr1> , <expr2> )"},
	},
	"stddev": {
		Description: "Data metric functions",
		Signatures:  []string{"SNOWFLAKE.CORE.STDDEV(<query>)"},
	},
	"stddev_pop": {
		Description: "Aggregate functions (General) , Window function syntax and usage (General)",
		Signatures:  []string{"STDDEV_POP( [ DISTINCT ] <expr1>)"},
	},
	"storage_lifecycle_policy_history": {
		Description: "Table functions (Information Schema)",
		Signatures:  []string{"STORAGE_LIFECYCLE_POLICY_HISTORY(\n  REF_ENTITY_NAME => '<string>',\n  REF_ENTITY_DOMAIN => '<string>'\n  [, TIME_RANGE_START => <constant_expr> ]\n  [, TIME_RANGE_END => <constant_expr> ]\n  [, RESULT_LIMIT => <integer> ] )"},
	},
	"strip_null_value": {
		Description: "Semi-structured and structured data functions (Parsing)",
		Signatures:  []string{"STRIP_NULL_VALUE( <variant_expr> )"},
	},
	"strtok": {
		Description: "String & binary functions (General)",
		Signatures:  []string{"STRTOK(<string> [,<delimiter>] [,<partNr>])"},
	},
	"strtok_split_to_table": {
		Description: "String & binary functions (General) , Table functions",
		Signatures:  []string{"STRTOK_SPLIT_TO_TABLE(<string> [,<delimiter_list>])"},
	},
	"strtok_to_array": {
		Description: "String & binary functions (General) , Semi-structured and structured data functions (Conversion/Casting)",
		Signatures:  []string{"STRTOK_TO_ARRAY( <string> [ , <delimiter> ] )"},
	},
	"substr": {
		Description: "String & binary functions (Matching/Comparison)",
		Signatures:  []string{"SUBSTR( <base_expr>, <start_expr> [ , <length_expr> ] )\n\nSUBSTRING( <base_expr>, <start_expr> [ , <length_expr> ] )"},
	},
	"sum": {
		Description: "Aggregate functions (General) , Window function syntax and usage (General)",
		Signatures:  []string{"SUM( [ DISTINCT ] <expr1> )"},
	},
	"summarize": {
		Description: "String & binary functions (AI Functions)",
		Signatures:  []string{"SNOWFLAKE.CORTEX.SUMMARIZE(<text>)"},
	},
	"sys_context": {
		Description: "Context functions (General)",
		Signatures:  []string{"SYS_CONTEXT(\n  '<namespace>' ,\n  '<property>'\n)"},
	},
	"sysdate": {
		Description: "Context functions (General)",
		Signatures:  []string{"SYSDATE()"},
	},
	"systimestamp": {
		Description: "Context functions (General)",
		Signatures:  []string{"SYSTIMESTAMP()"},
	},
	"tag_references": {
		Description: "Information Schema , Table functions",
		Signatures:  []string{"TAG_REFERENCES( '<object_name>' , '<object_domain>' )"},
	},
	"tag_references_all_columns": {
		Description: "Information Schema , Table functions",
		Signatures:  []string{"TAG_REFERENCES_ALL_COLUMNS( '<object_name>' , '<object_domain>' )"},
	},
	"tag_references_with_lineage": {
		Description: "Account Usage table functions , Table functions",
		Signatures:  []string{"TAG_REFERENCES_WITH_LINEAGE( '<name>' )"},
	},
	"tan": {
		Description: "Numeric functions (Trigonometric)",
		Signatures:  []string{"TAN( <input_expr> )"},
	},
	"tanh": {
		Description: "Numeric functions (Trigonometric)",
		Signatures:  []string{"TANH( <real_expr> )"},
	},
	"task_dependents": {
		Description: "Information Schema , Table functions",
		Signatures:  []string{"TASK_DEPENDENTS(\n      TASK_NAME => '<string>'\n      [, RECURSIVE => <Boolean> ] )"},
	},
	"task_history": {
		Description: "Information Schema , Table functions",
		Signatures:  []string{"TASK_HISTORY(\n      [ SCHEDULED_TIME_RANGE_START => <constant_expr> ]\n      [, SCHEDULED_TIME_RANGE_END => <constant_expr> ]\n      [, RESULT_LIMIT => <integer> ]\n      [, TASK_NAME => '<string>' ]\n      [, ERROR_ONLY => { TRUE | FALSE } ]\n      [, ROOT_TASK_ID => '<string>'] )"},
	},
	"text_html": {
		Description: "Notification functions (Message Construction)",
		Signatures:  []string{"SNOWFLAKE.NOTIFICATION.TEXT_HTML( '<message>' )"},
	},
	"text_plain": {
		Description: "Notification functions (Message Construction)",
		Signatures:  []string{"SNOWFLAKE.NOTIFICATION.TEXT_PLAIN( '<message>' )"},
	},
	"time_from_parts": {
		Description: "Date & time functions",
		Signatures:  []string{"TIME_FROM_PARTS( <hour>, <minute>, <second> [, <nanoseconds>] )"},
	},
	"time_slice": {
		Description: "Date & time functions",
		Signatures:  []string{"TIME_SLICE( <date_or_time_expr> , <slice_length> , <date_or_time_part> [ , <start_or_end> ] )"},
	},
	"timeadd": {
		Description: "Date & time functions",
		Signatures:  []string{"TIMEADD( <date_or_time_part> , <value> , <date_or_time_expr> )"},
	},
	"timediff": {
		Description: "Date & time functions",
		Signatures:  []string{"TIMEDIFF( <date_or_time_part> , <date_or_time_expr1> , <date_or time_expr2> )"},
	},
	"timestamp_from_parts": {
		Description: "Date & time functions",
		Signatures:  []string{"TIMESTAMP_FROM_PARTS( <year>, <month>, <day>, <hour>, <minute>, <second> [, <nanosecond> ] [, <time_zone> ] )\n\nTIMESTAMP_FROM_PARTS( <date_expr>, <time_expr> )"},
	},
	"timestampadd": {
		Description: "Date & time functions",
		Signatures:  []string{"TIMESTAMPADD( <date_or_time_part> , <time_value> , <date_or_time_expr> )"},
	},
	"timestampdiff": {
		Description: "Date & time functions",
		Signatures:  []string{"TIMESTAMPDIFF( <date_or_time_part> , <date_or_time_expr1> , <date_or_time_expr2> )"},
	},
	"to_array": {
		Description: "Conversion functions , Semi-structured and structured data functions (Array/Object)",
		Signatures:  []string{"TO_ARRAY( <expr> )"},
	},
	"to_binary": {
		Description: "Converts the input expression to a binary value. For NULL input, the output is NULL.",
		Signatures:  []string{"TO_BINARY( <string_expr> [, '<format>'] )\nTO_BINARY( <variant_expr> )"},
	},
	"to_boolean": {
		Description: "Converts the input text or numeric expression to a BOOLEAN value.",
		Signatures:  []string{"TO_BOOLEAN( <string_or_numeric_expr> )"},
	},
	"to_char": {
		Description: "Converts the input expression to a string. For NULL input, the output is NULL.",
		Signatures:  []string{"TO_CHAR( <expr> )\nTO_CHAR( <numeric_expr> [, '<format>' ] )\nTO_CHAR( <date_or_time_expr> [, '<format>' ] )\nTO_CHAR( <binary_expr> [, '<format>' ] )\n\nTO_VARCHAR( <expr> )\nTO_VARCHAR( <numeric_expr> [, '<format>' ] )\nTO_VARCHAR( <date_or_time_expr> [, '<format>' ] )\nTO_VARCHAR( <binary_expr> [, '<format>' ] )"},
	},
	"to_decfloat": {
		Description: "Converts an expression to a decimal floating-point number (DECFLOAT).",
		Signatures:  []string{"TO_DECFLOAT( <expr> [ , '<format>' ] )"},
	},
	"to_decimal": {
		Description: "Converts an input expression to a fixed-point number.",
		Signatures:  []string{"TO_DECIMAL( <expr> [, '<format>' ] [, <precision> [, <scale> ] ] )\n\nTO_NUMBER( <expr> [, '<format>' ] [, <precision> [, <scale> ] ] )\n\nTO_NUMERIC( <expr> [, '<format>' ] [, <precision> [, <scale> ] ] )"},
	},
	"to_double": {
		Description: "Converts an expression to a double-precision floating-point number.",
		Signatures:  []string{"TO_DOUBLE( <expr> [, '<format>' ] )"},
	},
	"to_file": {
		Description: "Constructs a value of type FILE from a file location or from metadata.",
		Signatures:  []string{"TO_FILE( <stage_name>, <relative_path> )\n\nTO_FILE( <file_url> )\n\nTO_FILE( <metadata> )"},
	},
	"to_geography": {
		Description: "Geospatial functions, Conversion functions",
		Signatures:  []string{"TO_GEOGRAPHY( <varchar_expression> [ , <allow_invalid> ] )\n\nTO_GEOGRAPHY( <binary_expression> [ , <allow_invalid> ] )\n\nTO_GEOGRAPHY( <variant_expression> [ , <allow_invalid> ] )\n\nTO_GEOGRAPHY( <geometry_expression> [ , <allow_invalid> ] )"},
	},
	"to_geometry": {
		Description: "Geospatial functions, Conversion functions",
		Signatures:  []string{"TO_GEOMETRY( <varchar_expression> [ , <srid> ] [ , <allow_invalid> ] )\n\nTO_GEOMETRY( <binary_expression> [ , <srid> ] [ , <allow_invalid> ] )\n\nTO_GEOMETRY( <variant_expression> [ , <srid> ] [ , <allow_invalid> ] )\n\nTO_GEOMETRY( <geography_expression> [ , <srid> ] [ , <allow_invalid> ] )"},
	},
	"to_json": {
		Description: "Conversion functions , Semi-structured and structured data functions (Cast)",
		Signatures:  []string{"TO_JSON( <expr> )"},
	},
	"to_object": {
		Description: "Conversion functions , Semi-structured and structured data functions (Array/Object)",
		Signatures:  []string{"TO_OBJECT( <expr> )"},
	},
	"to_query": {
		Description: "Returns a result set based on SQL text and an optional set of arguments that are passed to the SQL text if it is parameterized. The function compiles the SQL text as the definition of a subquery in...",
		Signatures:  []string{"TO_QUERY( SQL => '<string>' [ , <arg> => '<value>' [, <arg> => '<value>' ...] ] )"},
	},
	"to_time": {
		Description: "Conversion functions , Date & time functions",
		Signatures:  []string{"TO_TIME( <string_expr> [, <format> ] )\nTO_TIME( <timestamp_expr> )\nTO_TIME( '<integer>' )\nTO_TIME( <variant_expr> )\n\nTIME( <string_expr> )\nTIME( <timestamp_expr> )\nTIME( '<integer>' )\nTIME( <variant_expr> )"},
	},
	"to_timestamp": {
		Description: "Conversion functions , Date & time functions",
		Signatures:  []string{"timestampFunction ( <numeric_expr> [ , <scale> ] )\n\ntimestampFunction ( <date_expr> )\n\ntimestampFunction ( <timestamp_expr> )\n\ntimestampFunction ( <string_expr> [ , <format> ] )\n\ntimestampFunction ( '<integer>' )\n\ntimestampFunction ( <variant_expr> )"},
	},
	"to_variant": {
		Description: "Converts any value to a VARIANT value or NULL (if input is NULL).",
		Signatures:  []string{"TO_VARIANT( <expr> )"},
	},
	"to_xml": {
		Description: "Conversion functions , Semi-structured and structured data functions (Cast)",
		Signatures:  []string{"TO_XML( <expression> )"},
	},
	"transform": {
		Description: "Semi-structured and structured data functions (Higher-order)",
		Signatures:  []string{"TRANSFORM( <array> , <lambda_expression> )"},
	},
	"translate": {
		Description: "String & binary functions (AI Functions)",
		Signatures:  []string{"SNOWFLAKE.CORTEX.TRANSLATE(\n    <text>, <source_language>, <target_language>)"},
	},
	"trim": {
		Description: "String & binary functions (General)",
		Signatures:  []string{"TRIM( <expr> [, <characters> ] )"},
	},
	"truncate": {
		Description: "Numeric functions (Rounding and Truncation)",
		Signatures:  []string{"TRUNCATE( <input_expr> [ , <scale_expr> ] )\n\nTRUNC( <input_expr> [ , <scale_expr> ] )"},
	},
	"try_base64_decode_binary": {
		Description: "String & binary functions (Encoding/Decoding)",
		Signatures:  []string{"TRY_BASE64_DECODE_BINARY(<input> [, <alphabet>])"},
	},
	"try_base64_decode_string": {
		Description: "String & binary functions (Encoding/Decoding)",
		Signatures:  []string{"TRY_BASE64_DECODE_STRING(<input> [, <alphabet>])"},
	},
	"try_cast": {
		Description: "A special version of CAST , :: that is available for a subset of data type conversions. It performs the same operation (i.e. converts a value of one data type into another data type), but returns a...",
		Signatures:  []string{"TRY_CAST( <source_string_expr> AS <target_data_type> )"},
	},
	"try_complete": {
		Description: "String & binary functions (AI Functions)",
		Signatures:  []string{"SNOWFLAKE.CORTEX.TRY_COMPLETE( <model>, <prompt_or_history> [ , <options> ] )"},
	},
	"try_decrypt": {
		Description: "A special version of DECRYPT that returns a NULL value if an error occurs during decryption.",
		Signatures:  []string{"TRY_DECRYPT( <value_to_decrypt> , <passphrase> ,\n         [ [ <additional_authenticated_data> , ] <encryption_method> ]\n       )"},
	},
	"try_decrypt_raw": {
		Description: "A special version of DECRYPT_RAW that returns a NULL value if an error occurs during decryption.",
		Signatures:  []string{"TRY_DECRYPT_RAW( <value_to_decrypt> , <key> , <iv> ,\n         [ [ [ <additional_authenticated_data> , ] <encryption_method> , ] <aead_tag> ]\n       )"},
	},
	"try_hex_decode_binary": {
		Description: "String & binary functions (Encoding/Decoding)",
		Signatures:  []string{"TRY_HEX_DECODE_BINARY(<input>)"},
	},
	"try_hex_decode_string": {
		Description: "String & binary functions (Encoding/Decoding)",
		Signatures:  []string{"TRY_HEX_DECODE_STRING(<input>)"},
	},
	"try_parse_json": {
		Description: "Semi-structured and structured data functions (Parsing)",
		Signatures:  []string{"TRY_PARSE_JSON( <expr> [ , '<parameter>' ] )"},
	},
	"try_to_binary": {
		Description: "A special version of TO_BINARY that performs the same operation (i.e. converts an input expression to a binary value), but with error handling support (i.e. if the conversion cannot be performed, i...",
		Signatures:  []string{"TRY_TO_BINARY( <string_expr> [, '<format>'] )"},
	},
	"try_to_boolean": {
		Description: "A special version of TO_BOOLEAN that performs the same operation (that is, converts an input expression to a Boolean value), but with error-handling support. If the conversion canâ€™t be performed,...",
		Signatures:  []string{"TRY_TO_BOOLEAN( <string_expr> )"},
	},
	"try_to_date": {
		Description: "Conversion functions , Date & time functions",
		Signatures:  []string{"TRY_TO_DATE( <string_expr> [, <format> ] )\nTRY_TO_DATE( '<integer>' )"},
	},
	"try_to_decfloat": {
		Description: "A special version of TO_DECFLOAT that performs the same operation â€” that is, converts an input expression to a DECFLOAT â€” but with error-handling support. If the conversion canâ€™t be performed...",
		Signatures:  []string{"TRY_TO_DECFLOAT( <string_expr> [ , '<format>' ] )"},
	},
	"try_to_decimal": {
		Description: "A special version of TO_DECIMAL , TO_NUMBER , TO_NUMERIC that performs the same operation of converting an input expression to a fixed-point number, but has error-handling support so that the funct...",
		Signatures:  []string{"TRY_TO_DECIMAL( <string_expr> [, '<format>' ] [, <precision> [, <scale> ] ] )\n\nTRY_TO_NUMBER( <string_expr> [, '<format>' ] [, <precision> [, <scale> ] ] )\n\nTRY_TO_NUMERIC( <string_expr> [, '<format>' ] [, <precision> [, <scale> ] ] )"},
	},
	"try_to_double": {
		Description: "A special version of TO_DOUBLE that performs the same operation (that is, converts an input expression to a double-precision floating-point number), but with error-handling support (that is, if the...",
		Signatures:  []string{"TRY_TO_DOUBLE( <string_expr> [, '<format>' ] )"},
	},
	"try_to_file": {
		Description: "A version of TO_FILE that returns NULL instead of raising an error.",
		Signatures:  []string{"TRY_TO_FILE( <stage_name>, <relative_path> )\n\nTRY_TO_FILE( <file_url> )\n\nTRY_TO_FILE( <metadata> )"},
	},
	"try_to_geography": {
		Description: "Geospatial functions, Conversion functions",
		Signatures:  []string{"TRY_TO_GEOGRAPHY( <varchar_expression> [ , <allow_invalid> ] )\n\nTRY_TO_GEOGRAPHY( <binary_expression> [ , <allow_invalid> ] )\n\nTRY_TO_GEOGRAPHY( <variant_expression> [ , <allow_invalid> ] )"},
	},
	"try_to_geometry": {
		Description: "Geospatial functions, Conversion functions",
		Signatures:  []string{"TRY_TO_GEOMETRY( <varchar_expression> [ , <srid> ] [ , <allow_invalid> ] )\n\nTRY_TO_GEOMETRY( <binary_expression> [ , <srid> ] [ , <allow_invalid> ] )\n\nTRY_TO_GEOMETRY( <variant_expression> [ , <srid> ] [ , <allow_invalid> ] )"},
	},
	"try_to_time": {
		Description: "A special version of TO_TIME , TIME that performs the same operation (i.e. converts an input expression into a time), but with error-handling support (i.e. if the conversion cannot be performed, it...",
		Signatures:  []string{"TRY_TO_TIME( <string_expr> [, <format> ] )\nTRY_TO_TIME( '<integer>' )"},
	},
	"try_to_timestamp": {
		Description: "A special version of TO_TIMESTAMP / TO_TIMESTAMP_* that performs the same operation (i.e. converts an input expression into a timestamp), but with error-handling support (i.e. if the conversion can...",
		Signatures:  []string{"timestampFunction ( <string_expr> [, <format> ] )\ntimestampFunction ( '<integer>' )"},
	},
	"typeof": {
		Description: "Semi-structured and structured data functions (Type Predicates)",
		Signatures:  []string{"TYPEOF( <expr> )"},
	},
	"unicode": {
		Description: "String & binary functions (General)",
		Signatures:  []string{"UNICODE( <input> )"},
	},
	"uniform": {
		Description: "Data generation functions",
		Signatures:  []string{"UNIFORM( <min> , <max> , <gen> )"},
	},
	"unique_count": {
		Description: "Data metric functions",
		Signatures:  []string{"SNOWFLAKE.CORE.UNIQUE_COUNT(<query>)"},
	},
	"upper": {
		Description: "String & binary functions (Case Conversion)",
		Signatures:  []string{"UPPER( <expr> )"},
	},
	"uuid_string": {
		Description: "String & binary functions (General) , Data generation functions",
		Signatures:  []string{"UUID_STRING()\n\nUUID_STRING( '<uuid>' , '<name>' )"},
	},
	"validate": {
		Description: "Validates the files loaded in a past execution of the COPY INTO <table> command and returns all the errors encountered during the load, rather than just the first error.",
		Signatures:  []string{"VALIDATE( [<namespace>.]<table_name> , JOB_ID => { '<query_id>' | '_last' } )"},
	},
	"validate_pipe_load": {
		Description: "Information Schema , Table functions",
		Signatures:  []string{"VALIDATE_PIPE_LOAD(\n      PIPE_NAME => '<string>'\n       , START_TIME => <constant_expr>\n      [, END_TIME => <constant_expr> ] )"},
	},
	"var_pop": {
		Description: "Aggregate functions (General) , Window function syntax and usage (General)",
		Signatures:  []string{"VAR_POP( [ DISTINCT ] <expr1> )"},
	},
	"var_samp": {
		Description: "Aggregate functions (General) , Window function syntax and usage (General)",
		Signatures:  []string{"VAR_SAMP( [DISTINCT] <expr1> )"},
	},
	"variance": {
		Description: "Aggregate functions (General) , Window function syntax and usage (General)",
		Signatures:  []string{"VARIANCE( [ DISTINCT ] <expr1> )"},
	},
	"variance_pop": {
		Description: "Aggregate functions (General) , Window function syntax and usage (General)",
		Signatures:  []string{"VARIANCE_POP( [ DISTINCT ] <expr1> )"},
	},
	"vector_avg": {
		Description: "Vector functions , Aggregate functions",
		Signatures:  []string{"VECTOR_AVG( <vector_column> )"},
	},
	"vector_cosine_similarity": {
		Description: "Computes the cosine similarity between two vectors.",
		Signatures:  []string{"VECTOR_COSINE_SIMILARITY( <vector>, <vector> )"},
	},
	"vector_inner_product": {
		Description: "Computes the inner product of two vectors.",
		Signatures:  []string{"VECTOR_INNER_PRODUCT( <vector>, <vector> )"},
	},
	"vector_l1_distance": {
		Description: "Computes the L1 distance between two vectors.",
		Signatures:  []string{"VECTOR_L1_DISTANCE( <vector>, <vector> )"},
	},
	"vector_l2_distance": {
		Description: "Computes the L2 distance between two vectors.",
		Signatures:  []string{"VECTOR_L2_DISTANCE( <vector>, <vector> )"},
	},
	"vector_max": {
		Description: "Vector functions , Aggregate functions",
		Signatures:  []string{"VECTOR_MAX( <vector_column> )"},
	},
	"vector_min": {
		Description: "Vector functions , Aggregate functions",
		Signatures:  []string{"VECTOR_MIN( <vector_column> )"},
	},
	"vector_sum": {
		Description: "Vector functions , Aggregate functions",
		Signatures:  []string{"VECTOR_SUM( <vector_column> )"},
	},
	"warehouse_load_history": {
		Description: "Information Schema , Table functions",
		Signatures:  []string{"WAREHOUSE_LOAD_HISTORY(\n      [ DATE_RANGE_START => <constant_expr> ]\n      [, DATE_RANGE_END => <constant_expr> ]\n      [, WAREHOUSE_NAME => '<string>' ] )"},
	},
	"warehouse_metering_history": {
		Description: "Information Schema , Table functions",
		Signatures:  []string{"WAREHOUSE_METERING_HISTORY(\n      DATE_RANGE_START => <constant_expr>\n      [ , DATE_RANGE_END => <constant_expr> ]\n      [ , WAREHOUSE_NAME => '<string>' ] )"},
	},
	"width_bucket": {
		Description: "Constructs equi-width histograms, in which the histogram range is divided into intervals of identical size, and returns the bucket number into which the value of an expression falls, after it has b...",
		Signatures:  []string{"WIDTH_BUCKET( <expr> , <min_value> , <max_value> , <num_buckets> )"},
	},
	"xmlget": {
		Description: "Semi-structured and structured data functions (Extraction)",
		Signatures:  []string{"XMLGET( <expression> , <tag_name> [ , <instance_number> ] )"},
	},
	"zeroifnull": {
		Description: "Conditional expression functions",
		Signatures:  []string{"ZEROIFNULL( <expr> )"},
	},
	"zipf": {
		Description: "Data generation functions",
		Signatures:  []string{"ZIPF( <s> , <N> , <gen> )"},
	},
}
