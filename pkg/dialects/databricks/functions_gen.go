// Code generated by scripts/gendatabricks. DO NOT EDIT.
// Source: https://docs.databricks.com/aws/en/sql/language-manual/sql-ref-functions-builtin-alpha
// Generated: 2026-01-05

package dialect

import "github.com/leapstack-labs/leapsql/pkg/dialect"

// databricksScalars contains all scalar function names.
var databricksScalars = []string{
	"abs", "acos", "acosh", "add_months", "aes_decrypt",
	"aes_encrypt", "aggregate", "ai_analyze_sentiment", "ai_classify", "ai_extract",
	"ai_fix_grammar", "ai_forecast", "ai_gen", "ai_generate_text", "ai_mask",
	"ai_parse_document", "ai_query", "ai_similarity", "ai_summarize", "ai_translate",
	"array", "array_append", "array_compact", "array_contains", "array_distinct",
	"array_except", "array_insert", "array_intersect", "array_join", "array_max",
	"array_min", "array_position", "array_prepend", "array_remove", "array_repeat",
	"array_size", "array_sort", "array_union", "arrays_overlap", "arrays_zip",
	"ascii", "asin", "asinh", "assert_true", "atan",
	"atan2", "atanh", "base64", "bigint", "bin",
	"binary", "bit_count", "bit_get", "bit_length", "bit_reverse",
	"bitmap_bit_position", "bitmap_bucket_number", "bitmap_count", "boolean", "bround",
	"btrim", "cardinality", "cast", "cbrt", "ceil",
	"ceiling", "char", "char_length", "character_length", "charindex",
	"chr", "coalesce", "collation", "concat", "concat_ws",
	"contains", "conv", "convert_timezone", "cos", "cosh",
	"cot", "crc32", "csc", "cube", "curdate",
	"current_catalog", "current_database", "current_date", "current_metastore", "current_recipient",
	"current_schema", "current_timestamp", "current_timezone", "current_user", "current_version",
	"date", "date_add", "date_diff", "date_format", "date_from_unix_date",
	"date_part", "date_sub", "date_trunc", "dateadd", "datediff",
	"day", "dayname", "dayofmonth", "dayofweek", "dayofyear",
	"decimal", "decode", "degrees", "double", "e",
	"element_at", "elt", "encode", "endswith", "equal_null",
	"exists", "exp", "expm1", "extract", "factorial",
	"filter", "find_in_set", "flatten", "float", "floor",
	"forall", "format_number", "format_string", "from_avro", "from_csv",
	"from_json", "from_unixtime", "from_utc_timestamp", "from_xml", "get",
	"get_json_object", "getbit", "getdate", "greatest", "grouping",
	"grouping_id", "h3_boundaryasgeojson", "h3_boundaryaswkb", "h3_boundaryaswkt", "h3_centerasgeojson",
	"h3_centeraswkb", "h3_centeraswkt", "h3_compact", "h3_coverash3", "h3_coverash3string",
	"h3_distance", "h3_h3tostring", "h3_hexring", "h3_ischildof", "h3_ispentagon",
	"h3_isvalid", "h3_kring", "h3_kringdistances", "h3_longlatash3", "h3_longlatash3string",
	"h3_maxchild", "h3_minchild", "h3_pointash3", "h3_pointash3string", "h3_polyfillash3",
	"h3_polyfillash3string", "h3_resolution", "h3_stringtoh3", "h3_tessellateaswkb", "h3_tochildren",
	"h3_toparent", "h3_try_coverash3", "h3_try_coverash3string", "h3_try_distance", "h3_try_polyfillash3",
	"h3_try_polyfillash3string", "h3_try_tessellateaswkb", "h3_try_validate", "h3_uncompact", "h3_validate",
	"hash", "hex", "hll_sketch_estimate", "hll_union", "hll_union_agg",
	"hour", "http_request", "hypot", "if", "iff",
	"ifnull", "initcap", "input_file_block_length", "input_file_block_start", "input_file_name",
	"instr", "int", "is_account_group_member", "is_member", "is_valid_utf8",
	"is_variant_null", "isnan", "isnotnull", "isnull", "java_method",
	"json_array_length", "json_object_keys", "kll_sketch_get_n_bigint", "kll_sketch_get_n_double", "kll_sketch_get_n_float",
	"kll_sketch_get_quantile_bigint", "kll_sketch_get_quantile_double", "kll_sketch_get_quantile_float", "kll_sketch_get_rank_bigint", "kll_sketch_get_rank_double",
	"kll_sketch_get_rank_float", "kll_sketch_merge_bigint", "kll_sketch_merge_double", "kll_sketch_merge_float", "kll_sketch_to_string_bigint",
	"kll_sketch_to_string_double", "kll_sketch_to_string_float", "last_day", "lcase", "least",
	"left", "len", "length", "levenshtein", "ln",
	"locate", "log", "log10", "log1p", "log2",
	"lower", "lpad", "ltrim", "luhn_check", "make_date",
	"make_dt_interval", "make_interval", "make_timestamp", "make_valid_utf8", "make_ym_interval",
	"map", "map_concat", "map_contains_key", "map_entries", "map_filter",
	"map_from_arrays", "map_from_entries", "map_keys", "map_values", "map_zip_with",
	"mask", "md5", "minute", "mod", "monotonically_increasing_id",
	"month", "months_between", "named_struct", "nanvl", "negative",
	"next_day", "now", "nullif", "nullifzero", "nvl",
	"nvl2", "octet_length", "overlay", "parse_json", "parse_url",
	"pi", "pmod", "position", "positive", "pow",
	"power", "printf", "quarter", "radians", "raise_error",
	"rand", "randn", "random", "randstr", "reduce",
	"reflect", "regexp_count", "regexp_extract", "regexp_extract_all", "regexp_instr",
	"regexp_like", "regexp_replace", "regexp_substr", "repeat", "replace",
	"reverse", "right", "rint", "round", "rpad",
	"rtrim", "schema_of_csv", "schema_of_json", "schema_of_variant", "schema_of_xml",
	"sec", "second", "secret", "sentences", "sequence",
	"session_user", "sha", "sha1", "sha2", "shiftleft",
	"shiftright", "shiftrightunsigned", "shuffle", "sign", "signum",
	"sin", "sinh", "size", "slice", "smallint",
	"sort_array", "soundex", "space", "spark_partition_id", "split",
	"split_part", "sql_keywords", "sqrt", "st_addpoint", "st_area",
	"st_asbinary", "st_asewkb", "st_asewkt", "st_asgeojson", "st_astext",
	"st_aswkb", "st_aswkt", "st_buffer", "st_centroid", "st_concavehull",
	"st_contains", "st_convexhull", "st_covers", "st_difference", "st_dimension",
	"st_disjoint", "st_distance", "st_distancesphere", "st_distancespheroid", "st_dump",
	"st_dwithin", "st_endpoint", "st_envelope", "st_envelope_agg", "st_equals",
	"st_exteriorring", "st_flipcoordinates", "st_geogfromgeojson", "st_geogfromtext", "st_geogfromwkb",
	"st_geogfromwkt", "st_geohash", "st_geometryn", "st_geometrytype", "st_geomfromewkb",
	"st_geomfromgeohash", "st_geomfromgeojson", "st_geomfromtext", "st_geomfromwkb", "st_geomfromwkt",
	"st_interiorringn", "st_intersection", "st_intersects", "st_isempty", "st_isvalid",
	"st_length", "st_m", "st_makeline", "st_makepolygon", "st_multi",
	"st_ndims", "st_npoints", "st_numgeometries", "st_numinteriorrings", "st_perimeter",
	"st_point", "st_pointfromgeohash", "st_pointn", "st_removepoint", "st_reverse",
	"st_rotate", "st_scale", "st_setpoint", "st_setsrid", "st_simplify",
	"st_srid", "st_startpoint", "st_touches", "st_transform", "st_translate",
	"st_union", "st_union_agg", "st_within", "st_x", "st_xmax",
	"st_xmin", "st_y", "st_ymax", "st_ymin", "st_z",
	"st_zmax", "st_zmin", "startswith", "str_to_map", "string",
	"struct", "substr", "substring", "substring_index", "tan",
	"tanh", "timediff", "timestamp", "timestamp_micros", "timestamp_millis",
	"timestamp_seconds", "timestampadd", "timestampdiff", "tinyint", "to_avro",
	"to_binary", "to_char", "to_csv", "to_date", "to_geography",
	"to_geometry", "to_json", "to_number", "to_timestamp", "to_unix_timestamp",
	"to_utc_timestamp", "to_varchar", "to_variant_object", "to_xml", "transform",
	"transform_keys", "transform_values", "translate", "trim", "trunc",
	"try_add", "try_aes_decrypt", "try_cast", "try_divide", "try_element_at",
	"try_mod", "try_multiply", "try_parse_json", "try_reflect", "try_secret",
	"try_subtract", "try_to_binary", "try_to_geography", "try_to_geometry", "try_to_number",
	"try_to_timestamp", "try_url_decode", "try_validate_utf8", "try_variant_get", "try_zstd_decompress",
	"typeof", "ucase", "unbase64", "unhex", "uniform",
	"unix_date", "unix_micros", "unix_millis", "unix_seconds", "unix_timestamp",
	"upper", "url_decode", "url_encode", "user", "uuid",
	"validate_utf8", "variant_get", "vector_search", "version", "weekday",
	"weekofyear", "width_bucket", "window_time", "xpath", "xpath_boolean",
	"xpath_double", "xpath_float", "xpath_int", "xpath_long", "xpath_number",
	"xpath_short", "xpath_string", "xxhash64", "year", "zeroifnull",
	"zip_with", "zstd_compress", "zstd_decompress",
}

// databricksAggregates contains all aggregate function names.
var databricksAggregates = []string{
	"any", "any_value", "approx_count_distinct", "approx_percentile", "approx_top_k",
	"array_agg", "avg", "bit_and", "bit_or", "bit_xor",
	"bitmap_and_agg", "bitmap_construct_agg", "bitmap_or_agg", "bool_and", "bool_or",
	"collect_list", "collect_set", "corr", "count", "count_if",
	"count_min_sketch", "covar_pop", "covar_samp", "every", "first",
	"first_value", "histogram_numeric", "hll_sketch_agg", "kll_sketch_agg_bigint", "kll_sketch_agg_double",
	"kll_sketch_agg_float", "kurtosis", "last", "last_value", "listagg",
	"max", "max_by", "mean", "measure", "median",
	"min", "min_by", "mode", "percentile", "percentile_approx",
	"percentile_cont", "percentile_disc", "regr_avgx", "regr_avgy", "regr_count",
	"regr_intercept", "regr_r2", "regr_slope", "regr_sxx", "regr_sxy",
	"regr_syy", "schema_of_json_agg", "schema_of_variant_agg", "skewness", "some",
	"std", "stddev", "stddev_pop", "stddev_samp", "string_agg",
	"sum", "try_avg", "try_sum", "var_pop", "var_samp",
	"variance",
}

// databricksWindows contains all window function names.
var databricksWindows = []string{
	"cume_dist", "dense_rank", "lag", "lead", "nth_value",
	"ntile", "percent_rank", "rank", "row_number",
}

// databricksTableFunctions contains all table-valued function names.
var databricksTableFunctions = []string{
	"cloud_files_state", "collations", "event_log", "explode", "explode_outer",
	"inline", "inline_outer", "json_tuple", "list_secrets", "posexplode",
	"posexplode_outer", "range", "read_files", "read_kafka", "read_kinesis",
	"read_pubsub", "read_pulsar", "read_state_metadata", "read_statestore", "remote_query",
	"stack", "table_changes", "variant_explode", "variant_explode_outer",
}

// databricksFunctionDocs contains documentation for Databricks functions.
var databricksFunctionDocs = map[string]dialect.FunctionDoc{
	"abs": {
		Description: "Returns the absolute value of the numeric value in expr.",
		Signatures:  []string{"abs(expr)"},
	},
	"acos": {
		Description: "Returns the inverse cosine (arccosine) of expr.",
		Signatures:  []string{"acos(expr)"},
	},
	"acosh": {
		Description: "Returns the inverse hyperbolic cosine of expr.",
		Signatures:  []string{"acosh(expr)"},
	},
	"add_months": {
		Description: "Returns the date that is numMonths after startDate.",
		Signatures:  []string{"add_months(startDate, numMonths)"},
	},
	"aes_decrypt": {
		Description: "Decrypts a binary produced using AES encryption.",
		Signatures:  []string{"aes_decrypt(expr, key [, mode [, padding [, aad]]])"},
	},
	"aes_encrypt": {
		Description: "Encrypts a binary using AES encryption.",
		Signatures:  []string{"aes_encrypt(expr, key [, mode [, padding[, iv[, aad]]]])"},
	},
	"aggregate": {
		Description: "Aggregates elements in an array using a custom aggregator. This function is a synonym for reduce function.",
		Signatures:  []string{"aggregate(expr, start, merge [, finish])"},
	},
	"ai_analyze_sentiment": {
		Description: "This functionality is in Public Preview and HIPAA compliant.",
		Signatures:  []string{"ai_analyze_sentiment(content)"},
	},
	"ai_classify": {
		Description: "This functionality is in Public Preview and HIPAA compliant.",
		Signatures:  []string{"ai_classify(content, labels)"},
	},
	"ai_extract": {
		Description: "This functionality is in Public Preview and HIPAA compliant.",
		Signatures:  []string{"ai_extract(content, labels)"},
	},
	"ai_fix_grammar": {
		Description: "This functionality is in Public Preview and HIPAA compliant.",
		Signatures:  []string{"ai_fix_grammar(content)"},
	},
	"ai_forecast": {
		Description: "This functionality is in Public Preview and HIPAA compliant.",
		Signatures:  []string{"ai_forecast(  observed TABLE,  horizon DATE | TIMESTAMP | STRING,  time_col STRING,  value_col STRING | ARRAY<STRING>,  group_col STRING | ARRAY<STRING> | NULL DEFAULT NULL,  prediction_interval_width DOUBLE DEFAULT 0.95,  frequency STRING DEFAULT 'auto',  seed INTEGER | NULL DEFAULT NULL,  parameters STRING DEFAULT '{}')"},
	},
	"ai_gen": {
		Description: "This functionality is in Public Preview and HIPAA compliant.",
		Signatures:  []string{"ai_gen(prompt)"},
	},
	"ai_generate_text": {
		Description: "This feature is in Public Preview.",
		Signatures:  []string{"ai_generate_text(prompt, modelName[, param1, value1] [...])"},
	},
	"ai_mask": {
		Description: "This functionality is in Public Preview and HIPAA compliant.",
		Signatures:  []string{"ai_mask(content, labels)"},
	},
	"ai_parse_document": {
		Description: "This functionality is in Public Preview and HIPAA compliant.",
		Signatures:  []string{"ai_parse_document(content)"},
	},
	"ai_query": {
		Description: "This functionality is in Public Preview and HIPAA compliant.",
		Signatures:  []string{"ai_query(endpoint, request)"},
	},
	"ai_similarity": {
		Description: "This functionality is in Public Preview and HIPAA compliant.",
		Signatures:  []string{"ai_similarity(expr1, expr2)"},
	},
	"ai_summarize": {
		Description: "This functionality is in Public Preview and HIPAA compliant.",
		Signatures:  []string{"ai_summarize(content[, max_words])"},
	},
	"ai_translate": {
		Description: "This functionality is in Public Preview and HIPAA compliant.",
		Signatures:  []string{"ai_translate(content, to_lang)"},
	},
	"any": {
		Description: "Returns true if at least one value of expr in the group is true. The any aggregate function is synonymous with max aggregate function, but limited to a boolean argument. The function is also a syno...",
		Signatures:  []string{"any(expr) [FILTER ( WHERE cond ) ]"},
	},
	"any_value": {
		Description: "Returns some value of expr for a group of rows. This function is non-deterministic.",
		Signatures:  []string{"any_value(expr[, ignoreNull]) [FILTER ( WHERE cond ) ] [ IGNORE NULLS | RESPECT NULLS ]"},
	},
	"approx_count_distinct": {
		Description: "Returns the estimated number of distinct values in expr within the group.",
		Signatures:  []string{"approx_count_distinct(expr[, relativeSD]) [FILTER ( WHERE cond ) ]"},
	},
	"approx_percentile": {
		Description: "Returns the approximate percentile of the expr within the group.",
		Signatures:  []string{"approx_percentile ( [ALL | DISTINCT] expr, percentile [, accuracy] ) [ FILTER ( WHERE cond ) ]"},
	},
	"approx_top_k": {
		Description: "Returns the top k most frequently occurring item values in an expr along with their approximate counts.",
		Signatures:  []string{"approx_top_k(expr[, k[, maxItemsTracked]]) [FILTER ( WHERE cond ) ]"},
	},
	"array": {
		Description: "Returns an array with the elements in expr.",
		Signatures:  []string{"array(expr [, ...])"},
	},
	"array_agg": {
		Description: "Returns an array consisting of all values in expr within the group. This function is a synonym for collect_list aggregate function.",
		Signatures:  []string{"array_agg ( [ALL | DISTINCT] expr ) [FILTER ( WHERE cond ) ]"},
	},
	"array_append": {
		Description: "Returns array appended by elem.",
		Signatures:  []string{"array_append(array, elem)"},
	},
	"array_compact": {
		Description: "Removes NULL elements from array.",
		Signatures:  []string{"array_compact(array)"},
	},
	"array_contains": {
		Description: "Returns true if array contains value.",
		Signatures:  []string{"array_contains(array, value)"},
	},
	"array_distinct": {
		Description: "Removes duplicate values from array.",
		Signatures:  []string{"array_distinct(array)"},
	},
	"array_except": {
		Description: "Returns an array of the elements in array1 but not in array2.",
		Signatures:  []string{"array_except(array1, array2)"},
	},
	"array_insert": {
		Description: "Returns an expanded array where elem is inserted at the index position.",
		Signatures:  []string{"array_insert(array, index, elem)"},
	},
	"array_intersect": {
		Description: "Returns an array of the elements in the intersection of array1 and array2.",
		Signatures:  []string{"array_intersect(array1, array2)"},
	},
	"array_join": {
		Description: "Concatenates the elements of array.",
		Signatures:  []string{"array_join(array, delimiter [, nullReplacement])"},
	},
	"array_max": {
		Description: "Returns the maximum value in array.",
		Signatures:  []string{"array_max(array)"},
	},
	"array_min": {
		Description: "Returns the minimum value in array.",
		Signatures:  []string{"array_min(array)"},
	},
	"array_position": {
		Description: "Returns the position of the first occurrence of element in array.",
		Signatures:  []string{"array_position(array, element)"},
	},
	"array_prepend": {
		Description: "Returns array prepended by elem.",
		Signatures:  []string{"array_prepend(array, elem)"},
	},
	"array_remove": {
		Description: "Removes all occurrences of element from array.",
		Signatures:  []string{"array_remove(array, element)"},
	},
	"array_repeat": {
		Description: "Returns an array containing element count times.",
		Signatures:  []string{"array_repeat(element, count)"},
	},
	"array_size": {
		Description: "Returns the number of elements in array.",
		Signatures:  []string{"array_size(array)"},
	},
	"array_sort": {
		Description: "Returns array sorted according to func.",
		Signatures:  []string{"array_sort(array, func)"},
	},
	"array_union": {
		Description: "Returns an array of the elements in the union of array1 and array2 without duplicates.",
		Signatures:  []string{"array_union(array1, array2)"},
	},
	"arrays_overlap": {
		Description: "Returns true if the intersection of array1 and array2 is not empty.",
		Signatures:  []string{"arrays_overlap (array1, array2)"},
	},
	"arrays_zip": {
		Description: "Returns a merged array of structs in which the nth struct contains all nth values of input arrays.",
		Signatures:  []string{"arrays_zip (array1 [, ...])"},
	},
	"ascii": {
		Description: "Returns the ASCII code point of the first character of str.",
		Signatures:  []string{"ascii(str)"},
	},
	"asin": {
		Description: "Returns the inverse sine (arcsine) of expr.",
		Signatures:  []string{"asin(expr)"},
	},
	"asinh": {
		Description: "Returns the inverse hyperbolic sine of expr.",
		Signatures:  []string{"asinh(expr)"},
	},
	"assert_true": {
		Description: "Returns an error if expr is not true.",
		Signatures:  []string{"assert_true(condition [, message])"},
	},
	"atan": {
		Description: "Returns the inverse tangent (arctangent) of expr.",
		Signatures:  []string{"atan(expr)"},
	},
	"atan2": {
		Description: "Returns the angle in radians between the positive x-axis of a plane and the point specified by the coordinates (exprX, exprY).",
		Signatures:  []string{"atan2(exprY, exprX)"},
	},
	"atanh": {
		Description: "Returns inverse hyperbolic tangent of expr.",
		Signatures:  []string{"atanh(expr)"},
	},
	"avg": {
		Description: "Returns the mean calculated from values of a group. This function is a synonym for mean aggregate function.",
		Signatures:  []string{"avg( [ALL | DISTINCT] expr) [FILTER ( WHERE cond ) ]"},
	},
	"base64": {
		Description: "Converts expr to a base 64 string using RFC2045 Base64 transfer encoding for MIME.",
		Signatures:  []string{"base64(expr)"},
	},
	"bigint": {
		Description: "Casts the value expr to BIGINT. This function is a synonym for CAST(expr AS BIGINT). See cast function for details.",
		Signatures:  []string{"bigint(expr)"},
	},
	"bin": {
		Description: "Returns the binary representation of expr.",
		Signatures:  []string{"bin(expr)"},
	},
	"binary": {
		Description: "Casts the value of expr to BINARY. This function is a synonym for CAST(expr AS BINARY). See cast function for details.",
		Signatures:  []string{"binary(expr)"},
	},
	"bit_and": {
		Description: "Returns the bitwise AND of all input values in the group.",
		Signatures:  []string{"bit_and(expr) [FILTER ( WHERE cond ) ]"},
	},
	"bit_count": {
		Description: "Returns the number of bits set in the argument.",
		Signatures:  []string{"bit_count(expr)"},
	},
	"bit_get": {
		Description: "Returns the value of a bit in a binary representation of an integral numeric. This function is a synonym for getbit function.",
		Signatures:  []string{"bit_get(expr, pos))"},
	},
	"bit_length": {
		Description: "Returns the bit length of string data or number of bits of binary data.",
		Signatures:  []string{"bit_length(expr)"},
	},
	"bit_or": {
		Description: "Returns the bitwise OR of all input values in the group.",
		Signatures:  []string{"bit_or(expr) [FILTER ( WHERE cond ) ]"},
	},
	"bit_reverse": {
		Description: "Returns the value obtained by reversing the order of the bits in the two's complement binary representation of the specified integral value.",
		Signatures:  []string{"bit_reverse(expr)"},
	},
	"bit_xor": {
		Description: "Returns the bitwise XOR of all input values in the group.",
		Signatures:  []string{"bit_xor ( [ALL | DISTINCT] expr ) [FILTER ( WHERE cond ) ]"},
	},
	"bitmap_and_agg": {
		Description: "Returns the bitwise AND of all BINARY input values in the group.",
		Signatures:  []string{"bitmap_and_agg(expr) [FILTER ( WHERE cond ) ]"},
	},
	"bitmap_bit_position": {
		Description: "Returns the 0-based bit position of a given BIGINT number within a bucket.",
		Signatures:  []string{"bitmap_bit_position(expr)"},
	},
	"bitmap_bucket_number": {
		Description: "Returns the bitmap bucket number for a given BIGINT number.",
		Signatures:  []string{"bitmap_bucket_number(expr)"},
	},
	"bitmap_construct_agg": {
		Description: "Returns the bitwise OR of all bit positions values between 0 and 32767 in a group as a BINARY.",
		Signatures:  []string{"bitmap_construct_agg(expr) [FILTER ( WHERE cond ) ]"},
	},
	"bitmap_count": {
		Description: "Returns the number of bits set in a BINARY string representing a bitmap. This function is typically used to count distinct value in combination with the bitmap_bucket_number() and the bitmap_constr...",
		Signatures:  []string{"bitmap_count(expr)"},
	},
	"bitmap_or_agg": {
		Description: "Returns the bitwise OR of all BINARY input values in the group.",
		Signatures:  []string{"bitmap_or_agg(expr) [FILTER ( WHERE cond ) ]"},
	},
	"bool_and": {
		Description: "Returns true if all values in expr are true within the group. This function is a synonym for every aggregate function.",
		Signatures:  []string{"bool_and(expr) [FILTER ( WHERE cond ) ]"},
	},
	"bool_or": {
		Description: "Returns true if at least one value in expr is true within the group.",
		Signatures:  []string{"bool_or(expr) [FILTER ( WHERE cond ) ]"},
	},
	"boolean": {
		Description: "Casts expr to boolean. This function is a synonym for CAST(expr AS binary). See cast function for details.",
		Signatures:  []string{"boolean(expr)"},
	},
	"bround": {
		Description: "Returns the rounded expr using HALF_EVEN rounding mode.",
		Signatures:  []string{"bround(expr [,targetScale] )"},
	},
	"btrim": {
		Description: "Returns str with leading and trailing characters removed.",
		Signatures:  []string{"btrim( str [, trimStr ] )"},
	},
	"cardinality": {
		Description: "Returns the size of expr.",
		Signatures:  []string{"cardinality(expr)"},
	},
	"cast": {
		Description: "Casts the value expr to the target data type type. This operator is a synonym for :: (colon colon sign) operator",
		Signatures:  []string{"cast(sourceExpr AS targetType)"},
	},
	"cbrt": {
		Description: "Returns the cube root of expr.",
		Signatures:  []string{"cbrt(expr)"},
	},
	"ceil": {
		Description: "Returns the smallest number not smaller than expr rounded up to targetScale digits relative to the decimal point. This function is a synonym of ceiling function.",
		Signatures:  []string{"ceil(expr [, targetScale])"},
	},
	"ceiling": {
		Description: "Returns the smallest number not smaller than expr rounded up to targetScale digits relative to the decimal point. This function is a synonym of ceil function.",
		Signatures:  []string{"ceiling(expr [, targetScale])"},
	},
	"char": {
		Description: "Returns the character at the supplied UTF-16 code point. This function is a synonym for chr function.",
		Signatures:  []string{"char(expr)"},
	},
	"char_length": {
		Description: "Returns the character length of string data or number of bytes of binary data. This function is a synonym for character_length function and length function.",
		Signatures:  []string{"char_length(expr)"},
	},
	"character_length": {
		Description: "Returns the character length of string data or number of bytes of binary data. This function is a synonym for char_length function and length function.",
		Signatures:  []string{"character_length(expr)"},
	},
	"charindex": {
		Description: "Returns the position of the first occurrence of substr in str after position pos. This function is a synonym for locate function.",
		Signatures:  []string{"charindex(substr, str [, pos])"},
	},
	"chr": {
		Description: "Returns the character at the supplied UTF-16 code point. This function is a synonym for char function.",
		Signatures:  []string{"chr(expr)"},
	},
	"cloud_files_state": {
		Description: "Returns the file-level state of an Auto Loader or read_files stream.",
		Signatures:  []string{"cloud_files_state( { TABLE ( table_name ) | checkpoint } )"},
	},
	"coalesce": {
		Description: "Returns the first non-null argument.",
		Signatures:  []string{"coalesce(expr1 [, ...] )"},
	},
	"collation": {
		Description: "This feature is in Public Preview.",
		Signatures:  []string{"collation (strExpr)"},
	},
	"collations": {
		Description: "This feature is in Public Preview.",
		Signatures:  []string{"collations()"},
	},
	"collect_list": {
		Description: "Returns an array consisting of all values in expr within the group. This function is a synonym for array_agg aggregate function.",
		Signatures:  []string{"collect_list ( [ALL | DISTINCT] expr ) [FILTER ( WHERE cond ) ]"},
	},
	"collect_set": {
		Description: "Returns an array consisting of all unique values in expr within the group.",
		Signatures:  []string{"collect_set(expr) [FILTER ( WHERE cond ) ]"},
	},
	"concat": {
		Description: "Returns the concatenation of the arguments. This function is a synonym for || (pipe pipe sign) operator.",
		Signatures:  []string{"concat(expr1, expr2 [, ...] )"},
	},
	"concat_ws": {
		Description: "Returns the concatenation strings separated by sep.",
		Signatures:  []string{"concat_ws(sep [, expr1 [, ...] ])"},
	},
	"contains": {
		Description: "Returns true if expr contains subExpr.",
		Signatures:  []string{"contains(expr, subExpr)"},
	},
	"conv": {
		Description: "Converts num from fromBase to toBase.",
		Signatures:  []string{"conv(num, fromBase, toBase)"},
	},
	"convert_timezone": {
		Description: "Converts TIMESTAMP_NTZ to another time zone. The input column is converted to TIMESTAMP_NTZ type before the time zone conversion, if the input column is of TIMESTAMP or DATE or STRING type.",
		Signatures:  []string{"convert_timezone([sourceTz, ]targetTz, sourceTs)"},
	},
	"corr": {
		Description: "Returns Pearson coefficient of correlation between a group of number pairs.",
		Signatures:  []string{"corr ( [ALL | DISTINCT] expr1, expr2 ) [FILTER ( WHERE cond ) ]"},
	},
	"cos": {
		Description: "Returns the cosine of expr.",
		Signatures:  []string{"cos(expr)"},
	},
	"cosh": {
		Description: "Returns the hyperbolic cosine of expr.",
		Signatures:  []string{"cosh(expr)"},
	},
	"cot": {
		Description: "Returns the cotangent of expr.",
		Signatures:  []string{"cot(expr)"},
	},
	"count": {
		Description: "Returns the number of retrieved rows in a group.",
		Signatures:  []string{"count ( [DISTINCT | ALL] * ) [FILTER ( WHERE cond ) ]"},
	},
	"count_if": {
		Description: "Returns the number of true values for the group in expr.",
		Signatures:  []string{"count_if ( [ALL | DISTINCT] expr ) [ FILTER ( WHERE cond ) ]"},
	},
	"count_min_sketch": {
		Description: "Returns a count-min sketch of all values in the group in column with the epsilon, confidence and seed.",
		Signatures:  []string{"count_min_sketch ( [ALL | DISTINCT] column, epsilon, confidence, seed ) [FILTER ( WHERE cond ) ]"},
	},
	"covar_pop": {
		Description: "Returns the population covariance of number pairs in a group.",
		Signatures:  []string{"covar_pop ( [ALL | DISTINCT] expr1, expr2 ) [FILTER ( WHERE cond ) ]"},
	},
	"covar_samp": {
		Description: "Returns the sample covariance of number pairs in a group.",
		Signatures:  []string{"covar_samp ( [ALL | DISTINCT] expr1, expr2 ) [FILTER ( WHERE cond ) ]"},
	},
	"crc32": {
		Description: "Returns a cyclic redundancy check value of expr.",
		Signatures:  []string{"crc32(expr)"},
	},
	"csc": {
		Description: "Returns the cosecant of expr.",
		Signatures:  []string{"csc(expr)"},
	},
	"cube": {
		Description: "Creates a multi-dimensional cube using the specified expression columns.",
		Signatures:  []string{"cube (expr1 [, ...] )"},
	},
	"cume_dist": {
		Description: "Returns the position of a value relative to all values in the partition.",
		Signatures:  []string{"cume_dist() over_clause"},
	},
	"curdate": {
		Description: "Returns the current date at the start of query evaluation. This function is a synonym for current_date.",
		Signatures:  []string{"curdate()"},
	},
	"current_catalog": {
		Description: "Returns the current catalog.",
		Signatures:  []string{"current_catalog()"},
	},
	"current_database": {
		Description: "Returns the current schema. This function is an alias for current_schema function.",
		Signatures:  []string{"current_database()"},
	},
	"current_date": {
		Description: "Returns the current date at the start of query evaluation.",
		Signatures:  []string{"current_date()"},
	},
	"current_metastore": {
		Description: "Returns the current metastore id.",
		Signatures:  []string{"current_metastore()"},
	},
	"current_recipient": {
		Description: "Returns the property value associated with the specified property key for the current data recipient in a Delta Sharing context. This function allows data providers to dynamically control data acce...",
		Signatures:  []string{"current_recipient(key)"},
	},
	"current_schema": {
		Description: "Returns the current schema.",
		Signatures:  []string{"current_schema()"},
	},
	"current_timestamp": {
		Description: "Returns the current timestamp at the start of query evaluation.",
		Signatures:  []string{"current_timestamp()"},
	},
	"current_timezone": {
		Description: "Returns the current session local timezone.",
		Signatures:  []string{"current_timezone()"},
	},
	"current_user": {
		Description: "Returns the user executing the statement. current_user is an alias for user.",
		Signatures:  []string{"current_user()"},
	},
	"current_version": {
		Description: "Returns the current version of Databricks SQL or Databricks Runtime.",
		Signatures:  []string{"current_version()"},
	},
	"date": {
		Description: "This function is a synonym for CAST(expr AS expr). See cast function for details.",
		Signatures:  []string{"date(expr)"},
	},
	"date_add": {
		Description: "Adds value and unit to a timestamp expr. This function is a synonym for timestampadd function.",
		Signatures:  []string{"date_add(unit, value, expr)unit { MICROSECOND |   MILLISECOND |   SECOND |   MINUTE |   HOUR |   DAY | DAYOFYEAR |   WEEK |   MONTH |   QUARTER |   YEAR }"},
	},
	"date_diff": {
		Description: "Returns the difference between two timestamps measured in units. date_diff (timestamp) is a synonym for timestampdiff function.",
		Signatures:  []string{"date_diff(unit, start, end)unit { MICROSECOND |   MILLISECOND |   SECOND |   MINUTE |   HOUR |   DAY |   WEEK |   MONTH |   QUARTER |   YEAR }"},
	},
	"date_format": {
		Description: "Converts a timestamp to a string in the format fmt.",
		Signatures:  []string{"date_format(expr, fmt)"},
	},
	"date_from_unix_date": {
		Description: "Creates a date from the number of days since 1970-01-01. This function is a synonym for date_add(DATE'1970-01-01', days).",
		Signatures:  []string{"date_from_unix_date(days)"},
	},
	"date_part": {
		Description: "Extracts a part of the date, timestamp, or interval.",
		Signatures:  []string{"date_part(fieldStr, expr)"},
	},
	"date_sub": {
		Description: "Returns the date numDays before startDate.",
		Signatures:  []string{"date_sub(startDate, numDays)"},
	},
	"date_trunc": {
		Description: "Returns timestamp truncated to the unit specified in unit.",
		Signatures:  []string{"date_trunc(unit, expr)"},
	},
	"dateadd": {
		Description: "Returns the date numDays after startDate. This function is a synonym for date_add (days) function.",
		Signatures:  []string{"dateadd(startDate, numDays)"},
	},
	"datediff": {
		Description: "Returns the number of days from startDate to endDate.",
		Signatures:  []string{"datediff(endDate, startDate)"},
	},
	"day": {
		Description: "Returns the day of month of the date or timestamp. This function is a synonym for extract(DAY FROM expr).",
		Signatures:  []string{"day(expr)"},
	},
	"dayname": {
		Description: "Returns the three-letter English acronym for the day of the week for the given date.",
		Signatures:  []string{"dayname(expr)"},
	},
	"dayofmonth": {
		Description: "Returns the day of month of the date or timestamp. This function is a synonym for extract(DAY FROM expr).",
		Signatures:  []string{"dayofmonth(expr)"},
	},
	"dayofweek": {
		Description: "Returns the day of week of the date or timestamp. This function is a synonym for extract(DAYOFWEEK FROM expr).",
		Signatures:  []string{"dayofweek(expr)"},
	},
	"dayofyear": {
		Description: "Returns the day of year of the date or timestamp. This function is a synonym for extract(DAY FORM expr).",
		Signatures:  []string{"dayofyear(expr)"},
	},
	"decimal": {
		Description: "Casts the value expr to DECIMAL. This function is a synonym for CAST(expr AS decimal(10, 0)). See cast function for details.",
		Signatures:  []string{"decimal(expr)"},
	},
	"decode": {
		Description: "Returns the value matching the key.",
		Signatures:  []string{"decode(expr, { key1, value1 } [, ...] [, defValue])"},
	},
	"degrees": {
		Description: "Converts radians to degrees.",
		Signatures:  []string{"degrees(expr)"},
	},
	"dense_rank": {
		Description: "Returns the rank of a value compared to all values in the partition.",
		Signatures:  []string{"dense_rank()"},
	},
	"double": {
		Description: "Casts the value expr to DOUBLE. This function is a synonym for CAST(expr AS DOUBLE). See cast function for details.",
		Signatures:  []string{"double(expr)"},
	},
	"e": {
		Description: "Returns the constant e.",
		Signatures:  []string{"e()"},
	},
	"element_at": {
		Description: "Returns the element of an arrayExpr at index.",
		Signatures:  []string{"element_at(arrayExpr, index)"},
	},
	"elt": {
		Description: "Returns the nth expression.",
		Signatures:  []string{"elt(index, expr1 [, ...])"},
	},
	"encode": {
		Description: "Returns the binary representation of a string using the charSet character encoding.",
		Signatures:  []string{"encode(expr, charSet)"},
	},
	"endswith": {
		Description: "The function operates in BINARY mode if both arguments are BINARY. Returns true if expr ends with endExpr.",
		Signatures:  []string{"endswith(expr, endExpr)"},
	},
	"equal_null": {
		Description: "Returns true if expr1 equals expr2 or both expressions are NULL, or false otherwise. This function differs from = (eq sign) operator, by treating NULL as a comparable value.",
		Signatures:  []string{"equal_null ( expr1, expr2 )"},
	},
	"event_log": {
		Description: "Returns the event log for materialized views, streaming tables, and Lakeflow Spark Declarative Pipelines.",
		Signatures:  []string{"event_log( { TABLE ( table_name ) | pipeline_id } )"},
	},
	"every": {
		Description: "Returns true if all values in expr are true within the group. This function is a synonym for bool_and aggregate function.",
		Signatures:  []string{"every(expr) [FILTER ( WHERE cond ) ]"},
	},
	"exists": {
		Description: "Returns true if func is true for any element in expr or query returns at least one row.",
		Signatures:  []string{"exists(expr, func)"},
	},
	"exp": {
		Description: "Returns e to the power of expr.",
		Signatures:  []string{"exp(expr)"},
	},
	"explode": {
		Description: "Returns a set of rows by un-nesting collection.",
		Signatures:  []string{"explode(collection)"},
	},
	"explode_outer": {
		Description: "Returns a set of rows by un-nesting collection using outer semantics.",
		Signatures:  []string{"explode_outer(collection)"},
	},
	"expm1": {
		Description: "Returns exp(expr) - 1.",
		Signatures:  []string{"expm1(expr)"},
	},
	"extract": {
		Description: "Returns field of source.",
		Signatures:  []string{"extract(field FROM source)"},
	},
	"factorial": {
		Description: "Returns the factorial of expr.",
		Signatures:  []string{"factorial(expr)"},
	},
	"filter": {
		Description: "Filters the array in expr using the function func.",
		Signatures:  []string{"filter(expr, func)"},
	},
	"find_in_set": {
		Description: "Returns the position of a string within a comma-separated list of strings.",
		Signatures:  []string{"find_in_set(searchExpr, sourceExpr)"},
	},
	"first": {
		Description: "Returns the first value of expr for a group of rows. This function is a synonym for first_value aggregate function.",
		Signatures:  []string{"first(expr[, ignoreNull]) [FILTER ( WHERE cond ) ]"},
	},
	"first_value": {
		Description: "Returns the first value of expr for a group of rows. This function is a synonym for first aggregate function.",
		Signatures:  []string{"first_value(expr[, ignoreNull]) [FILTER ( WHERE cond ) ]"},
	},
	"flatten": {
		Description: "Transforms an array of arrays into a single array.",
		Signatures:  []string{"flatten(expr)"},
	},
	"float": {
		Description: "Casts the value expr to FLOAT. This function is a synonym for CAST(expr AS FLOAT). See cast function for details.",
		Signatures:  []string{"float(expr)"},
	},
	"floor": {
		Description: "Returns the largest number not bigger than expr rounded down to targetScale digits relative to the decimal point.",
		Signatures:  []string{"floor(expr [, targetScale])"},
	},
	"forall": {
		Description: "Tests whether func holds for all elements in the array.",
		Signatures:  []string{"forall(expr, func)"},
	},
	"format_number": {
		Description: "Formats expr like #,###,###.##, rounded to scale decimal places.",
		Signatures:  []string{"format_number(expr, scale)"},
	},
	"format_string": {
		Description: "Returns a formatted string from printf-style format strings.",
		Signatures:  []string{"format_string(strfmt [, obj1 [, ...] ])"},
	},
	"from_avro": {
		Description: "Returns a struct value with the avroBin and jsonSchemaStr.",
		Signatures:  []string{"from_avro(avroBin, jsonSchemaStr, options )"},
	},
	"from_csv": {
		Description: "Returns a struct value with the csvStr and schema.",
		Signatures:  []string{"from_csv(csvStr, schema [, options])"},
	},
	"from_json": {
		Description: "Returns a struct value with the jsonStr and schema.",
		Signatures:  []string{"from_json(jsonStr, schema [, options])"},
	},
	"from_unixtime": {
		Description: "Returns unixTime in fmt.",
		Signatures:  []string{"from_unixtime(unixTime [, fmt])"},
	},
	"from_utc_timestamp": {
		Description: "Returns the timestamp at timeZone for a timestamp expr at UTC.",
		Signatures:  []string{"from_utc_timestamp(expr, timeZone)"},
	},
	"from_xml": {
		Description: "This feature is in Public Preview.",
		Signatures:  []string{"from_xml(xmlStr, schema [, options])"},
	},
	"get": {
		Description: "Returns the element of an arrayExpr at index, starting with 0.",
		Signatures:  []string{"get(arrayExpr, index)"},
	},
	"get_json_object": {
		Description: "Extracts a JSON object from path.",
		Signatures:  []string{"get_json_object(expr, path)"},
	},
	"getbit": {
		Description: "Returns the value of a bit in a binary representation of an integral numeric. This function is a synonym of bit_get function.",
		Signatures:  []string{"getbit(expr, pos))"},
	},
	"getdate": {
		Description: "Returns the current timestamp at the start of query evaluation.",
		Signatures:  []string{"getdate()"},
	},
	"greatest": {
		Description: "Returns the greatest value of all arguments, skipping null values.",
		Signatures:  []string{"greatest(expr1, expr2 [, ...])"},
	},
	"grouping": {
		Description: "Indicates whether a specified column in a GROUPING SET, ROLLUP, or CUBE represents a subtotal.",
		Signatures:  []string{"grouping(col)"},
	},
	"grouping_id": {
		Description: "Returns the level of grouping for a set of columns.",
		Signatures:  []string{"grouping_id( [col1 [, ...] ] )"},
	},
	"h3_boundaryasgeojson": {
		Description: "Returns the polygonal boundary of the input H3 cell in GeoJSON format.",
		Signatures:  []string{"h3_boundaryasgeojson ( h3CellIdExpr )"},
	},
	"h3_boundaryaswkb": {
		Description: "Returns the polygonal boundary of the input H3 cell in WKB format.",
		Signatures:  []string{"h3_boundaryaswkb ( h3CellIdExpr )"},
	},
	"h3_boundaryaswkt": {
		Description: "Returns the polygonal boundary of the input H3 cell in WKT format.",
		Signatures:  []string{"h3_boundaryaswkt ( h3CellIdExpr )"},
	},
	"h3_centerasgeojson": {
		Description: "Returns the center of the input H3 cell as a point in GeoJSON format.",
		Signatures:  []string{"h3_centerasgeojson ( h3CellIdExpr )"},
	},
	"h3_centeraswkb": {
		Description: "Returns the center of the input H3 cell as a point in WKB format.",
		Signatures:  []string{"h3_centeraswkb ( h3CellIdExpr )"},
	},
	"h3_centeraswkt": {
		Description: "Returns the center of the input H3 cell as a point in WKT format.",
		Signatures:  []string{"h3_centeraswkt ( h3CellIdExpr )"},
	},
	"h3_compact": {
		Description: "Compacts the input set of H3 cells. The compacted set covers the same set of H3 cells as the original one.",
		Signatures:  []string{"h3_compact ( h3CellIdsExpr )"},
	},
	"h3_coverash3": {
		Description: "Returns an ARRAY of BIGINT values representing H3 cell IDs. These values correspond to the minimal set of hexagons or pentagons, of the specified resolution that fully cover the input linear or are...",
		Signatures:  []string{"h3_coverash3 ( geographyExpr, resolutionExpr )"},
	},
	"h3_coverash3string": {
		Description: "Returns an ARRAY of STRING values representing H3 cell IDs. These values correspond to the minimal set of hexagons or pentagons, of the specified resolution that fully cover the input linear or are...",
		Signatures:  []string{"h3_coverash3 ( geographyExpr, resolutionExpr )"},
	},
	"h3_distance": {
		Description: "Returns the grid distance of the two input H3 cell IDs.",
		Signatures:  []string{"h3_distance ( h3CellId1Expr, h3CellId2Expr )"},
	},
	"h3_h3tostring": {
		Description: "Converts the input H3 cell ID to its equivalent hexadecimal string representation.",
		Signatures:  []string{"h3_h3tostring ( h3CellIdExpr )"},
	},
	"h3_hexring": {
		Description: "Returns an array of H3 cells that form a hollow hexagonal ring centered at the origin H3 cell and that are at grid distance k from the origin H3 cell.",
		Signatures:  []string{"h3_hexring ( h3CellIdExpr, kExpr )"},
	},
	"h3_ischildof": {
		Description: "Returns true if the first H3 cell is the same as or a child of the second H3 cell.",
		Signatures:  []string{"h3_ischildof ( h3CellId1Expr, h3cellId2Expr )"},
	},
	"h3_ispentagon": {
		Description: "Returns true if the input BIGINT or hexadecimal STRING corresponds to a pentagonal H3 cell or not.",
		Signatures:  []string{"h3_ispentagon ( h3CellIdExpr )"},
	},
	"h3_isvalid": {
		Description: "Returns true if the input BIGINT or STRING is a valid H3 cell ID.",
		Signatures:  []string{"h3_isvalid ( expr )"},
	},
	"h3_kring": {
		Description: "Returns the H3 cells that are within (grid) distance k of the origin cell. The set of these H3 cells is called the k-ring of the origin cell.",
		Signatures:  []string{"h3_kring ( h3CellIdExpr, kExpr )"},
	},
	"h3_kringdistances": {
		Description: "Returns all H3 cells (represented as long integers or strings) within grid distance k from the origin H3 cell, along with their distance from the origin H3 cell.",
		Signatures:  []string{"h3_kringdistances ( h3CellIdExpr, kExpr )"},
	},
	"h3_longlatash3": {
		Description: "Returns the H3 cell ID (as a BIGINT) corresponding to the provided longitude and latitude at the specified resolution.",
		Signatures:  []string{"h3_longlatash3 ( longitudeExpr, latitudeExpr, resolutionExpr )"},
	},
	"h3_longlatash3string": {
		Description: "Returns the H3 cell ID (as a hexadecimal STRING) corresponding to the provided longitude and latitude at the specified resolution.",
		Signatures:  []string{"h3_longlatash3string ( longitudeExpr, latitudeExpr, resolutionExpr )"},
	},
	"h3_maxchild": {
		Description: "Returns the child of maximum value of the input H3 cell at the specified resolution.",
		Signatures:  []string{"h3_maxchild ( h3cellIdExpr, resolutionExpr )"},
	},
	"h3_minchild": {
		Description: "Returns the child of minimum value of the input H3 cell at the specified resolution.",
		Signatures:  []string{"h3_minchild ( h3cellIdExpr, resolutionExpr )"},
	},
	"h3_pointash3": {
		Description: "Returns the H3 cell ID (as a BIGINT) corresponding to the provided point at the specified resolution.",
		Signatures:  []string{"h3_pointash3 ( geographyExpr, resolutionExpr )"},
	},
	"h3_pointash3string": {
		Description: "Returns the H3 cell ID (as a STRING) corresponding to the provided point at the specified resolution.",
		Signatures:  []string{"h3_pointash3string ( geographyExpr, resolutionExpr )"},
	},
	"h3_polyfillash3": {
		Description: "Returns an ARRAY of H3 cell IDs (represented as BIGINT) corresponding to hexagons or pentagons, of the specified resolution, that are contained by the input areal geography.",
		Signatures:  []string{"h3_polyfillash3 ( geographyExpr, resolutionExpr )"},
	},
	"h3_polyfillash3string": {
		Description: "Returns an ARRAY of H3 cell IDs (represented as STRING) corresponding to hexagons or pentagons, of the specified resolution, that are contained by the input areal geography.",
		Signatures:  []string{"h3_polyfillash3string ( geographyExpr, resolutionExpr )"},
	},
	"h3_resolution": {
		Description: "Returns the resolution of the input H3 cell.",
		Signatures:  []string{"h3_resolution ( h3CellIdExpr )"},
	},
	"h3_stringtoh3": {
		Description: "Converts the input string, which is expected to be a hexadecimal string representing an H3 cell, to the corresponding BIGINT representation of the H3 cell.",
		Signatures:  []string{"h3_stringtoh3 ( h3CellIdExpr )"},
	},
	"h3_tessellateaswkb": {
		Description: "Returns a tessellation of the input geography using H3 cells at the specified resolution. The tessellation is represented by an ARRAY of structs, each representing an element of the tessellation. E...",
		Signatures:  []string{"h3_tessellateaswkb ( geographyExpr, resolutionExpr )"},
	},
	"h3_tochildren": {
		Description: "Returns an array of the children H3 cells of the input H3 cell at the specified resolution.",
		Signatures:  []string{"h3_tochildren ( h3cellIdExpr, resolutionExpr )"},
	},
	"h3_toparent": {
		Description: "Returns the parent H3 cell of the input H3 cell at the specified resolution.",
		Signatures:  []string{"h3_toparent ( h3cellIdExpr, resolutionExpr )"},
	},
	"h3_try_coverash3": {
		Description: "This function behaves the same as h3_coverash3, but returns NULL instead of an error if the first argument is invalid. It returns an ARRAY of BIGINT values representing H3 cell IDs. These values co...",
		Signatures:  []string{"h3_try_coverash3 ( geographyExpr, resolutionExpr )"},
	},
	"h3_try_coverash3string": {
		Description: "This function behaves the same as h3_coverash3string, but returns NULL instead of an error if the first argument is invalid. It returns an ARRAY of BIGINT values representing H3 cell IDs. These val...",
		Signatures:  []string{"h3_try_coverash3string ( geographyExpr, resolutionExpr )"},
	},
	"h3_try_distance": {
		Description: "This function behaves similarly to h3_distance, except that NULL is returned instead of an error if the grid distance between the two input H3 cell IDs of the same resolution is undefined. Specific...",
		Signatures:  []string{"h3_try_distance ( h3CellId1Expr, h3CellId2Expr )"},
	},
	"h3_try_polyfillash3": {
		Description: "Behaves the same as h3_polyfillash3, except that NULL is returned instead of an error if the first argument is invalid. More precisely, returns an ARRAY of H3 cell IDs (represented as BIGINT) corre...",
		Signatures:  []string{"h3_try_polyfillash3 ( geographyExpr, resolutionExpr )"},
	},
	"h3_try_polyfillash3string": {
		Description: "Behaves the same as h3_polyfillash3string, except that NULL is returned instead of an error if the first argument is invalid. More precisely, returns an ARRAY of H3 cell IDs (represented as STRING)...",
		Signatures:  []string{"h3_try_polyfillash3string ( geographyExpr, resolutionExpr )"},
	},
	"h3_try_tessellateaswkb": {
		Description: "This function behaves the same as h3_tessellateaswkb, but returns NULL instead of an error if the function fails to produce a tesselation. It returnstessellation of the input geography using H3 cel...",
		Signatures:  []string{"h3_try_tessellateaswkb ( geographyExpr, resolutionExpr )"},
	},
	"h3_try_validate": {
		Description: "Returns the input value, that is of type BIGINT or STRING, if it corresponds to a valid H3 cell, or NULL otherwise. In the case of STRING input, any leading zeros are trimmed.",
		Signatures:  []string{"h3_try_validate ( h3CellIdExpr )"},
	},
	"h3_uncompact": {
		Description: "Uncompacts the input set of H3 cells to the specified resolution. The uncompacted set covers the same set of H3 cells as the original one using cells at the specified resolution.",
		Signatures:  []string{"h3_uncompact ( h3CellIdsExpr, resolutionExpr )"},
	},
	"h3_validate": {
		Description: "Returns the input value, that is of type BIGINT or STRING, if it corresponds to a valid H3 cell ID, or emits an error otherwise. In the case of STRING input, any leading zeros are trimmed.",
		Signatures:  []string{"h3_validate ( h3CellIdExpr )"},
	},
	"hash": {
		Description: "Returns a hash value of the arguments.",
		Signatures:  []string{"hash(expr1, ...)"},
	},
	"hex": {
		Description: "Converts expr to hexadecimal.",
		Signatures:  []string{"hex(expr)"},
	},
	"histogram_numeric": {
		Description: "Computes a histogram on expr using numBins bins.",
		Signatures:  []string{"histogram_numeric ( [ALL | DISTINCT ] expr, numBins ) [ FILTER ( WHERE cond ) ]"},
	},
	"hll_sketch_agg": {
		Description: "This function utilizes the HyperLogLog algorithm to count a probabilistic approximation of the number of unique values in a given column, and outputs the result as a binary representation known as ...",
		Signatures:  []string{"hll_sketch_agg ( expr [, lgConfigK ] )"},
	},
	"hll_sketch_estimate": {
		Description: "This function utilizes the HyperLogLog algorithm to count a probabilistic approximation of the number of unique values in a given column, consuming a binary representation known as a sketch buffer ...",
		Signatures:  []string{"hll_sketch_estimate ( expr )"},
	},
	"hll_union": {
		Description: "This function utilizes the HyperLogLog algorithm to combine two sketches into a single sketch.",
		Signatures:  []string{"hll_union ( expr1, expr2 [, allowDifferentLgConfigK ] )"},
	},
	"hll_union_agg": {
		Description: "This function utilizes the HyperLogLog algorithm to combine a group of sketches into a single one.",
		Signatures:  []string{"hll_union_agg ( expr [, allowDifferentLgConfigK ] )"},
	},
	"hour": {
		Description: "Returns the hour component of a timestamp. This function is a synonym for extract(HOUR FROM expr).",
		Signatures:  []string{"hour(expr)"},
	},
	"http_request": {
		Description: "Makes an HTTP request using a defined HTTP connection.",
		Signatures:  []string{"http_request( { CONN => connectionName |                METHOD => httpMethod |                PATH => path |                HEADERS => headerMap |                PARAMS => paramMap |                JSON => jsonStr  } [, ..] )"},
	},
	"hypot": {
		Description: "Returns sqrt(expr1 * expr1 + expr2 * expr2).",
		Signatures:  []string{"hypot(expr1, expr2)"},
	},
	"if": {
		Description: "Returns expr1 if cond is true, or expr2 otherwise. This function is a synonym for iff function.",
		Signatures:  []string{"if(cond, expr1, expr2)"},
	},
	"iff": {
		Description: "Returns expr1 if cond is true, or expr2 otherwise. This function is a synonym for if function.",
		Signatures:  []string{"iff(cond, expr1, expr2)"},
	},
	"ifnull": {
		Description: "Returns expr2 if expr1 is NULL, or expr1 otherwise. This function is a synonym for coalesce(expr1, expr2) with two arguments.",
		Signatures:  []string{"ifnull(expr1, expr2)"},
	},
	"initcap": {
		Description: "Returns expr with the first letter of each word in uppercase according to the collation of expr. All other letters are in lowercase. Words are delimited by white space.",
		Signatures:  []string{"initcap(expr)"},
	},
	"inline": {
		Description: "Explodes an array of structs into a table.",
		Signatures:  []string{"inline(input)"},
	},
	"inline_outer": {
		Description: "Explodes an array of structs into a table with OUTER semantics.",
		Signatures:  []string{"inline_outer(input)"},
	},
	"input_file_block_length": {
		Description: "Returns the length in bytes of the block being read.",
		Signatures:  []string{"input_file_block_length()"},
	},
	"input_file_block_start": {
		Description: "Returns the start offset in bytes of the block being read.",
		Signatures:  []string{"input_file_block_start()"},
	},
	"input_file_name": {
		Description: "This function is not available on Unity Catalog.",
		Signatures:  []string{"input_file_name()"},
	},
	"instr": {
		Description: "Returns the (1-based) index of the first occurrence of substr in str.",
		Signatures:  []string{"instr(str, substr)"},
	},
	"int": {
		Description: "Casts the value expr to INTEGER. This function is a synonym for CAST(expr AS INTEGER).",
		Signatures:  []string{"int(expr)"},
	},
	"is_account_group_member": {
		Description: "Returns true if the session (connected) user is a direct or indirect member of the specified group at the account level.",
		Signatures:  []string{"is_account_group_member(group)"},
	},
	"is_member": {
		Description: "Returns true if the session (connected) user is a direct or indirect member of the specified group if the specified group is a workspace local group or an account level group assigned to the worksp...",
		Signatures:  []string{"is_member(group)"},
	},
	"is_valid_utf8": {
		Description: "Returns true if the input is a valid UTF-8 string, otherwise returns false.",
		Signatures:  []string{"is_valid_utf8(strExpr)"},
	},
	"is_variant_null": {
		Description: "Tests whether variantExpr is a VARIANT-encoded NULL.",
		Signatures:  []string{"is_variant_null ( variantExpr )"},
	},
	"isnan": {
		Description: "Returns true if expr is NaN.",
		Signatures:  []string{"isnan(expr)"},
	},
	"isnotnull": {
		Description: "Returns true if expr is not NULL. This function is a synonym for expr IS NOT NULL.",
		Signatures:  []string{"isnotnull(expr)"},
	},
	"isnull": {
		Description: "Returns true if expr is NULL. This function is a synonym for is null operator.",
		Signatures:  []string{"isnull(expr)"},
	},
	"java_method": {
		Description: "Calls a method with reflection.",
		Signatures:  []string{"java_method(class, method [, arg1 [, ...] ] )"},
	},
	"json_array_length": {
		Description: "Returns the number of elements in the outermost JSON array.",
		Signatures:  []string{"json_array_length(jsonArray)"},
	},
	"json_object_keys": {
		Description: "Returns all the keys of the outermost JSON object as an array.",
		Signatures:  []string{"json_object_keys(jsonObject)"},
	},
	"json_tuple": {
		Description: "Returns multiple JSON objects as a tuple.",
		Signatures:  []string{"json_tuple(jsonStr, path1 [, ...] )"},
	},
	"kll_sketch_agg_bigint": {
		Description: "Creates a KLL (K-Linear-Logarithmic) sketch for approximate quantile estimation on integer data with configurable accuracy.",
		Signatures:  []string{"kll_sketch_agg_bigint ( expr [, k] )"},
	},
	"kll_sketch_agg_double": {
		Description: "Creates a KLL (K-Linear-Logarithmic) sketch for approximate quantile estimation on double precision floating-point data with configurable accuracy.",
		Signatures:  []string{"kll_sketch_agg_double ( expr [, k] )"},
	},
	"kll_sketch_agg_float": {
		Description: "Creates a KLL (K-Linear-Logarithmic) sketch for approximate quantile estimation on single-precision floating-point data with configurable accuracy.",
		Signatures:  []string{"kll_sketch_agg_float ( expr [, k] )"},
	},
	"kll_sketch_get_n_bigint": {
		Description: "Returns the number of items that have been added to an integer KLL sketch.",
		Signatures:  []string{"kll_sketch_get_n_bigint ( sketch )"},
	},
	"kll_sketch_get_n_double": {
		Description: "Returns the number of items that have been added to a double KLL sketch.",
		Signatures:  []string{"kll_sketch_get_n_double ( sketch )"},
	},
	"kll_sketch_get_n_float": {
		Description: "Returns the number of items that have been added to a float KLL sketch.",
		Signatures:  []string{"kll_sketch_get_n_float ( sketch )"},
	},
	"kll_sketch_get_quantile_bigint": {
		Description: "Estimates the value at a given quantile rank (or multiple ranks) from an integer KLL sketch.",
		Signatures:  []string{"kll_sketch_get_quantile_bigint ( sketch, rank )"},
	},
	"kll_sketch_get_quantile_double": {
		Description: "Estimates the value at a given quantile rank (or multiple ranks) from a double KLL sketch.",
		Signatures:  []string{"kll_sketch_get_quantile_double ( sketch, rank )"},
	},
	"kll_sketch_get_quantile_float": {
		Description: "Estimates the value at a given quantile rank (or multiple ranks) from a float KLL sketch.",
		Signatures:  []string{"kll_sketch_get_quantile_float ( sketch, rank )"},
	},
	"kll_sketch_get_rank_bigint": {
		Description: "Estimates the normalized rank (0.0 to 1.0) of a given value in an integer KLL sketch.",
		Signatures:  []string{"kll_sketch_get_rank_bigint ( sketch, value )"},
	},
	"kll_sketch_get_rank_double": {
		Description: "Estimates the normalized rank (0.0 to 1.0) of a given value in a double KLL sketch.",
		Signatures:  []string{"kll_sketch_get_rank_double ( sketch, value )"},
	},
	"kll_sketch_get_rank_float": {
		Description: "Estimates the normalized rank (0.0 to 1.0) of a given value in a float KLL sketch.",
		Signatures:  []string{"kll_sketch_get_rank_float ( sketch, value )"},
	},
	"kll_sketch_merge_bigint": {
		Description: "Merges two compatible integer KLL sketches into a single sketch.",
		Signatures:  []string{"kll_sketch_merge_bigint ( sketch1, sketch2 )"},
	},
	"kll_sketch_merge_double": {
		Description: "Merges two compatible double KLL sketches into a single sketch.",
		Signatures:  []string{"kll_sketch_merge_double ( sketch1, sketch2 )"},
	},
	"kll_sketch_merge_float": {
		Description: "Merges two compatible float KLL sketches into a single sketch.",
		Signatures:  []string{"kll_sketch_merge_float ( sketch1, sketch2 )"},
	},
	"kll_sketch_to_string_bigint": {
		Description: "Returns a human-readable string representation of an integer KLL sketch for debugging.",
		Signatures:  []string{"kll_sketch_to_string_bigint ( sketch )"},
	},
	"kll_sketch_to_string_double": {
		Description: "Returns a human-readable string representation of a double KLL sketch for debugging.",
		Signatures:  []string{"kll_sketch_to_string_double ( sketch )"},
	},
	"kll_sketch_to_string_float": {
		Description: "Returns a human-readable string representation of a float KLL sketch for debugging.",
		Signatures:  []string{"kll_sketch_to_string_float ( sketch )"},
	},
	"kurtosis": {
		Description: "Returns the kurtosis value calculated from values of a group.",
		Signatures:  []string{"kurtosis ( [ALL | DISTINCT] expr ) [FILTER ( WHERE cond ) ]"},
	},
	"lag": {
		Description: "Returns the value of expr from a preceding row within the partition.",
		Signatures:  []string{"lag( expr [, offset [, default] ] ) [ IGNORE NULLS | RESPECT NULLS ] OVER clause"},
	},
	"last": {
		Description: "Returns the last value of expr for the group of rows. The function is a synonym for last_value aggregate function.",
		Signatures:  []string{"last(expr [, ignoreNull] ) [FILTER ( WHERE cond ) ] [ IGNORE NULLS | RESPECT NULLS ]"},
	},
	"last_day": {
		Description: "Returns the last day of the month that the date belongs to.",
		Signatures:  []string{"last_day(expr)"},
	},
	"last_value": {
		Description: "Returns the last value of expr for the group of rows. The function is a synonym for last aggregate function.",
		Signatures:  []string{"last_value(expr [, ignoreNull] ) [FILTER ( WHERE cond ) ] [ IGNORE NULLS | RESPECT NULLS ]"},
	},
	"lcase": {
		Description: "Returns expr with all characters changed to lowercase according to the collation of expr.",
		Signatures:  []string{"lcase(expr)"},
	},
	"lead": {
		Description: "Returns the value of expr from a subsequent row within the partition. This function is a synonym to lag(expr, -offset, default).",
		Signatures:  []string{"lead(expr [, offset [, default] ] ) [ IGNORE NULLS | RESPECT NULLS ] OVER clause"},
	},
	"least": {
		Description: "Returns the least value of all parameters, skipping null values.",
		Signatures:  []string{"least(expr1, expr2 [, ...] )"},
	},
	"left": {
		Description: "Returns the leftmost len characters from str.",
		Signatures:  []string{"left(str, len)"},
	},
	"len": {
		Description: "Returns the character length of string data or number of bytes of binary data. This function is a synonym for character_length function and char_length function.",
		Signatures:  []string{"len(expr)"},
	},
	"length": {
		Description: "Returns the character length of string data or number of bytes of binary data. This function is a synonym for character_length function and char_length function.",
		Signatures:  []string{"length(expr)"},
	},
	"levenshtein": {
		Description: "Returns the Levenshtein distance between the strings str1 and str2.",
		Signatures:  []string{"levenshtein(str1, str2 [, maxDistance])"},
	},
	"list_secrets": {
		Description: "Returns all keys in all scopes or one specific scope the user is authorized to see from Databricks secret service.",
		Signatures:  []string{"list_secrets ( [ scopeStr ] )"},
	},
	"listagg": {
		Description: "Returns concatenated STRING and BINARY values within a group.",
		Signatures:  []string{"listagg ( [ALL | DISTINCT] expr [, delimiter] )  [ WITHIN GROUP (ORDER BY { sortKey [ sort_direction ] [ nulls_sort_oder ] } [, ...] ) ]  [ FILTER ( WHERE cond ) ]sort_direction  [ ASC | DESC ]nulls_sort_order  [ NULLS FIRST | NULLS LAST ]"},
	},
	"ln": {
		Description: "Returns the natural logarithm (base e) of expr.",
		Signatures:  []string{"ln(expr)"},
	},
	"locate": {
		Description: "Returns the position of the first occurrence of substr in str after position pos. This function is a synonym for position function.",
		Signatures:  []string{"locate(substr, str [, pos] )"},
	},
	"log": {
		Description: "Returns the logarithm of expr with base.",
		Signatures:  []string{"log( [ base , ] expr)"},
	},
	"log10": {
		Description: "Returns the logarithm of expr with base 10.",
		Signatures:  []string{"log10(expr)"},
	},
	"log1p": {
		Description: "Returns log(1 + expr).",
		Signatures:  []string{"log1p(expr)"},
	},
	"log2": {
		Description: "Returns the logarithm of expr with base 2.",
		Signatures:  []string{"log2(expr)"},
	},
	"lower": {
		Description: "Returns expr with all characters changed to lowercase according to the collation of expr.",
		Signatures:  []string{"lower(expr)"},
	},
	"lpad": {
		Description: "Returns expr, left-padded with pad to a length of len.",
		Signatures:  []string{"lpad(expr, len [, pad] )"},
	},
	"ltrim": {
		Description: "Returns str with leading characters within trimStr removed.",
		Signatures:  []string{"ltrim( [trimstr ,] str)"},
	},
	"luhn_check": {
		Description: "Returns true if numStr passes the Luhn algorithm check.",
		Signatures:  []string{"luhn_check(numStr)"},
	},
	"make_date": {
		Description: "Creates a date from year, month, and day fields.",
		Signatures:  []string{"make_date(year, month, day)"},
	},
	"make_dt_interval": {
		Description: "Creates an interval from days, hours, mins and secs.",
		Signatures:  []string{"make_dt_interval( [ days [, hours [, mins [, secs] ] ] ] )"},
	},
	"make_interval": {
		Description: "Creates an interval from years, months, weeks, days, hours, mins and secs.",
		Signatures:  []string{"make_interval( [years [, months [, weeks [, days [, hours [, mins [, secs] ] ] ] ] ] ] )"},
	},
	"make_timestamp": {
		Description: "Creates a timestamp from year, month, day, hour, min, sec, and timezone fields.",
		Signatures:  []string{"make_timestamp(year, month, day, hour, min, sec [, timezone] )"},
	},
	"make_valid_utf8": {
		Description: "Returns a string in which all invalid UTF-8 byte sequences in strExpr, are replaced by the Unicode replacement character (U+FFFD).",
		Signatures:  []string{"make_valid_utf8(strExpr)"},
	},
	"make_ym_interval": {
		Description: "Creates an year-month interval from years and months.",
		Signatures:  []string{"make_ym_interval( [ years [, months ] ] )"},
	},
	"map": {
		Description: "Creates a map with the specified key-value pairs.",
		Signatures:  []string{"map( [key1, value1] [, ...] )"},
	},
	"map_concat": {
		Description: "Returns the union of all expr map expressions.",
		Signatures:  []string{"map_concat([ expr1 [, ...] ])"},
	},
	"map_contains_key": {
		Description: "Returns true if map contains key.",
		Signatures:  []string{"map_contains_key(map, key)"},
	},
	"map_entries": {
		Description: "Returns an unordered array of all entries in map.",
		Signatures:  []string{"map_entries(map)"},
	},
	"map_filter": {
		Description: "Filters entries in the map in expr using the function func.",
		Signatures:  []string{"map_filter(expr, func)"},
	},
	"map_from_arrays": {
		Description: "Creates a map with a pair of the keys and values arrays.",
		Signatures:  []string{"map_from_arrays(keys, values)"},
	},
	"map_from_entries": {
		Description: "Creates a map created from the specified array of entries.",
		Signatures:  []string{"map_from_entries(expr)"},
	},
	"map_keys": {
		Description: "Returns an unordered array containing the keys of map.",
		Signatures:  []string{"map_keys(map)"},
	},
	"map_values": {
		Description: "Returns an unordered array containing the values of map.",
		Signatures:  []string{"map_values(map)"},
	},
	"map_zip_with": {
		Description: "Merges map1 and map2 into a single map.",
		Signatures:  []string{"map_zip_with(map1, map2, func)"},
	},
	"mask": {
		Description: "Returns a masked version of the input str.",
		Signatures:  []string{"mask(str [, upperChar [, lowerChar [, digitChar [, otherChar ] ] ] ] )"},
	},
	"max": {
		Description: "Returns the maximum value of expr in a group.",
		Signatures:  []string{"max(expr) [FILTER ( WHERE cond ) ]"},
	},
	"max_by": {
		Description: "Returns the value of an expr1 associated with the maximum value of expr2 in a group.",
		Signatures:  []string{"max_by(expr1, expr2) [FILTER ( WHERE cond ) ]"},
	},
	"md5": {
		Description: "Returns an MD5 128-bit checksum of expr as a hex string.",
		Signatures:  []string{"md5(expr)"},
	},
	"mean": {
		Description: "Returns the mean calculated from values of a group. This function is a synonym for avg aggregate function.",
		Signatures:  []string{"mean ( [ALL | DISTINCT] expr ) [FILTER ( WHERE cond ) ]"},
	},
	"measure": {
		Description: "Returns the measure_column aggregated from the values of a group.",
		Signatures:  []string{"measure ( measure_column )"},
	},
	"median": {
		Description: "Returns the median calculated from values of a group.",
		Signatures:  []string{"median ( [ALL | DISTINCT] expr ) [FILTER ( WHERE cond ) ]"},
	},
	"min": {
		Description: "Returns the minimum value of expr in a group.",
		Signatures:  []string{"min(expr) [FILTER ( WHERE cond ) ]"},
	},
	"min_by": {
		Description: "Returns the value of an expr1 associated with the minimum value of expr2 in a group.",
		Signatures:  []string{"min_by(expr1, expr2) [FILTER ( WHERE cond ) ]"},
	},
	"minute": {
		Description: "Returns the minute component of the timestamp in expr. This function is a synonym for extract(MINUTES FROM expr).",
		Signatures:  []string{"minute(expr)"},
	},
	"mod": {
		Description: "Returns the remainder after dividend / divisor. This function is equivalent to the % (percent sign) operator.",
		Signatures:  []string{"mod(dividend, divisor)"},
	},
	"mode": {
		Description: "Returns the most frequent, not NULL, value of expr in a group.",
		Signatures:  []string{"mode(expr [, deterministic ]) [FILTER ( WHERE cond ) ]"},
	},
	"monotonically_increasing_id": {
		Description: "Returns monotonically increasing 64-bit integers.",
		Signatures:  []string{"monotonically_increasing_id()"},
	},
	"month": {
		Description: "Returns the month component of the timestamp in expr. This function is a synonym for extract(MONTH FROM expr).",
		Signatures:  []string{"month(expr)"},
	},
	"months_between": {
		Description: "Returns the number of months elapsed between dates or timestamps in expr1 and expr2.",
		Signatures:  []string{"months_between(expr1, expr2 [, roundOff] )"},
	},
	"named_struct": {
		Description: "Creates a struct with the specified field names and values.",
		Signatures:  []string{"named_struct( {name1, val1} [, ...] )"},
	},
	"nanvl": {
		Description: "Returns expr1 if it's not NaN, or expr2 otherwise.",
		Signatures:  []string{"nanvl(expr1, expr2)"},
	},
	"negative": {
		Description: "Returns the negated value of expr. This function is a synonym for - (minus sign) unary operator.",
		Signatures:  []string{"negative(expr)"},
	},
	"next_day": {
		Description: "Returns the first date which is later than expr and named as in dayOfWeek.",
		Signatures:  []string{"next_day(expr, dayOfWeek)"},
	},
	"now": {
		Description: "Returns the current timestamp at the start of query evaluation.",
		Signatures:  []string{"now()"},
	},
	"nth_value": {
		Description: "Returns the value at a specific offset in the window.",
		Signatures:  []string{"nth_value(expr, offset) [ IGNORE NULLS | RESPECT NULLS ] OVER clause"},
	},
	"ntile": {
		Description: "Divides the rows for each window partition into n buckets ranging from 1 to at most n.",
		Signatures:  []string{"ntile([n])"},
	},
	"nullif": {
		Description: "Returns NULL if expr1 equals expr2, or expr1 otherwise.",
		Signatures:  []string{"nullif(expr1, expr2)"},
	},
	"nullifzero": {
		Description: "Returns NULL if expr is 0, or expr otherwise. This function is a synonym for if(expr = 0, null, expr).",
		Signatures:  []string{"nullifzero(expr)"},
	},
	"nvl": {
		Description: "Returns expr2 if expr1 is NULL, or expr1 otherwise. This function is a synonym for coalesce(expr1, expr2) with two arguments.",
		Signatures:  []string{"nvl(expr1, expr2)"},
	},
	"nvl2": {
		Description: "Returns expr2 if expr1 is not NULL, or expr3 otherwise. This function is a synonym for CASE WHEN expr1 IS NOT NULL expr2 ELSE expr3 END.",
		Signatures:  []string{"nvl2(expr1, expr2, expr3)"},
	},
	"octet_length": {
		Description: "Returns the byte length of string data or number of bytes of binary data.",
		Signatures:  []string{"octet_length(expr)"},
	},
	"overlay": {
		Description: "Replaces input with replace that starts at pos and is of length len.",
		Signatures:  []string{"overlay(input, replace, pos[, len])"},
	},
	"parse_json": {
		Description: "Returns a VARIANT value from the jsonStr.",
		Signatures:  []string{"parse_json ( jsonStr )"},
	},
	"parse_url": {
		Description: "Extracts a part from url.",
		Signatures:  []string{"parse_url(url, partToExtract [, key] )"},
	},
	"percent_rank": {
		Description: "Computes the percentage ranking of a value within the partition.",
		Signatures:  []string{"percent_rank()"},
	},
	"percentile": {
		Description: "Returns the exact percentile value of expr at the specified percentage in a group.",
		Signatures:  []string{"percentile ( [ALL | DISTINCT] expr, percentage [, frequency] ) [FILTER ( WHERE cond ) ]"},
	},
	"percentile_approx": {
		Description: "Returns the approximate percentile of the expr within the group. This function is a synonym for approx_percentile aggregate function.",
		Signatures:  []string{"percentile_approx ( [ALL | DISTINCT ] expr, percentile [, accuracy] ) [FILTER ( WHERE cond ) ]"},
	},
	"percentile_cont": {
		Description: "Returns the value that corresponds to the percentile of the provided sortKeys using a continuous distribution model.",
		Signatures:  []string{"percentile_cont ( percentile )       WITHIN GROUP (ORDER BY sortKey [ASC | DESC] )"},
	},
	"percentile_disc": {
		Description: "Returns the value that corresponds to the percentile of the provided sortKey using a discrete distribution model.",
		Signatures:  []string{"percentile_disc ( percentile )       WITHIN GROUP (ORDER BY sortKey [ASC | DESC] )"},
	},
	"pi": {
		Description: "The function takes no argument.",
		Signatures:  []string{"pi()"},
	},
	"pmod": {
		Description: "Returns the positive remainder after dividend / divisor.",
		Signatures:  []string{"pmod(dividend, divisor)"},
	},
	"posexplode": {
		Description: "Returns a set of rows by un-nesting expr with numbering of positions.",
		Signatures:  []string{"posexplode(collection)"},
	},
	"posexplode_outer": {
		Description: "Returns rows by un-nesting the array with numbering of positions using OUTER semantics.",
		Signatures:  []string{"posexplode_outer(collection)"},
	},
	"position": {
		Description: "Returns the position of the first occurrence of substr in str after position pos. This function is a synonym for locate function.",
		Signatures:  []string{"position(substr, str [, pos] )"},
	},
	"positive": {
		Description: "Returns the value of expr. This function is a synonym for + (plus sign) unary operator.",
		Signatures:  []string{"positive(expr)"},
	},
	"pow": {
		Description: "Raises expr1 to the power of expr2. This function is a synonym for power function.",
		Signatures:  []string{"pow(expr1, expr2)"},
	},
	"power": {
		Description: "Raises expr1 to the power of expr2. This function is a synonym for pow function.",
		Signatures:  []string{"power(expr1, expr2)"},
	},
	"printf": {
		Description: "Returns a formatted string from printf-style format strings.",
		Signatures:  []string{"printf(strfmt[, obj1, ...])"},
	},
	"quarter": {
		Description: "Returns the quarter of the year for expr in the range 1 to 4. This function is a synonym for extract(QUARTER FROM expr).",
		Signatures:  []string{"quarter(expr)"},
	},
	"radians": {
		Description: "Converts expr in degrees to radians.",
		Signatures:  []string{"radians(expr)"},
	},
	"raise_error": {
		Description: "Throws an exception with expr as the message.",
		Signatures:  []string{"raise_error(expr)"},
	},
	"rand": {
		Description: "Returns a random value between 0 and 1. This function is a synonym for random function.",
		Signatures:  []string{"rand( [seed] )"},
	},
	"randn": {
		Description: "Returns a random value from a standard normal distribution.",
		Signatures:  []string{"randn( [seed] )"},
	},
	"random": {
		Description: "Returns a random value between 0 and 1. This function is a synonym for rand function.",
		Signatures:  []string{"random( [ seed ] )"},
	},
	"randstr": {
		Description: "Returns a random string of length alpha-numeric characters.",
		Signatures:  []string{"randstr ( length [, seed] )"},
	},
	"range": {
		Description: "Returns a table of values within a specified range.",
		Signatures:  []string{"range(end)range(start, end [, step [, numParts] ] )"},
	},
	"rank": {
		Description: "Returns the rank of a value compared to all values in the partition.",
		Signatures:  []string{"rank()"},
	},
	"read_files": {
		Description: "Reads files under a provided location and returns the data in tabular form.",
		Signatures:  []string{"read_files(path [, option_key => option_value ] [...])"},
	},
	"read_kafka": {
		Description: "Reads data from an Apache Kafka cluster and returns the data in tabular form.",
		Signatures:  []string{"read_kafka([option_key => option_value ] [, ...])"},
	},
	"read_kinesis": {
		Description: "Returns a table with records read from Kinesis from one or more streams.",
		Signatures:  []string{"read_kinesis ( { parameter => value } [, ...] )"},
	},
	"read_pubsub": {
		Description: "Returns a table with records read from Pub/Sub from a topic. Only supports streaming queries.",
		Signatures:  []string{"read_pubsub( { parameter => value } [, ...])"},
	},
	"read_pulsar": {
		Description: "This feature is in Public Preview.",
		Signatures:  []string{"read_pulsar ( { option_key => option_value } [, ...] )"},
	},
	"read_state_metadata": {
		Description: "Returns a table with rows that represent the metadata of a streaming query state.",
		Signatures:  []string{"read_state_metadata(path)"},
	},
	"read_statestore": {
		Description: "A table valued function for reading records from the state store of streaming queries. The returned relation only supports running as a batch query.",
		Signatures:  []string{"read_statestore ( path [, option_key => option_value ] [ ... ] )"},
	},
	"reduce": {
		Description: "Aggregates elements in an array using a custom aggregator. This function is a synonym for aggregate function.",
		Signatures:  []string{"reduce(expr, start, merge [, finish] )"},
	},
	"reflect": {
		Description: "Calls a method with reflection.",
		Signatures:  []string{"reflect(class, method [, arg1] [, ...])"},
	},
	"regexp_count": {
		Description: "Returns the number of times str matches the regexp pattern.",
		Signatures:  []string{"regexp_count( str, regexp )"},
	},
	"regexp_extract": {
		Description: "Extracts the first string in str that matches the regexp expression and corresponds to the regex group index.",
		Signatures:  []string{"regexp_extract(str, regexp [, idx] )"},
	},
	"regexp_extract_all": {
		Description: "Extracts all of the strings in str that match the regexp expression and correspond to the regex group index.",
		Signatures:  []string{"regexp_extract_all(str, regexp [, idx] )"},
	},
	"regexp_instr": {
		Description: "Returns the position of the first substring in str that matches regexp.",
		Signatures:  []string{"regexp_instr( str, regexp )"},
	},
	"regexp_like": {
		Description: "Returns true if str matches regex. This function is a synonym for rlike operator.",
		Signatures:  []string{"regexp_like( str, regex )"},
	},
	"regexp_replace": {
		Description: "Replaces all substrings of str that match regexp with rep.",
		Signatures:  []string{"regexp_replace(str, regexp, rep [, position] )"},
	},
	"regexp_substr": {
		Description: "Returns the first substring in str that matches regexp.",
		Signatures:  []string{"regexp_substr( str, regexp )"},
	},
	"regr_avgx": {
		Description: "Returns the mean of xExpr calculated from values of a group where xExpr and yExpr are NOT NULL.",
		Signatures:  []string{"regr_avgx( [ALL | DISTINCT] yExpr, xExpr) [FILTER ( WHERE cond ) ]"},
	},
	"regr_avgy": {
		Description: "Returns the mean of yExpr calculated from values of a group where xExpr and yExpr are NOT NULL.",
		Signatures:  []string{"regr_avgy( [ALL | DISTINCT] yExpr, xExpr) [FILTER ( WHERE cond ) ]"},
	},
	"regr_count": {
		Description: "Returns the number of non-null value pairs yExpr, xExpr in the group.",
		Signatures:  []string{"regr_count ( [ALL | DISTINCT] yExpr, xExpr ) [FILTER ( WHERE cond ) ]"},
	},
	"regr_intercept": {
		Description: "Returns the intercept of the univariate linear regression line in a group where xExpr and yExpr are NOT NULL.",
		Signatures:  []string{"regr_intercept( [ALL | DISTINCT] yExpr, xExpr) [FILTER ( WHERE cond ) ]"},
	},
	"regr_r2": {
		Description: "Returns the coefficient of determination from values of a group where xExpr and yExpr are NOT NULL.",
		Signatures:  []string{"regr_r2( [ALL | DISTINCT] yExpr, xExpr) [FILTER ( WHERE cond ) ]"},
	},
	"regr_slope": {
		Description: "Returns the slope of the linear regression line in a group where xExpr and yExpr are NOT NULL.",
		Signatures:  []string{"regr_slope( [ALL | DISTINCT] yExpr, xExpr) [FILTER ( WHERE cond ) ]"},
	},
	"regr_sxx": {
		Description: "Returns the sum of squares of the xExpr values of a group where xExpr and yExpr are NOT NULL.",
		Signatures:  []string{"regr_sxx( [ALL | DISTINCT] yExpr, xExpr) [FILTER ( WHERE cond ) ]"},
	},
	"regr_sxy": {
		Description: "Returns the sum of products of yExpr and xExpr calculated from values of a group where xExpr and yExpr are NOT NULL.",
		Signatures:  []string{"regr_sxy( [ALL | DISTINCT] yExpr, xExpr) [FILTER ( WHERE cond ) ]"},
	},
	"regr_syy": {
		Description: "Returns the sum of squares of the yExpr values of a group where xExpr and yExpr are NOT NULL.",
		Signatures:  []string{"regr_syy( [ALL | DISTINCT] yExpr, xExpr) [FILTER ( WHERE cond ) ]"},
	},
	"remote_query": {
		Description: "This feature is in Public Preview.",
		Signatures:  []string{"remote_query(connectionName [, connectorOptionKey => connectorOptionValue ] [...])"},
	},
	"repeat": {
		Description: "Returns the string that repeats expr n times.",
		Signatures:  []string{"repeat(expr, n)"},
	},
	"replace": {
		Description: "Replaces all occurrences of search with replace.",
		Signatures:  []string{"replace(str, search [, replace] )"},
	},
	"reverse": {
		Description: "Returns a reversed string or an array with reverse order of elements.",
		Signatures:  []string{"reverse(expr)"},
	},
	"right": {
		Description: "Returns the rightmost len characters from the string str.",
		Signatures:  []string{"right(str, len)"},
	},
	"rint": {
		Description: "Returns expr rounded to a whole number as a DOUBLE. This function is a synonym for round(expr, 0).",
		Signatures:  []string{"rint(expr)"},
	},
	"round": {
		Description: "Returns the rounded expr using HALF_UP rounding mode.",
		Signatures:  []string{"round(expr [, targetScale] )"},
	},
	"row_number": {
		Description: "Assigns a unique, sequential number to each row, starting with one, according to the ordering of rows in the window partition.",
		Signatures:  []string{"row_number()"},
	},
	"rpad": {
		Description: "Returns expr, right-padded with pad to a length of len.",
		Signatures:  []string{"rpad(expr, len [, pad] )"},
	},
	"rtrim": {
		Description: "Returns str with trailing characters removed.",
		Signatures:  []string{"rtrim( [trimStr ,] str)"},
	},
	"schema_of_csv": {
		Description: "Returns the schema of a CSV string in DDL format.",
		Signatures:  []string{"schema_of_csv(csv [, options] )"},
	},
	"schema_of_json": {
		Description: "Returns the schema of a JSON string in DDL format.",
		Signatures:  []string{"schema_of_json(jsonStr [, options] )"},
	},
	"schema_of_json_agg": {
		Description: "Returns the combined schema of all JSON strings in a group in DDL format.",
		Signatures:  []string{"schema_of_json_agg(jsonStr [, options] ) [FILTER ( WHERE cond ) ]"},
	},
	"schema_of_variant": {
		Description: "Returns the schema of a VARIANT expression in DDL format.",
		Signatures:  []string{"schema_of_variant ( variantExpr )"},
	},
	"schema_of_variant_agg": {
		Description: "Returns the combined schema of all VARIANT values in a group in DDL format.",
		Signatures:  []string{"schema_of_variant_agg ( variantExpr ) [FILTER ( WHERE cond ) ]"},
	},
	"schema_of_xml": {
		Description: "This feature is in Public Preview.",
		Signatures:  []string{"schema_of_xml(xmlStr [, options] )"},
	},
	"sec": {
		Description: "Returns the secant of expr.",
		Signatures:  []string{"sec(expr)"},
	},
	"second": {
		Description: "Returns the second component of the timestamp in expr.",
		Signatures:  []string{"second(expr)"},
	},
	"secret": {
		Description: "Extracts a secret value with the given scope and key from Databricks secret service.",
		Signatures:  []string{"secret ( scope, key )"},
	},
	"sentences": {
		Description: "Splits str into an array of array of words.",
		Signatures:  []string{"sentences(str [, lang, country] )"},
	},
	"sequence": {
		Description: "Generates an array of elements from start to stop (inclusive), incrementing by step.",
		Signatures:  []string{"sequence(start, stop [, step] )"},
	},
	"session_user": {
		Description: "Returns the user connected to Databricks.",
		Signatures:  []string{"session_user()"},
	},
	"sha": {
		Description: "Returns a sha1 hash value as a hex string of expr. This function is a synonym for sha1 function.",
		Signatures:  []string{"sha(expr)"},
	},
	"sha1": {
		Description: "Returns a sha1 hash value as a hex string of expr. This function is a synonym for sha function.",
		Signatures:  []string{"sha1(expr)"},
	},
	"sha2": {
		Description: "Returns a checksum of the SHA-2 family as a hex string of expr.",
		Signatures:  []string{"sha2(expr, bitLength)"},
	},
	"shiftleft": {
		Description: "Returns a bitwise left shifted by n bits.",
		Signatures:  []string{"shiftleft(expr, n)"},
	},
	"shiftright": {
		Description: "Returns a bitwise signed right shifted by n bits.",
		Signatures:  []string{"shiftright(expr, n)"},
	},
	"shiftrightunsigned": {
		Description: "Returns a bitwise unsigned right shifted by n bits.",
		Signatures:  []string{"shiftrightunsigned(expr, n)"},
	},
	"shuffle": {
		Description: "Returns a random permutation of the array in expr.",
		Signatures:  []string{"shuffle(expr)"},
	},
	"sign": {
		Description: "Returns -1.0, 0.0, or 1.0 as expr is negative, 0, or positive. This function is a synonym for signum function.",
		Signatures:  []string{"sign(expr)"},
	},
	"signum": {
		Description: "Returns -1.0, 0.0, or 1.0 as expr is negative, 0, or positive. This function is a synonym for sign function.",
		Signatures:  []string{"signum(expr)"},
	},
	"sin": {
		Description: "Returns the sine of expr.",
		Signatures:  []string{"sin(expr)"},
	},
	"sinh": {
		Description: "Returns the hyperbolic sine of expr.",
		Signatures:  []string{"sinh(expr)"},
	},
	"size": {
		Description: "Returns the cardinality of the array or map in expr.",
		Signatures:  []string{"size(expr)"},
	},
	"skewness": {
		Description: "Returns the skewness value calculated from values of a group.",
		Signatures:  []string{"skewness ( [ALL | DISTINCT ] expr ) [FILTER ( WHERE cond ) ]"},
	},
	"slice": {
		Description: "Returns a subset of an array.",
		Signatures:  []string{"slice(expr, start, length)"},
	},
	"smallint": {
		Description: "Casts the value expr to SMALLINT. This function is a synonym for CAST(expr AS SMALLINT). See cast function for details.",
		Signatures:  []string{"smallint(expr)"},
	},
	"some": {
		Description: "Returns true if at least one value of expr in a group is true.",
		Signatures:  []string{"some(expr) [FILTER ( WHERE cond ) ]"},
	},
	"sort_array": {
		Description: "Returns the array in expr in sorted order.",
		Signatures:  []string{"sort_array(expr [, ascendingOrder] )"},
	},
	"soundex": {
		Description: "Returns the soundex code of the string.",
		Signatures:  []string{"soundex(expr)"},
	},
	"space": {
		Description: "Returns a string consisting of n spaces.",
		Signatures:  []string{"space(n)"},
	},
	"spark_partition_id": {
		Description: "Returns the current partition ID.",
		Signatures:  []string{"spark_partition_id()"},
	},
	"split": {
		Description: "Splits str around occurrences that match regex and returns an array with a length of at most limit.",
		Signatures:  []string{"split(str, regex [, limit] )"},
	},
	"split_part": {
		Description: "Splits str around occurrences of delim and returns the partNum part.",
		Signatures:  []string{"split_part(str, delim, partNum)"},
	},
	"sql_keywords": {
		Description: "Returns the set of SQL keywords in Databricks.",
		Signatures:  []string{"sql_keywords()"},
	},
	"sqrt": {
		Description: "Returns the square root of expr.",
		Signatures:  []string{"sqrt(expr)"},
	},
	"st_addpoint": {
		Description: "This feature is in Public Preview.",
		Signatures:  []string{"st_addpoint ( geo1Expr, geo2Expr[, indexExpr] )"},
	},
	"st_area": {
		Description: "This feature is in Public Preview.",
		Signatures:  []string{"st_area ( geoExpr )"},
	},
	"st_asbinary": {
		Description: "This feature is in Public Preview.",
		Signatures:  []string{"st_asbinary ( geoExpr[, endiannessExpr] )"},
	},
	"st_asewkb": {
		Description: "This feature is in Public Preview.",
		Signatures:  []string{"st_asewkb ( geoExpr[, endiannessExpr] )"},
	},
	"st_asewkt": {
		Description: "This feature is in Public Preview.",
		Signatures:  []string{"st_asbinary ( geoExpr )"},
	},
	"st_asgeojson": {
		Description: "This feature is in Public Preview.",
		Signatures:  []string{"st_asgeojson ( geoExpr )"},
	},
	"st_astext": {
		Description: "This feature is in Public Preview.",
		Signatures:  []string{"st_astext ( geoExpr )"},
	},
	"st_aswkb": {
		Description: "This feature is in Public Preview.",
		Signatures:  []string{"st_aswkb ( geoExpr[, endiannessExpr] )"},
	},
	"st_aswkt": {
		Description: "This feature is in Public Preview.",
		Signatures:  []string{"st_aswkt ( geoExpr )"},
	},
	"st_buffer": {
		Description: "This feature is in Public Preview.",
		Signatures:  []string{"st_buffer ( geoExpr, radiusExpr )"},
	},
	"st_centroid": {
		Description: "This feature is in Public Preview.",
		Signatures:  []string{"st_centroid ( geoExpr )"},
	},
	"st_concavehull": {
		Description: "This feature is in Public Preview.",
		Signatures:  []string{"st_concavehull ( geoExpr, lengthRatioExpr[, allowHolesExpr])"},
	},
	"st_contains": {
		Description: "This feature is in Public Preview.",
		Signatures:  []string{"st_contains ( geoExpr1, geoExpr2 )"},
	},
	"st_convexhull": {
		Description: "This feature is in Public Preview.",
		Signatures:  []string{"st_convexhull ( geoExpr )"},
	},
	"st_covers": {
		Description: "This feature is in Public Preview.",
		Signatures:  []string{"st_covers ( geoExpr1, geoExpr2 )"},
	},
	"st_difference": {
		Description: "This feature is in Public Preview.",
		Signatures:  []string{"st_difference ( geoExpr1, geoExpr2 )"},
	},
	"st_dimension": {
		Description: "This feature is in Public Preview.",
		Signatures:  []string{"st_dimension ( geoExpr )"},
	},
	"st_disjoint": {
		Description: "This feature is in Public Preview.",
		Signatures:  []string{"st_disjoint ( geoExpr1, geoExpr2 )"},
	},
	"st_distance": {
		Description: "This feature is in Public Preview.",
		Signatures:  []string{"st_distance ( geoExpr1, geoExpr2 )"},
	},
	"st_distancesphere": {
		Description: "This feature is in Public Preview.",
		Signatures:  []string{"st_distancesphere ( geoExpr1, geoExpr2 )"},
	},
	"st_distancespheroid": {
		Description: "This feature is in Public Preview.",
		Signatures:  []string{"st_distancespheroid ( geoExpr1, geoExpr2 )"},
	},
	"st_dump": {
		Description: "This feature is in Public Preview.",
		Signatures:  []string{"st_dump ( geoExpr )"},
	},
	"st_dwithin": {
		Description: "This feature is in Public Preview.",
		Signatures:  []string{"st_dwithin ( geoExpr1, geoExpr2, distanceExpr )"},
	},
	"st_endpoint": {
		Description: "This feature is in Public Preview.",
		Signatures:  []string{"st_endpoint ( geoExpr )"},
	},
	"st_envelope": {
		Description: "This feature is in Public Preview.",
		Signatures:  []string{"st_envelope ( geoExpr )"},
	},
	"st_envelope_agg": {
		Description: "This feature is in Public Preview.",
		Signatures:  []string{"st_envelope_agg ( geoCol )"},
	},
	"st_equals": {
		Description: "This feature is in Public Preview.",
		Signatures:  []string{"st_equals ( geoExpr1, geoExpr2 )"},
	},
	"st_exteriorring": {
		Description: "This feature is in Public Preview.",
		Signatures:  []string{"st_exteriorring ( geoExpr )"},
	},
	"st_flipcoordinates": {
		Description: "This feature is in Public Preview.",
		Signatures:  []string{"st_flipcoordinates ( geoExpr )"},
	},
	"st_geogfromgeojson": {
		Description: "This feature is in Public Preview.",
		Signatures:  []string{"st_geogfromgeojson ( geojsonExpr )"},
	},
	"st_geogfromtext": {
		Description: "This feature is in Public Preview.",
		Signatures:  []string{"st_geogfromtext ( wktExpr )"},
	},
	"st_geogfromwkb": {
		Description: "This feature is in Public Preview.",
		Signatures:  []string{"st_geogfromwkb ( wkbExpr )"},
	},
	"st_geogfromwkt": {
		Description: "This feature is in Public Preview.",
		Signatures:  []string{"st_geogfromwkt ( wktExpr )"},
	},
	"st_geohash": {
		Description: "This feature is in Public Preview.",
		Signatures:  []string{"st_geohash ( geoExpr [, precisionExpr] )"},
	},
	"st_geometryn": {
		Description: "This feature is in Public Preview.",
		Signatures:  []string{"st_geometryn ( geoExpr, nExpr )"},
	},
	"st_geometrytype": {
		Description: "This feature is in Public Preview.",
		Signatures:  []string{"st_geometrytype ( geoExpr )"},
	},
	"st_geomfromewkb": {
		Description: "This feature is in Public Preview.",
		Signatures:  []string{"st_geomfromewkb ( ewkbExpr )"},
	},
	"st_geomfromgeohash": {
		Description: "This feature is in Public Preview.",
		Signatures:  []string{"st_geomfromgeohash ( geohashExpr )"},
	},
	"st_geomfromgeojson": {
		Description: "This feature is in Public Preview.",
		Signatures:  []string{"st_geomfromgeojson ( geojsonExpr )"},
	},
	"st_geomfromtext": {
		Description: "This feature is in Public Preview.",
		Signatures:  []string{"st_geomfromtext ( wktExpr[, sridExpr] )"},
	},
	"st_geomfromwkb": {
		Description: "This feature is in Public Preview.",
		Signatures:  []string{"st_geomfromwkb ( wkbExpr[, sridExpr] )"},
	},
	"st_geomfromwkt": {
		Description: "This feature is in Public Preview.",
		Signatures:  []string{"st_geomfromwkt ( wktExpr[, sridExpr] )"},
	},
	"st_interiorringn": {
		Description: "This feature is in Public Preview.",
		Signatures:  []string{"st_interiorringn ( geoExpr, indexExpr )"},
	},
	"st_intersection": {
		Description: "This feature is in Public Preview.",
		Signatures:  []string{"st_intersection ( geoExpr1, geoExpr2 )"},
	},
	"st_intersects": {
		Description: "This feature is in Public Preview.",
		Signatures:  []string{"st_intersects ( geoExpr1, geoExpr2 )"},
	},
	"st_isempty": {
		Description: "This feature is in Public Preview.",
		Signatures:  []string{"st_isempty ( geoExpr )"},
	},
	"st_isvalid": {
		Description: "This feature is in Public Preview.",
		Signatures:  []string{"st_isvalid ( geoExpr )"},
	},
	"st_length": {
		Description: "This feature is in Public Preview.",
		Signatures:  []string{"st_length ( geoExpr )"},
	},
	"st_m": {
		Description: "This feature is in Public Preview.",
		Signatures:  []string{"st_m ( geoExpr )"},
	},
	"st_makeline": {
		Description: "This feature is in Public Preview.",
		Signatures:  []string{"st_makeline ( geoArray )"},
	},
	"st_makepolygon": {
		Description: "This feature is in Public Preview.",
		Signatures:  []string{"st_makepolygon ( outer[, innerArray] )"},
	},
	"st_multi": {
		Description: "This feature is in Public Preview.",
		Signatures:  []string{"st_multi ( geoExpr )"},
	},
	"st_ndims": {
		Description: "This feature is in Public Preview.",
		Signatures:  []string{"st_ndims ( geoExpr )"},
	},
	"st_npoints": {
		Description: "This feature is in Public Preview.",
		Signatures:  []string{"st_npoints ( geoExpr )"},
	},
	"st_numgeometries": {
		Description: "This feature is in Public Preview.",
		Signatures:  []string{"st_numgeometries ( geoExpr )"},
	},
	"st_numinteriorrings": {
		Description: "This feature is in Public Preview.",
		Signatures:  []string{"st_numinteriorrings ( geoExpr )"},
	},
	"st_perimeter": {
		Description: "This feature is in Public Preview.",
		Signatures:  []string{"st_perimeter ( geoExpr )"},
	},
	"st_point": {
		Description: "This feature is in Public Preview.",
		Signatures:  []string{"st_point ( x, y [, srid] )"},
	},
	"st_pointfromgeohash": {
		Description: "This feature is in Public Preview.",
		Signatures:  []string{"st_pointfromgeohash ( geohash )"},
	},
	"st_pointn": {
		Description: "This feature is in Public Preview.",
		Signatures:  []string{"st_pointn ( geoExpr, indexExpr )"},
	},
	"st_removepoint": {
		Description: "This feature is in Public Preview.",
		Signatures:  []string{"st_removepoint ( geoExpr, indexExpr )"},
	},
	"st_reverse": {
		Description: "This feature is in Public Preview.",
		Signatures:  []string{"st_reverse ( geoExpr )"},
	},
	"st_rotate": {
		Description: "This feature is in Public Preview.",
		Signatures:  []string{"st_rotate ( geoExpr, rotationAngle )"},
	},
	"st_scale": {
		Description: "This feature is in Public Preview.",
		Signatures:  []string{"st_scale ( geoExpr, xfactor, yfactor[, zfactor] )"},
	},
	"st_setpoint": {
		Description: "This feature is in Public Preview.",
		Signatures:  []string{"st_setpoint ( geo1Expr, indexExpr, geo2Expr )"},
	},
	"st_setsrid": {
		Description: "This feature is in Public Preview.",
		Signatures:  []string{"st_setsrid ( geo, srid )"},
	},
	"st_simplify": {
		Description: "This feature is in Public Preview.",
		Signatures:  []string{"st_simplify ( geo, tolerance )"},
	},
	"st_srid": {
		Description: "This feature is in Public Preview.",
		Signatures:  []string{"st_srid ( geoExpr )"},
	},
	"st_startpoint": {
		Description: "This feature is in Public Preview.",
		Signatures:  []string{"st_startpoint ( geoExpr )"},
	},
	"st_touches": {
		Description: "This feature is in Public Preview.",
		Signatures:  []string{"st_touches ( geo1, geo2 )"},
	},
	"st_transform": {
		Description: "This feature is in Public Preview.",
		Signatures:  []string{"st_transform ( geo, srid )"},
	},
	"st_translate": {
		Description: "This feature is in Public Preview.",
		Signatures:  []string{"st_translate ( geoExpr, xfactor, yfactor[, zfactor] )"},
	},
	"st_union": {
		Description: "This feature is in Public Preview.",
		Signatures:  []string{"st_union ( geo1, geo2 )"},
	},
	"st_union_agg": {
		Description: "This feature is in Public Preview.",
		Signatures:  []string{"st_union_agg ( geoCol )"},
	},
	"st_within": {
		Description: "This feature is in Public Preview.",
		Signatures:  []string{"st_within ( geo1, geo2 )"},
	},
	"st_x": {
		Description: "This feature is in Public Preview.",
		Signatures:  []string{"st_x ( geoExpr )"},
	},
	"st_xmax": {
		Description: "This feature is in Public Preview.",
		Signatures:  []string{"st_xmax ( geoExpr )"},
	},
	"st_xmin": {
		Description: "This feature is in Public Preview.",
		Signatures:  []string{"st_xmin ( geoExpr )"},
	},
	"st_y": {
		Description: "This feature is in Public Preview.",
		Signatures:  []string{"st_y ( geoExpr )"},
	},
	"st_ymax": {
		Description: "This feature is in Public Preview.",
		Signatures:  []string{"st_ymax ( geoExpr )"},
	},
	"st_ymin": {
		Description: "This feature is in Public Preview.",
		Signatures:  []string{"st_ymin ( geoExpr )"},
	},
	"st_z": {
		Description: "This feature is in Public Preview.",
		Signatures:  []string{"st_z ( geoExpr )"},
	},
	"st_zmax": {
		Description: "This feature is in Public Preview.",
		Signatures:  []string{"st_zmax ( geoExpr )"},
	},
	"st_zmin": {
		Description: "This feature is in Public Preview.",
		Signatures:  []string{"st_zmin ( geoExpr )"},
	},
	"stack": {
		Description: "Separates expr1, , exprN into numRows rows.",
		Signatures:  []string{"stack(numRows, expr1 [, ...] )"},
	},
	"startswith": {
		Description: "Returns true if expr begins with startExpr.",
		Signatures:  []string{"startswith(expr, startExpr)"},
	},
	"std": {
		Description: "Returns the sample standard deviation calculated from the values in the group. This function is a synonym for stddev aggregate function.",
		Signatures:  []string{"std ( [ALL | DISTINCT] expr ) [FILTER ( WHERE cond ) ]"},
	},
	"stddev": {
		Description: "Returns the sample standard deviation calculated from the values in the group. This function is a synonym for std aggregate function.",
		Signatures:  []string{"stddev ( [ALL | DISTINCT] expr ) [FILTER ( WHERE cond ) ]"},
	},
	"stddev_pop": {
		Description: "Returns the population standard deviation calculated from the values of a group.",
		Signatures:  []string{"stddev_pop ( [ALL | DISTINCT] expr ) [FILTER ( WHERE cond ) ]"},
	},
	"stddev_samp": {
		Description: "Returns the sample standard deviation calculated from the values of a group.",
		Signatures:  []string{"stddev_samp ( [ALL | DISTINCT] expr ) [FILTER ( WHERE cond ) ]"},
	},
	"str_to_map": {
		Description: "Creates a map after splitting the input into key-value pairs using delimiters.",
		Signatures:  []string{"str_to_map(expr [, pairDelim [, keyValueDelim] ] )"},
	},
	"string": {
		Description: "Casts the value expr to STRING. This function is a synonym for cast(expr AS STRING). See cast function for details.",
		Signatures:  []string{"string(expr)"},
	},
	"string_agg": {
		Description: "Returns concatenated STRING and BINARY values within a group.",
		Signatures:  []string{"string_agg ( [ALL | DISTINCT] expr [, delimiter] )  [ WITHIN GROUP (ORDER BY { sortKey [ sort_direction ] [ nulls_sort_oder ] } [, ...] ) ]  [ FILTER ( WHERE cond ) ]sort_direction  [ ASC | DESC ]nulls_sort_order  [ NULLS FIRST | NULLS LAST ]"},
	},
	"struct": {
		Description: "Creates a STRUCT with the specified field values.",
		Signatures:  []string{"struct(expr1 [[AS] alias1] ) [, ...] )"},
	},
	"substr": {
		Description: "Returns the substring of expr that starts at pos and is of length len. This function is a synonym for substring function.",
		Signatures:  []string{"substr(expr, pos [, len] )"},
	},
	"substring": {
		Description: "Returns the substring of expr that starts at pos and is of length len. This function is a synonym for substr function.",
		Signatures:  []string{"substring(expr, pos [, len])"},
	},
	"substring_index": {
		Description: "Returns the substring of expr before the count occurrence of the delimiter delim.",
		Signatures:  []string{"substring_index(expr, delim, count)"},
	},
	"sum": {
		Description: "Returns the sum calculated from the values of a group.",
		Signatures:  []string{"sum ( [ALL | DISTINCT] expr ) [FILTER ( WHERE cond ) ]"},
	},
	"table_changes": {
		Description: "Returns a log of changes to a Delta Lake table with Change Data Feed enabled.",
		Signatures:  []string{"table_changes ( table_str, start [, end ] )"},
	},
	"tan": {
		Description: "Returns the tangent of expr.",
		Signatures:  []string{"tan(expr)"},
	},
	"tanh": {
		Description: "Returns the hyperbolic tangent of expr.",
		Signatures:  []string{"tanh(expr)"},
	},
	"timediff": {
		Description: "Returns the difference between two timestamps measured in units. This function is a synonym for timestampdiff function.",
		Signatures:  []string{"timediff(unit, start, end)unit { MICROSECOND |   MILLISECOND |   SECOND |   MINUTE |   HOUR |   DAY |   WEEK |   MONTH |   QUARTER |   YEAR }"},
	},
	"timestamp": {
		Description: "Casts expr to TIMESTAMP. This function is a synonym for CAST(expr AS TIMESTAMP). For details see cast function.",
		Signatures:  []string{"timestamp(expr)"},
	},
	"timestamp_micros": {
		Description: "Creates a timestamp expr microseconds since UTC epoch.",
		Signatures:  []string{"timestamp_micros(expr)"},
	},
	"timestamp_millis": {
		Description: "Creates a timestamp expr milliseconds since UTC epoch.",
		Signatures:  []string{"timestamp_millis(expr)"},
	},
	"timestamp_seconds": {
		Description: "Creates timestamp expr seconds since UTC epoch.",
		Signatures:  []string{"timestamp_seconds(expr)"},
	},
	"timestampadd": {
		Description: "Adds value units to a timestamp expr.",
		Signatures:  []string{"timestampadd(unit, value, expr)unit { MICROSECOND |   MILLISECOND |   SECOND |   MINUTE |   HOUR |   DAY | DAYOFYEAR |   WEEK |   MONTH |   QUARTER |   YEAR }"},
	},
	"timestampdiff": {
		Description: "Returns the difference between two timestamps measured in units.",
		Signatures:  []string{"timestampdiff(unit, start, end)unit { MICROSECOND |   MILLISECOND |   SECOND |   MINUTE |   HOUR |   DAY |   WEEK |   MONTH |   QUARTER |   YEAR }"},
	},
	"tinyint": {
		Description: "Casts expr to TINYINT. This function is a synonym for CAST(expr AS TINYINT). See cast function for details.",
		Signatures:  []string{"tinyint(expr)"},
	},
	"to_avro": {
		Description: "Returns a Avro binary value with the specified input value.",
		Signatures:  []string{"to_avro(expr [, avroSchemaSpec] )"},
	},
	"to_binary": {
		Description: "Returns expr cast to BINARY based on fmt.",
		Signatures:  []string{"to_binary(expr [, fmt] )"},
	},
	"to_char": {
		Description: "Returns expr cast to STRING using formatting fmt.",
		Signatures:  []string{"to_char(expr, { numericFormat | datetimeFormat | stringFormat } )numericFormat  { ' [ S ] [ L | $ ]      [ 0 | 9 | G | , ] [...]      [ . | D ]      [ 0 | 9 ] [...]      [ L | $ ] [ PR | MI | S ] ' }"},
	},
	"to_csv": {
		Description: "Returns a CSV string with the specified struct value.",
		Signatures:  []string{"to_csv(expr [, options] )"},
	},
	"to_date": {
		Description: "Returns expr cast to a date using an optional formatting.",
		Signatures:  []string{"to_date(expr [, fmt] )"},
	},
	"to_geography": {
		Description: "This feature is in Public Preview.",
		Signatures:  []string{"to_geography ( geoRepExpr )"},
	},
	"to_geometry": {
		Description: "This feature is in Public Preview.",
		Signatures:  []string{"to_geometry ( geoRepExpr )"},
	},
	"to_json": {
		Description: "Returns a JSON string with the STRUCT or VARIANT specified in expr.",
		Signatures:  []string{"to_json(expr [, options] )"},
	},
	"to_number": {
		Description: "Returns expr cast to DECIMAL using formatting fmt.",
		Signatures:  []string{"to_number(expr, fmt)fmt  { ' [ MI | S ] [ L | $ ]      [ 0 | 9 | G | , ] [...]      [ . | D ]      [ 0 | 9 ] [...]      [ L | $ ] [ PR | MI | S ] ' }"},
	},
	"to_timestamp": {
		Description: "Returns expr cast to a timestamp using an optional formatting.",
		Signatures:  []string{"to_timestamp(expr [, fmt] )"},
	},
	"to_unix_timestamp": {
		Description: "Returns the timestamp in expr as a UNIX timestamp.",
		Signatures:  []string{"to_unix_timestamp(expr [, fmt] )"},
	},
	"to_utc_timestamp": {
		Description: "Returns the timestamp at UTC for a timestamp expr at timeZone.",
		Signatures:  []string{"to_utc_timestamp(expr, timeZone)"},
	},
	"to_varchar": {
		Description: "Returns expr cast to STRING using formatting fmt.",
		Signatures:  []string{"to_varchar(expr, { numericFormat | datetimeFormat | stringFormat } )numericFormat  { ' [ S ] [ L | $ ]      [ 0 | 9 | G | , ] [...]      [ . | D ]      [ 0 | 9 ] [...]      [ L | $ ] [ PR | MI | S ] ' }"},
	},
	"to_variant_object": {
		Description: "Convert a complex expression (ARRAY, MAP, STRUCT) into a VARIANT where maps and structs are converted to variant objects which are unordered. MAP can only have STRING keys.",
		Signatures:  []string{"to_variant_object(expr)"},
	},
	"to_xml": {
		Description: "Returns an XML string with the struct or variant specified in expr.",
		Signatures:  []string{"to_xml(expr [, options] )"},
	},
	"transform": {
		Description: "Transforms elements in an array in expr using the function func.",
		Signatures:  []string{"transform(expr, func)"},
	},
	"transform_keys": {
		Description: "Transforms keys in a map in expr using the function func.",
		Signatures:  []string{"transform_keys(expr, func)"},
	},
	"transform_values": {
		Description: "Transforms values in a map in expr using the function func.",
		Signatures:  []string{"transform_values(expr, func)"},
	},
	"translate": {
		Description: "Returns an expr where all characters in from have been replaced with those in to.",
		Signatures:  []string{"translate(expr, from, to)"},
	},
	"trim": {
		Description: "Removes the leading or trailing space characters from str.",
		Signatures:  []string{"trim(str)trim(BOTH FROM str)"},
	},
	"trunc": {
		Description: "Returns a date with the date truncated to the unit specified by the format model unit.",
		Signatures:  []string{"trunc(expr, unit)"},
	},
	"try_add": {
		Description: "Returns the sum of expr1 and expr2, or NULL in case of error.",
		Signatures:  []string{"try_add ( expr1 , expr2 )"},
	},
	"try_aes_decrypt": {
		Description: "Decrypts a binary produced using AES encryption and returns NULL if that fails for any reason.",
		Signatures:  []string{"try_aes_decrypt(expr, key [, mode [, padding [, aad]]])"},
	},
	"try_avg": {
		Description: "Returns the mean calculated from values of a group. If there is an overflow, returns NULL.",
		Signatures:  []string{"try_avg( [ALL | DISTINCT] expr) [FILTER ( WHERE cond ) ]"},
	},
	"try_cast": {
		Description: "Returns the value of sourceExpr cast to the targetType if the cast is supported; otherwise, it returns NULL, provided that the cast from the type of sourceExpr to targetType is supported. If the so...",
		Signatures:  []string{"try_cast(sourceExpr AS targetType)"},
	},
	"try_divide": {
		Description: "Returns dividend divided by divisor, or NULL if divisor is 0.",
		Signatures:  []string{"try_divide(dividend, divisor)"},
	},
	"try_element_at": {
		Description: "Returns the element of an arrayExpr at index, or NULL if index is out of bound.",
		Signatures:  []string{"try_element_at(arrayExpr, index)"},
	},
	"try_mod": {
		Description: "Returns the remainder after dividend / divisor or NULL ifdivisor is 0.",
		Signatures:  []string{"try_mod(dividend, divisor)"},
	},
	"try_multiply": {
		Description: "Returns multiplier multiplied by multiplicand, or NULL on overflow.",
		Signatures:  []string{"try_multiply(multiplier, multiplicand)"},
	},
	"try_parse_json": {
		Description: "Returns a VARIANT value from the jsonStr if possible, or NULL if not possible.",
		Signatures:  []string{"try_parse_json ( jsonStr )"},
	},
	"try_reflect": {
		Description: "Call a method with reflection, returning NULL if the method returns an exception.",
		Signatures:  []string{"try_reflect(class, method [, arg1] [, ...])"},
	},
	"try_secret": {
		Description: "Extracts a secret value with the given scope and key from Databricks secret service, or NULL if the key cannot be retrieved.",
		Signatures:  []string{"try_secret ( scope, key )"},
	},
	"try_subtract": {
		Description: "Returns the subtraction of expr2 from expr1, or NULL on overflow.",
		Signatures:  []string{"try_subtract ( expr1 , expr2 )"},
	},
	"try_sum": {
		Description: "Returns the sum calculated from values of a group, or NULL if there is an overflow.",
		Signatures:  []string{"try_sum ( [ALL | DISTINCT] expr ) [FILTER ( WHERE cond ) ]"},
	},
	"try_to_binary": {
		Description: "Returns expr cast to BINARY based on fmt, or NULL if the input is not valid.",
		Signatures:  []string{"try_to_binary(expr [, fmt] )"},
	},
	"try_to_geography": {
		Description: "This feature is in Public Preview.",
		Signatures:  []string{"try_to_geography ( geoRepExpr )"},
	},
	"try_to_geometry": {
		Description: "This feature is in Public Preview.",
		Signatures:  []string{"try_to_geometry ( geoRepExpr )"},
	},
	"try_to_number": {
		Description: "Returns expr cast to DECIMAL using formatting fmt, or NULL if expr does not match the format.",
		Signatures:  []string{"try_to_number(expr, fmt)fmt  { ' [ MI | S ] [ L | $ ]      [ 0 | 9 | G | , ] [...]      [ . | D ]      [ 0 | 9 ] [...]      [ L | $ ] [ PR | MI | S ] ' }"},
	},
	"try_to_timestamp": {
		Description: "Returns expr cast to a timestamp using an optional formatting, or NULL if the cast fails.",
		Signatures:  []string{"try_to_timestamp(expr [, fmt] )"},
	},
	"try_url_decode": {
		Description: "Translates a string back from application/x-www-form-urlencoded format, or NULL if the format is incorrect.",
		Signatures:  []string{"try_url_decode(str)"},
	},
	"try_validate_utf8": {
		Description: "Returns the input value if it corresponds to a valid UTF-8 string, or NULL otherwise.",
		Signatures:  []string{"try_validate_utf8(strExpr)"},
	},
	"try_variant_get": {
		Description: "Extracts a value of type type from variantExpr, specified by path, or NULL if it is not possible to cast to the target type.",
		Signatures:  []string{"try_variant_get ( variantExpr, path, type )"},
	},
	"try_zstd_decompress": {
		Description: "Returns value decompressed with Zstandard compression. On decompression failure, the function returns NULL",
		Signatures:  []string{"try_zstd_decompress ( value )"},
	},
	"typeof": {
		Description: "Return a DDL-formatted type string for the data type of the input.",
		Signatures:  []string{"typeof(expr)"},
	},
	"ucase": {
		Description: "Returns expr with all characters changed to uppercase according to the collation of expr. This function is a synonym for upper function.",
		Signatures:  []string{"ucase(expr)"},
	},
	"unbase64": {
		Description: "Returns a decoded base64 string as binary.",
		Signatures:  []string{"unbase64(expr)"},
	},
	"unhex": {
		Description: "Converts hexadecimal expr to BINARY.",
		Signatures:  []string{"unhex(expr)"},
	},
	"uniform": {
		Description: "Returns a random value with independent and identically distributed values within the specified range of numbers.",
		Signatures:  []string{"uniform (boundaryExpr1, boundaryExpr2 [, seed] )"},
	},
	"unix_date": {
		Description: "Returns the number of days since 1970-01-01.",
		Signatures:  []string{"unix_date(expr)"},
	},
	"unix_micros": {
		Description: "Returns the number of microseconds since 1970-01-01 00:00:00 UTC.",
		Signatures:  []string{"unix_micros(expr)"},
	},
	"unix_millis": {
		Description: "Returns the number of milliseconds since 1970-01-01 00:00:00 UTC.",
		Signatures:  []string{"unix_millis(expr)"},
	},
	"unix_seconds": {
		Description: "Returns the number of seconds since 1970-01-01 00:00:00 UTC.",
		Signatures:  []string{"unix_seconds(expr)"},
	},
	"unix_timestamp": {
		Description: "Returns the UNIX timestamp of current or specified time.",
		Signatures:  []string{"unix_timestamp([expr [, fmt] ] )"},
	},
	"upper": {
		Description: "Returns expr with all characters changed to uppercase according to the collation of expr. This function is a synonym for ucase function.",
		Signatures:  []string{"upper(expr)"},
	},
	"url_decode": {
		Description: "Translates a string back from application/x-www-form-urlencoded format.",
		Signatures:  []string{"url_decode(str)"},
	},
	"url_encode": {
		Description: "Translates a string into application/x-www-form-urlencoded format.",
		Signatures:  []string{"url_encode(str)"},
	},
	"user": {
		Description: "Returns the user executing the statement. This function is an alias for current_user.",
		Signatures:  []string{"user()"},
	},
	"uuid": {
		Description: "Returns a universally unique identifier UUID string.",
		Signatures:  []string{"uuid()"},
	},
	"validate_utf8": {
		Description: "Returns the input value if it corresponds to a valid UTF-8 string, or raises INVALID_UTF8_STRING otherwise.",
		Signatures:  []string{"validate_utf8(strExpr)"},
	},
	"var_pop": {
		Description: "Returns the population variance calculated from values of a group.",
		Signatures:  []string{"var_pop ( [ALL | DISTINCT] expr ) [FILTER ( WHERE cond ) ]"},
	},
	"var_samp": {
		Description: "Returns the sample variance calculated from values of a group. This function is a synonym for variance aggregate function.",
		Signatures:  []string{"var_samp ( [ALL | DISTINCT] expr ) [FILTER ( WHERE cond ) ]"},
	},
	"variance": {
		Description: "Returns the sample variance calculated from values of a group. This function is a synonym for var_samp aggregate function.",
		Signatures:  []string{"variance ( [ALL | DISTINCT] expr ) [FILTER ( WHERE cond ) ]"},
	},
	"variant_explode": {
		Description: "Returns a set of rows by un-nesting input.",
		Signatures:  []string{"variant_explode ( input )"},
	},
	"variant_explode_outer": {
		Description: "Returns a set of rows by un-nesting variantExpr using outer semantics.",
		Signatures:  []string{"variant_explode_outer ( variantExpr )"},
	},
	"variant_get": {
		Description: "Extracts a value of type from variantExpr, specified by path.",
		Signatures:  []string{"variant_get ( variantExpr, path, type )"},
	},
	"vector_search": {
		Description: "This feature is in Public Preview.",
		Signatures:  []string{"query_text"},
	},
	"version": {
		Description: "Returns the Apache Spark version.",
		Signatures:  []string{"version()"},
	},
	"weekday": {
		Description: "Returns the day of the week of expr. This function is a synonym for extract(DAYOFWEEK_ISO FROM expr) - 1.",
		Signatures:  []string{"weekday(expr)"},
	},
	"weekofyear": {
		Description: "Returns the week of the year of expr.",
		Signatures:  []string{"weekofyear(expr)"},
	},
	"width_bucket": {
		Description: "Returns the bucket number for a value in an equi-width histogram.",
		Signatures:  []string{"width_bucket(expr, minExpr, maxExpr, numBuckets)"},
	},
	"window_time": {
		Description: "Returns the inclusive end time of a time-window produced by the window or session_window functions.",
		Signatures:  []string{"window_time(window)"},
	},
	"xpath": {
		Description: "Returns values within the nodes of xml that match xpath.",
		Signatures:  []string{"xpath(xml, xpath)"},
	},
	"xpath_boolean": {
		Description: "Returns true if the xpath expression evaluates to true, or if a matching node in xml is found.",
		Signatures:  []string{"xpath_boolean(xml, xpath)"},
	},
	"xpath_double": {
		Description: "Returns a DOUBLE value from an XML document.",
		Signatures:  []string{"xpath_double(xml, xpath)"},
	},
	"xpath_float": {
		Description: "Returns a FLOAT value from an XML document.",
		Signatures:  []string{"xpath_float(xml, xpath)"},
	},
	"xpath_int": {
		Description: "Returns an INTEGER value from an XML document.",
		Signatures:  []string{"xpath_int(xml, xpath)"},
	},
	"xpath_long": {
		Description: "Returns an BIGINT value from an XML document.",
		Signatures:  []string{"xpath_long(xml, xpath)"},
	},
	"xpath_number": {
		Description: "Returns a DOUBLE value from an XML document.",
		Signatures:  []string{"xpath_number(xml, xpath)"},
	},
	"xpath_short": {
		Description: "Returns an SMALLINT value from an XML document.",
		Signatures:  []string{"xpath_short(xml, xpath)"},
	},
	"xpath_string": {
		Description: "Returns the contents of the first XML node that matches the XPath expression.",
		Signatures:  []string{"xpath_string(xml, xpath)"},
	},
	"xxhash64": {
		Description: "Returns a 64-bit hash value of the arguments.",
		Signatures:  []string{"xxhash64(expr1 [, ...] )"},
	},
	"year": {
		Description: "Returns the year component of expr. This function is a synonym for extract(YEAR FROM expr).",
		Signatures:  []string{"year(expr)"},
	},
	"zeroifnull": {
		Description: "Returns 0 if expr is NULL, or expr otherwise. This function is a synonym for coalesce(expr, 0).",
		Signatures:  []string{"zeroifnull(expr)"},
	},
	"zip_with": {
		Description: "Merges the arrays in expr1 and expr2, element-wise, into a single array using func.",
		Signatures:  []string{"zip_with(expr1, expr2, func)"},
	},
	"zstd_compress": {
		Description: "Returns value compressed with Zstandard compression.",
		Signatures:  []string{"zstd_compress ( value [, level [, streaming_mode ] ] )"},
	},
	"zstd_decompress": {
		Description: "Returns value decompressed with Zstandard compression. On decompression failure, it throws an exception.",
		Signatures:  []string{"zstd_decompress ( value )"},
	},
}
